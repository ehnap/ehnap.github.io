<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>谈谈 2020 年的读书 FLAG</title>
    <url>/2020/12/30/2020-read-flag/</url>
    <content><![CDATA[<p>2020 年初的时候立了个 FLAG ，说是月读书量保一争二，争取输出一些读书笔记。最终保一是勉强完成了，中间也找了几本薄一点的凑了个数，争二就没争上。不过总的结果还是好的，因为收获的就不仅仅是完成任务的喜悦这么简单。</p>
<span id="more"></span>
<p>完整读完的 12 本，输出笔记 5 篇。在读 2 本。建立了待读书单，目前内有 32 本，明年也会在其中挑一部分来读。建立了自己的书籍数据库。了解了很多跟书籍相关的东西，算是半只脚踏进读书的圈子。</p>
<p>我会把目前已有的书籍登记在库，对阅读状态加以标注，对已读书籍会进行打分，有读书笔记的也要关联起来，便于后期分析各个出版社或品牌书籍质量，这个是很有意思的一件事情。</p>
<p>我的打分机制非常简单、也非常主观：5 星制。<br>★☆☆☆☆：内容差、名不副实、方法论书籍但不具有可操作性、纯鸡汤……<br>★★☆☆☆：写作内容尚可、方法论书籍可操作但不实用、单一技术手册……<br>★★★☆☆：中规中矩、对自己有一定帮助、可以扩充见识……<br>★★★★☆：写作内容优秀、能带来不同领域的突破性认识、方法论书籍提供的方法论成体系并且有很强的可操作性……<br>★★★★★：能改变人生观，价值观，世界观之一、我个人最喜爱的……</p>
<p>下面简单说说今年读的这些书，有读书笔记的就直接附连接了，没有的就简要谈谈。(书籍信息不全的是用 kindle 看的，不太确定版本)</p>
<h2 id="《谈美》"><a href="#《谈美》" class="headerlink" title="《谈美》"></a>《谈美》</h2><p>作者：朱光潜<br>出版社：湖南文艺出版社<br>品牌：博集天卷<br>评分：★★★★☆<br>读书笔记：<a href="https://ehnap.me/2020/11/17/i-do-not-understand-aesthetics/">关于美学其实我一无所知</a></p>
<h2 id="《文化苦旅》"><a href="#《文化苦旅》" class="headerlink" title="《文化苦旅》"></a>《文化苦旅》</h2><p>作者：余秋雨<br>评分：★★★☆☆</p>
<p>文化苦旅这本书很有意思，但我没有写读书笔记，对于这本书的评分我是比较纠结的，看之前我对余秋雨其实是存在一些偏见的，我觉得他的散文华而不实，纯纯的是词藻的堆砌。但是毕竟没有完整的看过他的书，这种批判显得有点太不客观了。所以我是抱着批判的心态去看待这本书。最开始我是要给这本书打 2 星的，不过后来看完之后，确实觉得他还是写出点东西的，华而不实形容他并不是太贴切，所以调整到 3 星。</p>
<h2 id="《读懂一本书：樊登读书法》"><a href="#《读懂一本书：樊登读书法》" class="headerlink" title="《读懂一本书：樊登读书法》"></a>《读懂一本书：樊登读书法》</h2><p>作者：樊登<br>评分：★★☆☆☆</p>
<p>今年两本讲读书方法的书，立了 FLAG 之后，便寻思先学学别人怎么读书的。然后年初的时候，樊登读书会很火，就看了这本书。不过看完之后，通篇提炼出来的就是：想把书读透了，得给别人讲。</p>
<h2 id="《高效阅读：20分钟读懂一本书》"><a href="#《高效阅读：20分钟读懂一本书》" class="headerlink" title="《高效阅读：20分钟读懂一本书》"></a>《高效阅读：20分钟读懂一本书》</h2><p>作者：渡边康弘<br>评分：★★☆☆☆</p>
<p>这本书，加上我以前看过的日本人写的数学书和编程书，给我留下了这样一个印象，日本人的书非常擅长搞深入浅出，凡是讲方法的书籍，方法都具有很强的可实操性，但是我太懒了，也没有按照里边提供的方法去读。不过在我阅读的时候确实有借鉴一些它提供的思路。</p>
<h2 id="《活着》"><a href="#《活着》" class="headerlink" title="《活着》"></a>《活着》</h2><p>作者：余华<br>评分：★★★★☆</p>
<p>这本书我印象很深刻，没读之前其实已经听说过很久了，没有人说它不好。在我过年之后回去工作的飞机上，一口气读完了。直接把我看哭了……</p>
<h2 id="《阅读是一座随身携带的避难所》"><a href="#《阅读是一座随身携带的避难所》" class="headerlink" title="《阅读是一座随身携带的避难所》"></a>《阅读是一座随身携带的避难所》</h2><p>作者：威廉·萨默赛特·毛姆<br>出版社：北京联合出版公司<br>品牌：联合读创<br>译者：罗长利<br>评分：★★★★☆<br>读书笔记：<a href="https://ehnap.me/2020/03/31/maugham-reading-notes/">一篇读《毛姆读书随笔》的随笔</a></p>
<h2 id="《局外人》"><a href="#《局外人》" class="headerlink" title="《局外人》"></a>《局外人》</h2><p>作者：阿尔贝·加缪<br>出版社：江苏凤凰文艺出版社<br>品牌：读客<br>译者：金祎<br>评分：★★★★☆<br>读书笔记：<a href="https://ehnap.me/2020/06/13/absurdity-and-reality/">荒诞的尽头也许是真实……</a></p>
<h2 id="《干校六记》"><a href="#《干校六记》" class="headerlink" title="《干校六记》"></a>《干校六记》</h2><p>作者：杨绛<br>评分：★★★☆☆</p>
<p>这本书之所以选来读，完全是因为感觉每月一本的任务要完不成了，感觉挺薄的，然后别人说挺好的，我就拿来凑数了。好是挺好，可以了解那个时期的事情。值得一提的是，这里边其实很多内容都挺内涵的，用今天的话讲是不是应该叫 YYGQ 。</p>
<h2 id="《房思琪的初恋乐园》"><a href="#《房思琪的初恋乐园》" class="headerlink" title="《房思琪的初恋乐园》"></a>《房思琪的初恋乐园》</h2><p>作者：林奕含<br>出版社：北京联合出版公司<br>品牌：磨铁图书（Xiron）<br>评分：★★★★★<br>读书笔记：<a href="https://ehnap.me/2020/07/15/a-book-about-child-sexual-abuse/">连封皮都透着压抑的书</a></p>
<h2 id="《人性的弱点》"><a href="#《人性的弱点》" class="headerlink" title="《人性的弱点》"></a>《人性的弱点》</h2><p>作者：戴尔·卡耐基<br>评分：★☆☆☆☆</p>
<p>这书应该是在微信读书上看的，花了一个下午，看完之后就觉得挺没意思的，我还以为是鸡汤文。</p>
<h2 id="《禅与摩托车维修艺术》"><a href="#《禅与摩托车维修艺术》" class="headerlink" title="《禅与摩托车维修艺术》"></a>《禅与摩托车维修艺术》</h2><p>作者：罗伯特·M·波西格<br>出版社：重庆出版社<br>译者：张国辰、王培沛<br>评分：★★★★★</p>
<p>yyds！这本书没有写读书笔记，是因为我一直不知道怎么下笔，才能配得上这本书的内容，它给我带来的是世界观的改变。基本上逢人就推，但是大家都以为我看的是修摩托车的书……太强了。明年打算重读一遍，也要把笔记补上了。</p>
<h2 id="《态度》"><a href="#《态度》" class="headerlink" title="《态度》"></a>《态度》</h2><p>作者：吴军<br>出版社：中信出版集团<br>评分：★★★☆☆<br>读书笔记：<a href="https://ehnap.me/2020/09/06/what-patterns-mean-to-ordinary-people/">格局对普通人有意义吗？</a></p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>迟到的 2021 年的读书 FLAG 总结</title>
    <url>/2022/01/09/2021-read-flag/</url>
    <content><![CDATA[<p>本来应该在 2021 年的最后一天完成的总结，竟然迟到了 9 天，可见拖延症已经达到了多么严重的地步！2021 年的保一争二 Flag 很遗憾是失败了，公众号的输出也不理想。主要的原因还是归结还是懒，工作也比较忙，导致个人 OKR 全面拉垮，多少有点罪恶感。</p>
<span id="more"></span>
<p>完整读完的 10 本，输出笔记 3 篇。在读 2 本。待买书单增加到 75 本，同比增长 134% 。其实这里边今年也有消化一部分(就是买了，不一定是看了)，但是还在不断增加。</p>
<p>打分机制：5 星制。<br>★☆☆☆☆：内容差、名不副实、方法论书籍但不具有可操作性、纯鸡汤……<br>★★☆☆☆：写作内容尚可、方法论书籍可操作但不实用、单一技术手册……<br>★★★☆☆：中规中矩、对自己有一定帮助、可以扩充见识……<br>★★★★☆：写作内容优秀、能带来不同领域的突破性认识、方法论书籍提供的方法论成体系并且有很强的可操作性……<br>★★★★★：能改变人生观，价值观，世界观之一、我个人最喜爱的……</p>
<p>下面简单说说 2021 年读的这些书，有读书笔记的就直接附连接了，没有的就简要谈谈。(书籍信息不全的是用 kindle 看的，不太确定版本)</p>
<h2 id="《文心》"><a href="#《文心》" class="headerlink" title="《文心》"></a>《文心》</h2><p>作者：夏丏尊、叶圣陶<br>出版社：生活·读书·新知三联书店<br>品牌：生活·读书·新知三联书店<br>评分：★★★★☆<br>读书笔记：<a href="https://ehnap.me/2021/02/17/literary-mind-notes/">写作入门到底应该看点什么</a></p>
<h2 id="《呐喊：鲁迅短篇小说集》"><a href="#《呐喊：鲁迅短篇小说集》" class="headerlink" title="《呐喊：鲁迅短篇小说集》"></a>《呐喊：鲁迅短篇小说集》</h2><p>作者：鲁迅<br>出版社：天津人民出版社<br>品牌：果麦文化<br>评分：★★★★☆</p>
<p>我买的果麦的这本，完整收录鲁迅从1918至1922年所作小说十四篇、自序一篇，以及陈丹青先生专门为新版撰写的读后记长文一篇。我对果麦也算是真爱粉了，因为让我第一次感兴趣重读鲁迅是前年吧，在公司附近的书店看的《朝花夕拾（鲁迅散文精选集）》，那个时候发现看鲁迅就跟小时候的印象完全不一样了，然后也开始注意果麦这个品牌。不过这个品牌目前被某些轻型纸斗士喷的不轻，不过我觉得编的内容还是不错的。</p>
<p>说回这本书自身，里边有一些小说其实都是耳熟能详的，也是之前其实有读过的，但是这次再读，还是觉得不一样。那种感觉就好像，上学的时候，看到的其实是老师或者教材本身想要让我看到的鲁迅，而现在看已经可以绕过这一层，就好像又重新认识了鲁迅。有时候我总是在想，如果他活在现在，还能火成这样吗？这是一个问题……这本看完之后就不打算再单买鲁迅的书了，打算买一套鲁迅文集，已记入待办。</p>
<h2 id="《必然》"><a href="#《必然》" class="headerlink" title="《必然》"></a>《必然》</h2><p>作者：凯文·凯利<br>出版社：电子工业出版社<br>品牌：东西文库<br>译者：周峰、董理、金阳<br>评分：★★★★☆<br>读书笔记：<a href="https://ehnap.me/2021/06/28/inevitable/">未来已来，样子跟他说的还真差不多</a></p>
<h2 id="《富爸爸，穷爸爸》"><a href="#《富爸爸，穷爸爸》" class="headerlink" title="《富爸爸，穷爸爸》"></a>《富爸爸，穷爸爸》</h2><p>作者：罗伯特・T・清崎 &#x2F; 莎伦・L・莱希特<br>评分：★★★★☆</p>
<p>这本书作为财商提升的入门书籍，被各种自媒体推荐烂了，惭愧我是今年才看。这本书给了四分，如果对于财商部分缺乏基本的概念，作为启蒙是比较不错的，可以给到一个比较新的视角。但是毕竟书已经出版 20 年了，里边一些比较实际的操作观点其实已经并不太灵了，入门不错，实操性一般。</p>
<h2 id="《大山里的小诗人》"><a href="#《大山里的小诗人》" class="headerlink" title="《大山里的小诗人》"></a>《大山里的小诗人》</h2><p>作者：『是光』的孩子们<br>出版社：江苏凤凰文艺出版社<br>品牌：果麦文化<br>评分：★★★★★<br>读书笔记：<a href="https://ehnap.me/2021/07/12/youthful-bliss/">『眼中有泪，心中有光』，年轻真好</a></p>
<h2 id="《姜二嫚的诗》"><a href="#《姜二嫚的诗》" class="headerlink" title="《姜二嫚的诗》"></a>《姜二嫚的诗》</h2><p>作者：姜二嫚<br>出版社：浙江文艺出版社<br>品牌：果麦文化<br>评分：★★★☆☆<br>读书笔记：同上</p>
<h2 id="《睡眠革命》"><a href="#《睡眠革命》" class="headerlink" title="《睡眠革命》"></a>《睡眠革命》</h2><p>作者：尼克·利特尔黑尔斯<br>出版社：贵州科技出版社<br>品牌：未读<br>译者：王敏<br>评分：★★★★☆</p>
<p>今年的上半年饱受失眠的困扰，曾经有一周里两天完全没睡觉。可能有工作的压力，也有睡觉环境差的原因，后来没办法，也想在书里找找答案，当时好像是看樊登推过这本书，大概了解了一下 R90 睡眠法，觉得这书应该有点东西，就买回来看了一下。R90 睡眠法确实是比较颠覆的一种观点，但是我根据书上说的，实际体验了一下，这种说法我觉得确实比 8 小时睡眠的说法要靠谱得多。所以关于睡眠的理论，这本书介绍的还是挺有意思的。但是后边实操比较适合那种睡眠质量想从好提升到更好，包括怎么布置房间、选床垫等等，但是如果是因为环境差导致睡眠质量差想把睡眠质量变好，其实没啥作用，只能把他说的相关的环境因素调整过来，但是我如果能调整过来，可能我也不用看这本书了。所以最终给到四星。如果它能解决我的失眠，那它应该就是五星了，但是没有…… 这本书后边的实操方法我就没怎么看了，主要是当时不具备实操的条件，后边如果要是打算布置一下卧室，会把它翻出来当参考手册。</p>
<h2 id="《十分钟冥想》"><a href="#《十分钟冥想》" class="headerlink" title="《十分钟冥想》"></a>《十分钟冥想》</h2><p>作者：安迪·普迪科姆<br>评分：★★★★☆</p>
<p>当时睡不着觉的时候，也有接触到冥想，基本每天晚上睡前都要听着冥想的指导音频，才能入睡。改善睡眠，这是我接触冥想的初衷。不过后来对这个东西深入的了解了一下，而且自身也有一些体验，也参加了公司冥想相关的组织，当时看有人分享这本书，就第一时间读了。算是一个手册类的书籍，讲如何去练习冥想，冥想的好处等等。优势的话就是书中冥想的练习方法，可操作性很大，让人很容易进入状态，算是把这种比较抽象的东西，描述的比较让人能接受的一本手册了，内容还算不错。</p>
<h2 id="《倾城之恋》"><a href="#《倾城之恋》" class="headerlink" title="《倾城之恋》"></a>《倾城之恋》</h2><p>作者：张爱玲<br>出版社：北京十月文艺出版社<br>品牌：新经典<br>评分：★★★★☆</p>
<p>张爱玲的书之前没有读过，但是对于一些比较经典的名句就知道一些。今年也读了一下，因为自己对红楼梦也是非常感兴趣，读她的书，就会觉得红楼梦的味道特别重，那种人物衣着描写，其实要是把它单拎出来，就会觉得跟红楼梦一样。当然她本人确实对红楼梦也是非常痴迷的，所以我也买了她的《红楼梦魇》，但是还没有看。</p>
<p>这本书是张爱玲中短篇小说集。收录创作于1943年至1944年创作的中短篇小说《第一炉香》《第二炉香》《茉莉香片》《心经》《封锁》《倾城之恋》《琉璃瓦》《金锁记》《连环套》。其实整体看下来，一方面是梁文道说的那样，可以透过张爱玲的这些爱情故事看到那个年代的社会状态；另一方面单从爱情故事的角度来看，张爱玲的文字我个人觉得是比较丧的，写出来的故事基本没啥好结局，可能倾城之恋在这些里还算是相对来说不错的结局。但是总归写出了爱情现实的残酷，也算有它的意义。我是觉得年轻妹纸看看，多对爱情多点戒备别上头，上点岁数的小姐姐就别看了，看了就觉得对爱情更没什么追求。</p>
<h2 id="《小径分岔的花园》"><a href="#《小径分岔的花园》" class="headerlink" title="《小径分岔的花园》"></a>《小径分岔的花园》</h2><p>作者：豪尔赫·路易斯·博尔赫斯<br>出版社：上海译文出版社<br>品牌：博尔赫斯全集<br>译者：王永年<br>评分：★★★★☆</p>
<p>博尔赫斯我是在梁文道的节目里了解到的，当时他就介绍了这本书，听了一下，觉得值得一看，就买来看了。读完之后整体的感觉是，字我都认识，但是没看懂。这个没看懂主要是指，写法太高级，感觉就是在玩写作。举例别人要写书是写书，他不直接写，它是写一篇故事来描述要写的书，还有各种各样的花样。而且文化梗太多，就是一看就知道这应该是个梗，但是因为书读得太少，根本不知道这是啥梗，有一部分注释上标了还好，有的没标，读完就是没有读出乐趣来，但是看着就知道不简单，但是因为读不懂，所以暂时也只能给四星。整本的话其实也就《小径分岔的花园》这篇还算是比较好读的。今年还买了他的《杜撰集》，打算再挑战一下。</p>
<h2 id="《如何成为不完美主义者》"><a href="#《如何成为不完美主义者》" class="headerlink" title="《如何成为不完美主义者》"></a>《如何成为不完美主义者》</h2><p>作者：斯蒂芬·盖斯<br>出版社：江西人民出版社<br>品牌：后浪<br>译者：陈晓颖<br>评分：★★★★☆</p>
<p>这本书也是看了一个 B 站 up 主推荐，但是感觉说的症状也是全中，所以毫不犹豫地买了看了，不得不说作者对完美主义的分析是十分透彻的，也针对这种状况给出了比较具有操作性的指导意见，如果下定决心要破除这种状态，这本书是很好的一个选择。而且有很多观点其实也是比较颠覆性的，非常值得一看。作者的成名作其实是《微习惯》，配合食用更佳，我已经把它加入待买书单。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总体来看今年读的书质量整体水平是比较不错的，一般都在四星左右，没有二星。唯一一个五星给了《大山里的小诗人》，对小孩写的诗真的是毫无抵抗力，那种奇思妙想，那种纯真是大人做不到的。当然今年也有一些书看了之后昏昏欲睡，没能坚持读下去。比如《西西弗神话》，当时因为看了加缪的《局外人》觉得不错，这个又是经典，就买来看，结果看了两页就想睡觉；再比如《沉思录》，也是看了两页实在坚持不下去了。在读书籍一本是《建立边界感》，年底买的，正在读，没读完，只能排在明年的 OKR 里了，另外一本是蒋勋的《孤独六讲》，很早就买了，但是看了一部分之后中间断了，年末又重拾起来，也还没读完，只能排到明年 OKR 中了。</p>
<p>希望明年可以超额完成 OKR ……</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>连封皮都透着压抑的书</title>
    <url>/2020/07/15/a-book-about-child-sexual-abuse/</url>
    <content><![CDATA[<p>六月份的预定目标很早就读完了，懒癌发作，一直拖到现在才写。</p>
<p>书的腰封上这样写道：<strong>「向死而生的文学绝唱」</strong>。对于这个说法，我表示十二分的赞同，这本书就是《房思琪的初恋乐园》(下称房书)。</p>
<span id="more"></span>

<p>主线：十三岁的少女房思琪被中年教师李国华诱奸，保持纯粹的性关系长达五年之久，无人理解、不能自救最终精神崩溃。副线：房思琪和朋友刘怡婷的文学领路人——邻居许伊纹，饱受家暴痛苦，最终遇到毛毛，终于解脱。</p>
<p>这本书是豆瓣2018年的高分图书，我很早就听说过。也很早就翻看过，但是看了几页就看不下去了，“最初的感觉”是看开头觉得文笔诡异，用了很多花哨的比喻，有很多语言也读不通，就没再看了。这次是因为买了实体书，就耐着性子看了下去。当我读到中间的时候，就非常能理解这本书的文风了，当我看完的时候，反而觉得如果开头不是这样的笔触，倒是不对了。就这样我只用了两天时间就看完了全本。而且还都是用睡前时间看的。也正因为如此，那两天根本就没睡好。</p>
<p>对于很多看过这本书的人来说，都认为这本书主线讲述的是十三岁的少女房思琪被中年教师李国华诱奸的故事。而根据作者林奕含本人的说法，这本书说的应该是：「房思琪爱上诱奸她的补习老师的故事」。这其中的区别就在于这个过程中是否有爱。从林奕含的说法，去看这个故事，则变得更加深刻，也更加悲剧。</p>
<p>儿童性侵是全世界都非常关注的主题。但是能以非常深刻的笔触写出这个的作品少之又少，毕竟对于作家来说，想象力终究是有限的，非亲身经历就不能深刻。通读房书会发现，作者的文字非常贴近房思琪的视角，让人非常直观的感受到她的痛苦。这也是为什么我说，当我看完之后这么久，再次拿起书，看到封皮的时候，依旧感到非常压抑。从这一点上来说，虽然最终不能找到确凿证据，但我愿意相信，林奕含是亲身经历过的。我很难想象，作者是承受着怎样的痛苦，将这些文字落于纸上​。将房思琪的心理活动不失文采地完整写下来​。​仿佛把自己把自己放在火上烤，她不是消费了别人，而是消费了自己。</p>
<p>几乎所有看过这本书的人都认为这本书应该作为当代学生的性教育读本，我也十分同意。不过在我看来，从某种角度说，它更是当代父母与孩子沟通的警示录。房思琪和房妈的对话和经历，让我想起了前年家乡的一个学生跳楼事件，导火索大概就是因为孩子被没收了手机，据说已经非常郁闷了，然后在考试前又被父亲说了几句，最终直接从楼上一跃而下。跟房妈一样，说到底是家长对孩子的心理状态不够敏感。不能够平视孩子，不理解、不关注。</p>
<p>说回房书，对于房思琪最终的精神崩溃，直接原因当然是李国华。但正如书中所写，周围的人全是帮凶。如果刘怡婷能了解到房思琪的痛苦；如果在房思琪第一次试探性的跟房妈交流的时候，房妈能准确感知她的异常；如果许伊纹愿意对房思琪敞开心扉，得到房思琪毫无保留地倾诉，这一切也许不会最终这么糟糕。整个事情的走向，但恰恰相反，正像当初李国华所想的那样，<strong>「一个如此精致的小孩是不会说出去的，因为这太脏了。自尊心往往是一根伤人伤己的针，但是在这里，自尊心会缝起她的嘴。」</strong> 这么多人，没有发现房思琪的挣扎，而房思琪最终也没能战胜自己，才造就了如此悲剧。更为可怕的是，书中的世界不止李国华，还有蔡良，也不止房思琪，还有郭晓奇、饼干。正是社会对这种事情缺乏敏感，才造就了这么多的悲剧。</p>
<p>我曾经想，如果在书中真的有一个人成功的拯救了房思琪，毫无疑问只有许伊纹，因为许伊纹已经感受到了房思琪的异常，但是很遗憾，伊纹自己深陷家暴的泥潭无法自救，最终并没能拯救房思琪。</p>
<p>最后还是要说一下，书中用了大量的比喻，导致我初读此书的时候非常不习惯，所以很久之前第一次读的时候并没有读完便放弃了。而后来我从不习惯到认为文风理应如此，有这么大的转变，也许用书里的一句话便能完美解释了。那是因为：</p>
<p><strong>「我已经知道，联想、象征、隐喻，是世界上最危险的东西。」</strong></p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>荒诞的尽头也许是真实……</title>
    <url>/2020/06/13/absurdity-and-reality/</url>
    <content><![CDATA[<p>上个月读了加缪的《局外人》(金祎的译本)。买书之前调查了一下各种译本以及同一个译者的不同版本，最终还是选了金祎译的这本，除了有翻译上的原因，还有一个理由是，这本书除了有小说内容之外，还在后边附上了：后记、导读、加缪的演讲稿，这些内容着实让我对这部小说有了更深刻的认识。当然对于存在主义，我现在还是知之甚少的……</p>
<span id="more"></span>

<p>《局外人》，传说中的荒诞文学……，有点震撼。那种感觉大概就是觉得很厉害，但是当我想写点什么的时候，却什么都写不出来，再加上工作一直很忙，这篇读书笔记上个月读了加缪的《局外人》(金祎的译本)。买书之前调查了一下各种译本以及同一个译者的不同版本，最终还是选了金祎译的这本，除了有翻译上的原因，还有一个理由是，这本书除了有小说内容之外，还在后边附上了：后记、导读、加缪的演讲稿，这些内容着实让我对这部小说有了更深刻的认识。当然对于存在主义，我现在还是知之甚少的……</p>
<p>《局外人》，传说中的荒诞文学……，有点震撼。那种感觉大概就是觉得很厉害，但是当我想写点什么的时候，却什么都写不出来，再加上工作一直很忙，这篇读书笔记就“难产”了。这段时间里，我仔细琢磨它让我震撼的点究竟是什么，如果非要找到一个理由，那大概就是这篇小说有点短，剧情也一点都不跌宕起伏，但是会给我无穷的拷问。也许我在看其他小说的时候，会花 80% 的时间看剧情，花 20% 的时间去思考，但对于这本《局外人》，我想应该是倒过来的。</p>
<p>我甚至不想对这本书的内容做任何的介绍，因为并没有什么介绍能胜过完整的读一遍。如果非要找到一个故事简介，我想用加缪自己的话说是最合适的，“《局外人》讲述的是一个毫无英雄主义的自命不凡的、只是愿意为真实赴死的男人的故事。”</p>
<p>我在纸面上看到的主人公默尔索，是一个不参与游戏……徘徊在社会边缘……拒绝撒谎的人，但也正因为如此，他最终走向了死亡。而导致他走向死亡的根本原因，“可能”是因为他没有在母亲的葬礼上哭泣。(加缪也曾经这样介绍《局外人》的主题：在我们的社会里，任何不在母亲葬礼上哭泣的人，都有可能被处以死刑)；而透过这层纸，我看到的默尔索是直面自己的、“绝对”而又“真实”的人。</p>
<p>而正是因为他的“绝对”与“真实”，有些人会认为默尔索是一个被社会抛弃的人，也是加缪所说的“局外人”。他抵抗这个社会设定的规则，原因就是因为他拒绝说谎。加缪的说法是，说谎并不一定意味着说假话，而是当你讲述的不仅是真相的时候，就已经是在说谎了。默尔索抵抗的正是这种“广义的”说谎。</p>
<p>实际上我也一直在思考，这个世界是否能存在绝对的客观。而现在看来，默尔索身上具有的真实，跟我所想象的绝对的客观是非常相似的。当我们一直在寻求客观的时候，突然出现了一个默尔索一样的人，或许我们并不会认为他很真实，反而会认为他是异类，加缪用这本书给了我一个很好的诠释。更让我感到肃然起敬的是，他可以把这些东西赤裸裸的落到纸面上去思考。</p>
<p>这本书让我清晰地感受到：荒诞的尽头是真实。但我隐约也有一种感觉，如果人不能巧妙地游走在荒诞与真实之间，而是走向一个极端，在这个社会也必然是难以生存的。这就是芸芸众生之中的那些“局外人”的现状。即使像默尔索，最终也走向了一个妥协。正如书中所说：『为了让一切有个了结，为了使我不感到那么孤独，我还是希望我被处决的那天有很多人来观看，希望他们用仇恨的喊声来欢迎我。』</p>
<p>跳出小说中的内容，通过导读的一些东西，让我对加缪各种崇拜。他并不是那种，误打误撞，靠一部作品一炮走红的作家，而是掌握着自上而下的超强写作能力的作家，他对自己的作品有着清晰的架构，所有的作品内容都在他的掌控之中，看似内容没有关联的几部作品，实则诠释了他对某一内涵的完整解读，而这种解读又并非只是简单的扣住一个主题，而是有着清晰的层次划分的，这是我见过的少有的，不得不说他算是个写作的天才。</p>
<p>最后用默尔索的一句话，也是全书唯一出现过“荒诞”一词的地方，来结束这篇笔记。</p>
<p>『在我所度过的整个荒诞的人生中，从我未来的深处，一股昏暗的气息穿越尚未到来的岁月向我扑来，这股气息一路袭来，使别人向我建议的一切都变得毫无差别，未来的岁月并不比我已经度过的岁月更真实』就“难产”了。这段时间里，我仔细琢磨它让我震撼的点究竟是什么，如果非要找到一个理由，那大概就是这篇小说有点短，剧情也一点都不跌宕起伏，但是会给我无穷的拷问。也许我在看其他小说的时候，会花 80% 的时间看剧情，花 20% 的时间去思考，但对于这本《局外人》，我想应该是倒过来的。</p>
<p>我甚至不想对这本书的内容做任何的介绍，因为并没有什么介绍能胜过完整的读一遍。如果非要找到一个故事简介，我想用加缪自己的话说是最合适的，“《局外人》讲述的是一个毫无英雄主义的自命不凡的、只是愿意为真实赴死的男人的故事。”</p>
<p>我在纸面上看到的主人公默尔索，是一个不参与游戏……徘徊在社会边缘……拒绝撒谎的人，但也正因为如此，他最终走向了死亡。而导致他走向死亡的根本原因，“可能”是因为他没有在母亲的葬礼上哭泣。(加缪也曾经这样介绍《局外人》的主题：在我们的社会里，任何不在母亲葬礼上哭泣的人，都有可能被处以死刑)；而透过这层纸，我看到的默尔索是直面自己的、“绝对”而又“真实”的人。</p>
<p>而正是因为他的“绝对”与“真实”，有些人会认为默尔索是一个被社会抛弃的人，也是加缪所说的“局外人”。他抵抗这个社会设定的规则，原因就是因为他拒绝说谎。加缪的说法是，说谎并不一定意味着说假话，而是当你讲述的不仅是真相的时候，就已经是在说谎了。默尔索抵抗的正是这种“广义的”说谎。</p>
<p>实际上我也一直在思考，这个世界是否能存在绝对的客观。而现在看来，默尔索身上具有的真实，跟我所想象的绝对的客观是非常相似的。当我们一直在寻求客观的时候，突然出现了一个默尔索一样的人，或许我们并不会认为他很真实，反而会认为他是异类，加缪用这本书给了我一个很好的诠释。更让我感到肃然起敬的是，他可以把这些东西赤裸裸的落到纸面上去思考。</p>
<p>这本书让我清晰地感受到：荒诞的尽头是真实。但我隐约也有一种感觉，如果人不能巧妙地游走在荒诞与真实之间，而是走向一个极端，在这个社会也必然是难以生存的。这就是芸芸众生之中的那些“局外人”的现状。即使像默尔索，最终也走向了一个妥协。正如书中所说：『为了让一切有个了结，为了使我不感到那么孤独，我还是希望我被处决的那天有很多人来观看，希望他们用仇恨的喊声来欢迎我。』</p>
<p>跳出小说中的内容，通过导读的一些东西，让我对加缪各种崇拜。他并不是那种，误打误撞，靠一部作品一炮走红的作家，而是掌握着自上而下的超强写作能力的作家，他对自己的作品有着清晰的架构，所有的作品内容都在他的掌控之中，看似内容没有关联的几部作品，实则诠释了他对某一内涵的完整解读，而这种解读又并非只是简单的扣住一个主题，而是有着清晰的层次划分的，这是我见过的少有的，不得不说他算是个写作的天才。</p>
<p>最后用默尔索的一句话，也是全书唯一出现过“荒诞”一词的地方，来结束这篇笔记。</p>
<p>『在我所度过的整个荒诞的人生中，从我未来的深处，一股昏暗的气息穿越尚未到来的岁月向我扑来，这股气息一路袭来，使别人向我建议的一切都变得毫无差别，未来的岁月并不比我已经度过的岁月更真实』</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年度报告</title>
    <url>/2018/12/29/annual-2018/</url>
    <content><![CDATA[<p>正值19和20年交替之际，我做了一个决定，打算每年都做一个年度报告，记录这一年的年度事件与感悟。18年的记忆还在，就顺手补上了，所以这篇文章其实是在19年末写的。但为了保证文章的顺序，还是觉得把他放在18年的归档中，比较妥当，所以将文章的时间改前了一年。</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018年变化之大，说是我人生中的一个重要节点也不为过。我一直觉得2018年这一年的经历可能比我之前七八年的经历还丰富。</p>
<h2 id="离职"><a href="#离职" class="headerlink" title="离职"></a>离职</h2><h3 id="一直在累积的工作负面情绪"><a href="#一直在累积的工作负面情绪" class="headerlink" title="一直在累积的工作负面情绪"></a>一直在累积的工作负面情绪</h3><p>到现在我都还记得离职之前的那段日子，用我当时自己这样评价自己，我已经不适合这个团队了，我的负面情绪太重了，觉得工作没意思，没前途，没冲劲。在 WPS 我没有好的需求可以接，打杂的需求学不到东西，觉得自从不做 WPS看图 (现在叫的 WPS图片 )之后，一直在维护 PDF2WORD 插件，天天跟新西兰老铁对接 SDK 的问题，没有任何技术上的提升，再加上一直不满意的薪资，实际上负面情绪已经非常严重了。而且在 WPS 做了两年多(算上实习就三年多)，一路走来，按说自己技术肯定是有了提升，但是实际上我对自己越来越不自信，对自己的水平产生了严重的怀疑，害怕、恐惧，觉得自己脑子不够灵光。感觉是不是除了 WPS 也没别的地方能去了，又不甘心。这种情绪，随着一直工作下去，一直就在累积，得不到任何释放和消除。</p>
<h3 id="异地恋"><a href="#异地恋" class="headerlink" title="异地恋"></a>异地恋</h3><p>2016年12月2日，一个妹纸走进了我的世界，坦率地说，我从没有想过，她会给我的生活带来巨大的改变，甚至重塑了我的爱情观，但事实就是如此。一直到2017年末整整一年的异地恋，而且这中间又发生了难以言说的事情，耗费了我太多的精力。我又在工作，异地恋的距离之远，让我感到非常无力。所以其实在18年的春节已经开始在谋划换地方工作了。当时就决定是裸辞，顺便休整一下，考个驾照，也多准备一下。</p>
<h3 id="公司搬迁"><a href="#公司搬迁" class="headerlink" title="公司搬迁"></a>公司搬迁</h3><p>2017年10月份，公司正式搬到唐家的金山软件园的新楼，空气中导出充斥着甲醛，但公司也并没有什么好的防护措施，也算是一个小小的不满吧。</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>总之，2018年3月24日我从 WPS 正式离职。没有下家，也没有任何口头 offer，就这样辞职了，收拾了在广州上学和在珠海生活的这几年的东西，能卖的出二手，或者送人，不舍得卖，卖不出去的，打包寄回了家里。</p>
<h2 id="考驾照"><a href="#考驾照" class="headerlink" title="考驾照"></a>考驾照</h2><p>4月份开始学习开车，从报名到拿证，一共43天，感觉也算是很快了</p>
<h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><p>5月份拿到驾照，就做了计划，准备准备简历，复习一下很久没看过的一些面试相关的东西。6月份去北京看看工作机会。在家里投了几个，电话里聊了一下，得到一个二面通知的时候，就正式买了去北京的车票，在北京找工。住在通州的亲戚家里，每天到西二旗来回五个小时车程，两周拿到了三个 offer 。事实上都是前一周的 offer，后一周基本上面试都很少了，而且大厂一个面试邀请都都没有，毕竟不是金三银四，金九银十。没有大厂的 offer，薪水给的很勉强，有一个甚至因为当时没接，后来再去的时候直接当面砍了价格。也正是因为这个，让我感到技术的廉价，让我萌生了考研的想法，而且女朋友也在准备考研，又想跟女朋友呆在一起，我一气之下拒了这仅有的三个 offer，离开北京又回了家。实际上如果那时的我是2019年的我，我应该很容易判断，考研这个决定是否靠谱，但事实是，我没有考虑太多，就做了决定。也或者说，心里可能想着考不上也不亏。不得不说，裸辞让人胆子变得更大，裸辞一时爽，裸辞时间越长就越爽。</p>
<h2 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h2><p>事实是到9月份，就没怎么准备，或者说是没准备，沉迷女色，“沉迷游戏”，之所以沉迷游戏做了引号，是因为在后边看来可能是坏事，也可能有好的收获。9月份开始，常规的看看课程，做笔记，做题，书是买了不少，也有做，中间又经历了分手，痛苦了一段时间。一直到11月份，攻略上说这个时候得开始模拟了，每天也是常规的做做模拟卷(数学)，但实际上按之前的复习状态，可想而知，这个时候确实开始有些发慌了。但还是按着这个节奏在搞，英语一直都是背单词，直到上考场模拟卷一套也没做过，英语考试前一天晚上我都还不知道题型都有啥……也是没谁了……计算机专业课把王道和天勤的选择撸了，发现工作两年多，还好，选择什么的还不虚。政治跟着肖秀荣所有选择撸了两遍。考试之前背了肖四，和一些所谓的秘密资料。最后英语61 政治56 专业课119 数学……还是不说了…… 如果跟专业课一样分，估计我已经上学了。</p>
<h2 id="分手"><a href="#分手" class="headerlink" title="分手"></a>分手</h2><p>“求不得”可能才是生活的常态，只是我还不习惯。明明觉得遇上了一个有趣的人，也憧憬了很多，但也有很多的矛盾。就这样还是分开了，有爱没恨、只是遗憾。这段感情人对了，时间不合适了，很多事情都变的拧巴了，也没法重来了。</p>
<h2 id="意外收获"><a href="#意外收获" class="headerlink" title="意外收获"></a>意外收获</h2><p>离职的时候，我一度认为我不聪明，脑子不灵活。玩游戏都没有别人玩的好，一无是处，找不到自己的优点，也没有自信。这一年我沉迷游戏，说来也可笑，其实倒也不是沉迷游戏本身，我只是想知道我到底是不是什么都做不好。</p>
<h3 id="提升认知与自信"><a href="#提升认知与自信" class="headerlink" title="提升认知与自信"></a>提升认知与自信</h3><p>不管听起来是不是很可笑，亦或者像是打广告，但我确实是通过玩QQ飞车手游，提升了自己对未知的东西的认知能力。玩了大半年，排位上了星耀三，再回顾，发现对游戏的理解跟从前完全不一样。再加上在复习政治的过程中，真正的研究了一下马克思主义哲学。这种感觉仿佛一下子通透了。</p>
<p>我对认知过程的理解和感悟可以用两个概念概括：</p>
<blockquote>
<p>否定之否定(哲学的基本规律之一)。它揭示了事物发展的前进性与曲折性的统一，表明了事物的发展不是直线式前进而是螺旋式上升的。</p>
</blockquote>
<blockquote>
<p>《人间词话》：“古今之成大事业、大学问者，必经过三种之境界：‘昨夜西风凋碧树。独上高楼，望尽天涯路’。此第一境也。‘衣带渐宽终不悔，为伊消得人憔悴。’此第二境也。‘众里寻他千百度，蓦然回首，那人却在，灯火阑珊处’。此第三境也。”</p>
</blockquote>
<p>终于我也找到了自己的认知体系，算是一个意外收获，让我知道，我在各个方面的现有的认知水平，究竟是怎样的。而且游戏本身也让我觉得，只要花时间琢磨，我还是可以做的更好的，在一定程度上还是有一些自信的回升。</p>
<h3 id="对裸辞的认识"><a href="#对裸辞的认识" class="headerlink" title="对裸辞的认识"></a>对裸辞的认识</h3><p>毕业之后一直在金山工作，没有去过别的公司，也没有面过别的公司，实际上在之前的时间里，裸辞是一个根本不敢想的东西。很难想象一年不工作，我觉得这在职场是致命的，在知乎看到了那么多人，那么多帖子，告诉你不要裸辞，但事实上，都是小马过河的故事。到底你能不能裸辞，只有你自己知道，至少对于我来说，无所畏惧了，因为我尝试过，也没有觉得多恐怖。我也敢于去追自己想要的东西，这比大部分人来说迈出了一大步，也算是一个意外收获。</p>
<h3 id="重新为自己的技术估值"><a href="#重新为自己的技术估值" class="headerlink" title="重新为自己的技术估值"></a>重新为自己的技术估值</h3><p>在北京找工作，都觉得不太满意，虽然最后回家了，但实际上这段经历也是非常有用的，这对我估量市场行情有很大帮助。</p>
<h3 id="价值观的重塑"><a href="#价值观的重塑" class="headerlink" title="价值观的重塑"></a>价值观的重塑</h3><p>事实上经历了2018年这几件事之后，我整个人是非常丧的。一度觉得自己走向自闭了。看到正在工作的小伙伴，赚的盆满钵满，实话实说，我是酸的。但可能有时候就是不破不立，走了极端不一定是坏事。后来我也终于想透了。只要人一进入职场，就浮躁了起来，整个人飘在天上，眼睛看着钱，看着周围的人赚多少钱，自己赚的多还是少。但一燥起来，就忘了本质，燥到只渴望钱，而不知道为什么渴望钱。</p>
<p>失去了目的和本质之后，就转为单纯的贪婪，这就变得可怕，原因有二：</p>
<ul>
<li>一是贪婪无止境，会让人变得盲目、无底线；</li>
<li>二是当聚焦到钱上之后，做事变得不再纯粹，不够专注，就会做的不够好。</li>
</ul>
<p>当我明白了这两点之后，很多东西就放下了，慢下来了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾2018的关键词：离职、找工作失利、考研失利、分手。仿佛没有一个是让人觉得向好的，但是在19年开年的时候我写下了一段话，确是非常阳光的，我想可能就是因为这些意外收获，我觉得很有价值。所以2018年是试错的一年，我觉得值得。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="年度书籍"><a href="#年度书籍" class="headerlink" title="年度书籍"></a>年度书籍</h3><ul>
<li>《天勤计算机考研2019数据结构高分笔记 》</li>
<li>《天勤数据结构高分笔记之习题精析扩展》</li>
<li><a href="https://book.douban.com/subject/30258763/">《肖秀荣2019考研政治命题人1000题（上册试题、下册解析）》</a></li>
<li><a href="https://book.douban.com/subject/30269999/">《肖秀荣2019考研政治命题人知识点精讲精练》</a></li>
<li><a href="https://book.douban.com/subject/30326003/">《肖秀荣2019考研政治命题人讲真题（上、下册）》</a> - 10%</li>
<li><a href="https://book.douban.com/subject/30391616/">《肖秀荣2019考研政治命题人冲刺8套卷》</a></li>
<li><a href="https://book.douban.com/subject/30396091/">《肖秀荣2019考研政治命题人终极预测4套卷》</a></li>
<li>《王道考研2019计算机考研(数据结构、操作系统、计组、计网)》</li>
<li>《高数叔总复习笔记(高数、线代、概率论)》</li>
<li>《2019张宇考研数学真题大全解(数一)》</li>
<li>《2019石磊考研政治保命32分》</li>
<li>《2019李正元范培华考研数学历年试题解析数学一》</li>
<li><a href="https://book.douban.com/subject/30765054/">《2019恋练有词》</a></li>
<li><a href="https://book.douban.com/subject/26677354/">《数学女孩》</a></li>
<li><a href="https://book.douban.com/subject/11610490/">《数学与人类文明》</a></li>
<li><a href="https://book.douban.com/subject/20494401/">《费马大定理-一个困惑了世间智者358年的谜》</a></li>
</ul>
<h3 id="年度人物"><a href="#年度人物" class="headerlink" title="年度人物"></a>年度人物</h3><ul>
<li>峰哥(离职找我谈话，跟我说的一番话，我一直铭记，受益匪浅)</li>
<li>前女友(重塑了我的爱情观)</li>
</ul>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>年度总结</tag>
        <tag>人生经验</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年度报告</title>
    <url>/2019/12/30/annual-2019/</url>
    <content><![CDATA[<p>今年的年末突然有个想法，每年的年末要出一个年度报告，记录这一年来的大事记，年度书籍，年度人物。这样便于及时看清自己的状况，做到心里有数，不迷茫。以后回忆起来，也有地方翻看一下。</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>总体看来，2019是向好的，至少在我看来要比2018年好了一些，不那么惨淡。新的开始，新的工作，新的同事。增加了很多新的见识。</p>
<h2 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h2><p>2018年的种种失利，让我在年末的时候，非常低落。还没有考试之前，便计划好了，考完试要自己走一下，不做具体行程计划，完全随心，前一天晚上考虑第二天去哪。所以只是提前定了住的地点和车票。打算坐火车，边走边玩，最后回家。我当时给我这次旅行定为涅槃之旅，希望能借着旅行可以散散心。</p>
<h3 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h3><p>考研结束后，在珠海小做休整，2018年12月25日从珠海出发，这一走就是21天，珠海、广州、长沙、武汉、西安、郑州、洛阳、大连，最后回家。</p>
<ul>
<li>珠海：跟同事吃了饭，互相交流了一下，离开职场一年，问问他们有什么见闻。自己去曾经总去的地方散散步，找找回忆。</li>
<li>广州：跟同学聚了一下，问问他们的近况。</li>
<li>长沙：在长沙逗留了三天，去吃臭豆腐、大香肠，去橘子洲，去岳麓山，岳麓书院、湖南广电总局。去岳麓书院的时候大摇大摆进去，竟然没有人跟我要门票，我还以为不用门票，出来之后我才知道，这里是要门票的，而且很幸运的在岳麓山上遇到我来南方之后的第一场雪。</li>
<li>武汉：跟之前珠海调去武汉的同事聚了一下，聊聊近况。跟家里的亲戚之前约好了元旦在武汉的小姨家聚会，聚了一下，聊聊天，聊聊各自的状况。</li>
<li>西安：在西安的行程就不做赘述了，有自撰蚂蜂窝<a href="http://m.mafengwo.cn/i/11625062.html">游记</a>一篇。</li>
<li>郑州：只停留了几个小时便转车去了洛阳</li>
<li>洛阳：在洛阳，去了丽景门喝《舌尖》中说到的不翻汤，去古墓博物馆近距离看古代的墓穴，去了龙门石窟、白马寺。有幸看到了雪中的龙门石窟。还去了洛阳博物馆。</li>
<li>大连：跟高中同学吃了个饭，聊聊近况。</li>
</ul>
<h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>这段旅程对我来说有很重要的意义，或者说比我之前预想的要更有价值。原本只是为了散心，但这次行程我看到了很多人，感受到了很多的事，很多执着的东西，让我能放下了，也在一定程度上突破了自己。</p>
<p>意外收获的话，就是发现淡季出去旅游，消费减半，体验翻倍。终于不用再看人，而是专注内容与感悟。</p>
<p>在长沙，尝了我之前从来没有吃过的臭豆腐，总是觉得来长沙一次，不吃就可惜了，突破了一下自我；</p>
<p>在西安，陕西省博物馆讲解员、秦陵讲解员、南城东巷乐队以及观看他们演出的一个中年男人、在大冰的小屋唱歌的歌手，还有南门地下通道的演唱小哥，给了我太深刻的印象，我没有跟他们说一句话，但我切切实实是被他们感染了。在他们的身上，我看不到一丝的铜臭，我只看到<strong>热爱、专注，对自己从事行业的执著</strong>。两个讲解员都是学历史出身，但没有去做考古研究，而是选择做讲解员，收入不高，但热情不减，从他们的介绍当中，我能看出那种对这份工作的热爱，而不是对钱的热爱；去大冰的小屋喝酒，歌手唱歌之前还不忘跟我们说，推了今天的麻将局，来这里唱歌；南门下的南城东巷乐队，1月份的西安，午夜12点，那份寒冷让观众都有些受不了，他们还在唱着，手僵了就找杯热水暖手，热烈的气氛，让人突然觉得不像是冬天。吉他包里没有多少钞票，但是并不影响歌手的热情，一直唱到凌晨一点，而我一直看着他们唱完，还有一个中年男人，一直看到他们唱完，并放了三百元在吉他包里。他与周围的年轻人，形成了鲜明的对比，我不知道他有什么故事，但我觉得他在这里得到了他从来没有得到的快乐。我还看到了南门地下通道的唱歌小哥，一个观众都没有，但唱的还是非常有激情。</p>
<p>在他们身上，我突然觉得，<strong>有一件自己喜欢做的事情是非常幸福的，那种无关钱财的豁然，让这份幸福成倍的放大</strong>。在他们对比下，我觉得对金钱的追求让我变得渺小，我甚至找不到一个，我能笃定的为之奋斗的事业，这不得不让我感到惭愧。同时在他们的身上，我看到了那种积极，即使学历史不去考古，搞乐队不上舞台，但不妨碍他们把自己的快乐分享给别人，在任何层次上都可以做到极致，这对我一直以来的观念是极大的冲突，以前的我总会觉得自己的能力不行，但就觉得很失望，很沮丧，失去了动力。西安之行让我改变了很多，或许很多事情只有这些离我最近的人，或许才会更容易打动我。</p>
<p>临近年末的时候，在微信群的一段对话让我印象深刻：</p>
<blockquote>
<p>马老师：你们工作上出问题，会内疚吗？</p>
<p>我：为什么会内疚？</p>
<p>马老师：就是觉得没帮到别人，很难受。</p>
<p>我：你尽力没吧？</p>
<p>马老师：嗯</p>
<p>我：那就没有内疚。医生救不活人，也不能去死吧。你不可能因为有一个主播没支持好，就不支持了。然后导致更多的主播都受不到支持。<br><strong>这个世界有很多层级，在每一个层级上都有机会做好，不一定都得在顶层做。</strong><br>就像老师也有顶级名师、也有去山区支教的老师，他们对教育事业的贡献都很大</p>
<p>王总：心理辅导</p>
<p>我：真实感受</p>
<p>我：我原来也是我觉得做不好，就不做了。但实际上如果都是这样，那这个世界就不连续了，只有优秀，而没有良好、及格、很差，但是人不可能一出生就优秀，这就矛盾了。</p>
</blockquote>
<p>我想我能说出这番话，也是他们带给我的感悟吧</p>
<p>在西安的网红书店，我发了一条朋友圈：</p>
<blockquote>
<p>很多时候是要感谢那些在你生命中来了又走的人，不管一起经历过什么，是好是坏，你总能吸收一些他们的特质；他们又是镜子，从中你看到了自己的缺点，他们不断地来了又走，你看起来还是你自己，但事实上你却并不是你了。令人欣慰的是，这种变化大抵是向好的，所以……2019，我相信人间值得。</p>
</blockquote>
<p>现在看来，我说的没错，至少在我自己看来确实值得。</p>
<h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><p>考研的成绩下来之后，毫无疑问，就应该准备找工作了。在家稍做准备之后，我还是决定直接拎着箱子跑到广州去，找一个地方住下来，慢慢找。这在以前我是想都不敢想的，在这座城市没有落脚的地方，一个人跑来，可能是二十多年，我从来不曾有过的。我不擅长没有准备的东西，而这一次，找工作确实是不在我的把握之中。但我还是来了。到了广州之后，住在东圃的一个酒店，当时天下着雨，我花了一天时间搞定了公寓，月付，对我来说还好。2019年3月8日，在科韵路的公寓安顿下来之后，一边刷题，一边投简历。</p>
<p>可能人要是太低谷了，老天都会帮一把吧，3月12日，拿到了第一个offer，晓教育，这一天我印象很深刻，天下着雨。我回到科韵路的时候已经是晚上了，从天桥走下来的时候，恰好一个外卖小哥从我身边走过，吃力的拉着车子，我当时也没多想，自然的在后边拉了他车子一把，分担一些力，下来之后他向我道谢。那一刻，才觉得生活不易。但可能是18年的种种经历导致，没有offer的我，虽然前路迷茫，却好像无所畏惧。3月14日，拿到了虎牙的offer，兴奋的一夜没睡着觉。拿到了虎牙的口头offer之后，就没有动力再面其他的了，去面了中望龙腾，但不是很想去。约了CVTE的面试，因为着急体检，也没有去。现在回想起来，当时如果后边没了offer，就很被动了，还是很可怕的。3月20日等来了正式offer，3月25日正式入职虎牙。这时我才发现，距离我从 WPS 离职，2018年3月24日，正好一年。</p>
<h2 id="在虎牙"><a href="#在虎牙" class="headerlink" title="在虎牙"></a>在虎牙</h2><p>从 WPS 离职之后，我一直觉得下一份工作要找一个真正的互联网公司，体验一下。在虎牙，如愿以偿。看到了一个有活力的公司，看到了很多不一样的同事，这种体验是跟 WPS 完全不同的。我并不能草率的去评价哪一种更好，我只想说，他们有很大区别。我的 leader 是一个充满了想法的人，也是一个特别敢做的人，这是一种我之前从来没遇到过的人，也是我从来不曾想过，职场上还会存在这样的人。而组里今年入职的王总，在程序上的广度，让我感叹，也是他让我意识到，我要对自己的很多东西形成方法论，而不仅仅只是做好，做到极致。还有怀揣理想的技术支持马老师，是如何在不了解这么多设备的内部构造，而又能对各种设备了如指掌，在我看来是个奇迹。</p>
<p>WPS 工作经历，让我成长为一个职场工具人，我的思维和我的做事风格，都是工具人的风格。但是在这里，我看到了纯粹，有时候我为自己的不纯粹感到惭愧。感受到了作为与不作为对事情的影响，真正理解了主动的意义，仿佛又从工具人变成了一个活人，去感受责任对于每个人的意义。</p>
<p>技术栈的转变让我拓宽了视野，王总对工具的使用，让我知道原来利其器对善其事是如此重要，跳出自己的舒适圈，逼迫自己使用更多的工具，事实证明，效果是极好的。我也开始去摸索任务管理的自己的一套方法论……正在进行，还没有完备。</p>
<h2 id="小玩意"><a href="#小玩意" class="headerlink" title="小玩意"></a>小玩意</h2><p>2019年实现了两个小玩意：</p>
<ul>
<li><a href="https://github.com/ehnap/gal">Gal</a>：一个快速启动器，支持插件，还做了几个我工作常用到的插件(18年末做，到7月份实现了插件支持，后边就没动过了，现在我一直在用)</li>
<li><a href="ms-windows-store://pdp/?productid=9NR52CX0QJX7">泼辣有图(非官方版)</a>：为了研究 UWP，做了一个 UWP 小应用。(19年末做了1周，上架了第一版)</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2019年是收获的一年，也是我的价值观重新洗牌的一年。得到了很多东西。不过还有很多东西在做，但没有收好尾。工作之后，看的书少了，写博客的习惯还是没有建立起来。但好在一切都是向好的。虽然我特别喜欢跟别人说燥起来，但事实上，我需要时刻提醒自己，别燥了，别迷了，多一些专注……</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="年度书籍："><a href="#年度书籍：" class="headerlink" title="年度书籍："></a>年度书籍：</h3><ul>
<li><a href="https://book.douban.com/subject/3284547/">《文心》</a> - 75%</li>
<li><a href="https://book.douban.com/subject/1050339/">《文化苦旅》</a> - 20%</li>
<li><a href="https://book.douban.com/subject/26285184/">《朝花夕拾-鲁迅散文精选集》</a> - 100%</li>
<li><a href="https://book.douban.com/subject/30178432/">《FFmpeg 从入门到精通》</a> - 100%</li>
<li><a href="https://book.douban.com/subject/27105011/">《编写高性能的 .NET 代码》</a> - 10%</li>
<li><a href="https://book.douban.com/subject/26285940/">《CLR via C#(第四版)》</a> - 30%</li>
</ul>
<h3 id="年度人物："><a href="#年度人物：" class="headerlink" title="年度人物："></a>年度人物：</h3><ul>
<li>陕西省博物馆讲解员、秦陵讲解员、南城东巷乐队以及观看他们演出的一个中年男人、在大冰的小屋唱歌的歌手，还有南门地下通道的演唱小哥</li>
<li>科韵路外卖小哥</li>
<li>基哥、王总、马老师</li>
</ul>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>年度总结</tag>
        <tag>人生经验</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年度报告</title>
    <url>/2020/12/31/annual-2020/</url>
    <content><![CDATA[<p>2020 对世界来说是不平凡的一年，新冠疫情，让每个人的生活都有了一个不小的变化，居家隔离、远程办公、自己竟然做了半个月的饭，之前从来没想过的事情，竟然成了现实。不过回头看来，也正是因为这个，让我感受到了那些平时触手可及的小事情，能给人们带来多大的幸福感。毕竟只有当一个东西没有了的时候，才能体会出它的珍贵。</p>
<span id="more"></span>

<p>回看这一年，对于我来说体会最深的还是成长，从 19 年自己对方法论有了一个很模糊的概念，到 20 年深入探索属于自己的成长模式。我觉得这两年的成长是飞跃性的，那种感觉是上学时所没有的。或者说从某种程度上讲，还是挺后悔的，如果上学的时候能有这样的认识，或许现在的我又不一样了。</p>
<h2 id="虎牙"><a href="#虎牙" class="headerlink" title="虎牙"></a>虎牙</h2><p>王总因为家庭原因离职了，很突然，本来还想跟他继续探讨工具上的哲学，现在只能是自己摸索了。所以云游戏落到了我的头上。对云游戏进行了重构，站在整个项目的角度上看问题，让我发现原来以前我的很多思维还非常局限，看到了自己很多的不足；也让我对重构有了更深刻的认识。而且因为要梳理重构方案，把 WPF 比较核心的代码读了个透，对 WPF 有了一个新的认识。</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>20 年初立了一个 FLAG，要每个月至少读一本书，庆幸自己做到了。也因此而收获了很多，长了很多见识。渐渐地发现，自己忽略了一个最重要的获取知识的渠道。就像我在公众号的文章<a href="https://mp.weixin.qq.com/s/1tB19FB6to0h0HUFCLpgdg">《音视频大行其道的今天，关于读书还能说点什么？》</a>中说到的，优质的书会节省自己大量的时间，会少走很多弯路。</p>
<p>20 年完整读完的书一共 12 本，输出笔记 5 篇。在读 2 本。建立了待读书单，目前内有 32 本，明年也会在其中挑一部分来读。建立了自己的书籍数据库，目前库存 45 本，并对阅读状态加以标注，对已读书籍会进行打分，有读书笔记的也要关联起来，便于后期分析各个出版社或品牌的书籍质量，这个是很有意思的一件事情。</p>
<p>另外我也在选书、读书等方面进行摸索，看了很多关于读书的纪录片和文章，了解了很多跟书籍相关的东西，算是半只脚踏进读书的圈子，让我对读书有了更进一步的认识，感觉自己上了这么多年学，但这又是我从未接触过的一片盲区。21 年还是要在读书方面继续深入。</p>
<h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><p>10.29 我从虎牙离职， 11.9 入职腾讯，从广州搬到深圳。这次换工作主要也就几个原因:</p>
<ol>
<li>证明自己，需要一个职级的认可，虎牙给不到，就想看看其他地方了</li>
<li>云游戏的前景不明朗，产品打法非常模糊，让我觉得不是在做一款好产品</li>
<li>想看看大厂的做事风格是怎样的(可能这就是离职时候总监跟我说的大厂情结吧)</li>
</ol>
<p>在腾讯我看到了很多工作极为主动的人，他们有着无限的激情，对工作投入百分之一百二的热情(当然这是好还是坏没法评说)。也从来不担心同事的水平不行，都很优秀。</p>
<h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><h3 id="主动性"><a href="#主动性" class="headerlink" title="主动性"></a>主动性</h3><p>在虎牙，基哥跟龙海那种把产品当作自己的孩子一样的热忱，这是我之前所不具备的品质，也让我对主动性有了一个全新的认识。在过去，我一直把自己当作是一个工具人来定位，在职场就要有工具人的样子，把自己的事情做好，不多管闲事，这是最好的。是基哥让我知道了，做到极致的前提是主动。所以这一年我开始有了转变。</p>
<p>而正是因为主动性的提升，让我看到了新的东西，我开始有自己的想法，开始思考自己想要什么、不想要什么，也侧面辅助了我方法论的沉淀，我开始主动去了解优质的成长模式，去看其他人的工具哲学。卸载了抖音，关掉了朋友圈；回到了用 RSS 获取信息的方式，变被动获取为主动，只看优质信息；同时用 Notion 来整理已有信息。这些又让我提升了不少效率。</p>
<h3 id="包容心、同理心、慈悲心"><a href="#包容心、同理心、慈悲心" class="headerlink" title="包容心、同理心、慈悲心"></a>包容心、同理心、慈悲心</h3><p>这一年见到了太多的事，自己的职场角色也在频繁的变化，我对很多事情变得更理解了。虽然理解不代表接受，但是这样的转变，还是会让我从中收益。可能之前的我，还总是强调为什么，为什么我要包容别人，我要理解别人，现在却不强调了，我说不上原因，真的说不上……</p>
<h3 id="工作的意义"><a href="#工作的意义" class="headerlink" title="工作的意义"></a>工作的意义</h3><p>今年读了一些书，再加上换工作，让我对工作的意义有了新的思考。我常想，如何选择公司。我之前和很多人一样，会觉得哪里钱多就去哪里，肯定没错。就像酸酸说的那样：『不要相信公司没有钱但是会让你成长，能给的起钱的公司更能让你成长。』但我发现，如果以钱作为筛选目标，会让人没有底线，没有止境。跳槽就会涨钱，那是不是要不停的跳呢，如果又是怕下家觉得不稳定，又不敢跳，这又陷入了一种被动选择的模式上。所以我开始考虑新的选择目标，而选择去腾讯，是因为项目本身算是挺有意义吧，再加上比较大的团队规模，是我想要去观察的目标，所以我没有选择百废待兴、成长空间更大的字节。</p>
<p>20 年最深的一个体会就是，程序员这个职业，没什么信仰，太痛苦了。如果干来干去发现是为钱而干，就太难受了。不像医生、老师、警察等等那么充实。</p>
<h2 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h2><p>身体是革命的本钱，当体检报告下来的时候我才觉得这是真理啊。当体会到了自己的成长、也找到人生目标的时候，发现自己力不从心，那才是让人觉得难受的事情。是时候反思自己了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>20 年是成长的一年，我得到了很多。但自己对很多事情看的太重，让自己很累。21 年的首要目标还是健康，所以要把很多事放下，要看轻，或者说要举重若轻。成长的增速维持住，多读书，就好。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="年度书籍"><a href="#年度书籍" class="headerlink" title="年度书籍"></a>年度书籍</h3><p>(读过的评分在4星以上的)</p>
<ul>
<li><a href="https://book.douban.com/subject/30238819/">《谈美》</a></li>
<li><a href="https://book.douban.com/subject/4913064/">《活着》</a></li>
<li><a href="https://book.douban.com/subject/27024398/">《阅读是一座随身携带的避难所》</a></li>
<li><a href="https://book.douban.com/subject/30468519/">《局外人》</a></li>
<li><a href="https://book.douban.com/subject/27614904/">《房思琪的初恋乐园》</a></li>
<li><a href="https://book.douban.com/subject/30208077/">《禅与摩托车维修艺术》</a></li>
</ul>
<h3 id="年度关键词"><a href="#年度关键词" class="headerlink" title="年度关键词"></a>年度关键词</h3><p>成长</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>年度总结</tag>
        <tag>人生经验</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年度报告</title>
    <url>/2022/01/01/annual-2021/</url>
    <content><![CDATA[<p>2021年是一个平淡无奇的一年，就算是年末突然又卷土重来的疫情，也不能给这一年带来什么大的波澜。工作越久，越忙，就会越发的失去对生活的思考，也会让生活趋于平淡。认知上没有什么质的提升。职场让人变得麻木，让人变成只是完成任务的一个机器，也让生活变得枯燥乏味。这最终导致回忆起这一年，我竟然想不起几件能值得记录的大事件。</p>
<span id="more"></span>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>也许这应该是今年最值得记录的一件事情，也可能是我整个人生当中比较值得记录的事情之一。我买房了。终于在所谓的大城市能有一个称得上家的地方。在这之前，我居住的地方都把它们叫做“我住的地方”，我朋友说这么说不费劲吗，我说但是那不叫家，找不到别的形容方式了。所以也许我现在可以说在这里我有家了。</p>
<p>年初开始不断地跑，不断地看房，不断地研究怎么买，做功课，看政策，砍价，跟各种各样的业主和中介打交道，做心里建设，做取舍。积累了丰富的看房买房经验（写到这里，感觉又可以出一篇购房总结了）。</p>
<p>就像我的朋友说的，『所有的东西，最终都是心理建设』，只有买了之后，才知道这话所言非虚。</p>
<p>拥有了自己的房子，突然觉得人生开启了下一个阶段，或者说原本被消磨殆尽的生活热情，又因为有了房子好像重新被点燃，就立刻得上了仓鼠症，总要买些这个，买些那个。又有了很多憧憬和希望。</p>
<p>今年的个人KPI，还是没能完成，我也没能想到，一直对相亲持非常怀疑态度的我，终于安慰自己说要通过相亲多认识一些人，所以跑去相亲。但是我觉得我或许在年末的时候已经遇到了那个对的人，22年我应该可以完成了，而且很快就会完成了，手动狗头。</p>
<h2 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h2><p>还记得去年立下flag，说要关注身体健康，但是没想到今年就去医院看心电图了。上半年的工作压力很大，四月份的时候，失眠严重，每次一要睡着，就梦到公司的电话打过来，就被吓醒，印象中整个四月份有两天是完全没有睡觉的。然后总觉得自己心脏跳的厉害，买了手环看心率是不是正常，甚至研究冥想，看关于睡眠的书籍。再后来就去医院检查了，做了运动平板检查，不过说是没事，健康的很，这也倒是可以放宽心了，不知道是不是刚好工作压力也没那么大了，后边睡眠就好了很多。</p>
<p>公司体检发现轻度脂肪肝没有了，不知道是医生没检查出来，还是真的已经消失，这勉强算是一个比较正向的事情。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>关于工作，技术上今年一个比较重要的事情就是在对 Flutter 一无所知，而且 Flutter Desktop 还是 beta 的情况下，绕过了一些坑，从零支棱起来腾讯会议RoomsController(Windows版)，也算是对 Flutter 和 Dart 语言有了一些初步的认识。但是我自己的 Phaedrus 却无限期的 delay 了，对 .NET 6 的探索也停滞不前了。</p>
<p>而其他的能给我留下的印象，可能就是加班、赶进度、deadline，以及并不满意的绩效，卷来卷去也就是个3星，毕竟不是嫡系。</p>
<p>对于自身还是有得到一些东西的，所以来会议至少也算求仁得仁了。当初来会议也是为了看看优秀的产品是怎么做的，虽然跟我想象的差别还是很大，但还是有一些借鉴意义的。</p>
<h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>除了有了自己的家之外，今年能让我感到振奋的，就是雨崩之行了，从来没有见过这么美的地方，随便按下快门，都能得到很棒的照片。算是对藏文化有了一个初步的了解，让我觉得西藏是一个一定要去看看的地方。当然也经历了高原反应、爬山体力不支这些身体的不适，但总归是非常值得的。还写了攻略<a href="https://ehnap.me/2021/11/07/yubeng-hiking/#more">《雨崩徒步保姆级攻略——写给去雨崩旅游顺便徒步的小白》</a>。雨崩应该得算是我这辈子一定不会只去一次的地方，期待下一次的雨崩之行。</p>
<h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><p>今年接触到了冥想，让我感觉好像找到认清自己的另一个方法，算是一个不错的收获。另外也在自我提升方面看了一些书籍，也开始正视自己完美主义的问题，并积极寻求解决办法，虽然可能还没怎么见到成效。</p>
<p>另外一部分，就很难写清楚，我隐约觉得相比之前是会有一些不一样，但是又并不能说得清楚这种变化。如果硬是要给一个概括，可能就是慈悲心比以前更强了，它是一种广义的东西，可以说是对别人的包容和理解；也可以说是对自己没那么苛求，能够放下更多的执念等等，总之这种心态给了我更加开阔的一种思维和视野。</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>今年读书保一争二的 KPI，没有完成，全年只读完了十本书，另外有两本现在还在阅读中……。公众号今年也只更新了四篇，拉垮得很，安慰自己的话，就算是打破自己的完美主义了，争取下一年找补回来。如果硬要找理由，就是房子的事分了神，有些懈怠。当然本质原因是懒。不过翻了一下今年看的书，竟然最差的也还是给了三星，没有读到烂书，算是一个小庆幸了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="年度书籍"><a href="#年度书籍" class="headerlink" title="年度书籍"></a>年度书籍</h3><p>(读过的评分在4星以上的)</p>
<ul>
<li><a href="https://book.douban.com/subject/3284547/">《文心》</a></li>
<li><a href="https://book.douban.com/subject/26710670/">《呐喊》</a></li>
<li><a href="https://book.douban.com/subject/26653673/">《必然》</a></li>
<li><a href="https://book.douban.com/subject/1033778/">《穷爸爸富爸爸》</a></li>
<li><a href="https://book.douban.com/subject/35006237/">《大山里的小诗人》</a></li>
<li><a href="https://book.douban.com/subject/34888157/">《十分钟冥想》</a></li>
<li><a href="https://book.douban.com/subject/30294357/">《倾城之恋》</a></li>
<li><a href="https://book.douban.com/subject/25796120/">《小径分岔的花园》</a></li>
<li><a href="https://book.douban.com/subject/35390276/">《如何成为不完美主义者》</a></li>
</ul>
<h3 id="年度关键词"><a href="#年度关键词" class="headerlink" title="年度关键词"></a>年度关键词</h3><p>成长</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>年度总结</tag>
        <tag>人生经验</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年度报告</title>
    <url>/2022/12/31/annual-2022/</url>
    <content><![CDATA[<p>2022 年如果要是找一个词来形容，我觉得应该是“魔幻”。这个国家或者这个世界，都是魔幻的。我能感受到一种明显的动荡感，这种感觉是我从出生到现在的 30 年里从未有过的。当然对于我自己来说，也算是不平淡的一年。换了新的工作，也对一些事情有了新的看法。</p>
<span id="more"></span>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>9月份的时候离开了会议，也离开了深圳，又回到了广州，这也许是今年值得记录的一件事情。</p>
<h3 id="为什么离开"><a href="#为什么离开" class="headerlink" title="为什么离开"></a>为什么离开</h3><p>就像去年说的一样，加班、赶进度、deadline 依旧是我在会议的主旋律，我也越来越不认可会议的方法论和价值观。</p>
<p>会议的问题：</p>
<ol>
<li>看不到人的主观能动性，所有的方法论都建立在人性本“惰”的基础上，氛围让人窒息</li>
<li>上层不会化解压力，只会向下传递并加倍，导致一线开发测试产品无形中存在了对抗没有合力(每个人都不做卡点，但是如果工作量已经超出了合理的范畴，那必然就会导致甩锅的现象出现，本质是生产力不足导致的矛盾，但是被转化成了产研矛盾)</li>
<li>开发话语权小，技术糟糕，但因为没有话语权，技术改进得不到支持</li>
</ol>
<p>从我自己的感受来看，在会议技术人员得不到应该得到的尊重。在这里，每个人都会化作一个人力，把所有的时间排的满满登登，然后还不断地被插入、打断、置换，很难聚焦起来做事情。在这种情况下，人就只有两种选择，一种是让自己聚焦，但是就要变得流氓，用一些流氓的方式抵御这些打断；还有一种情况就是照单全收，但是就很难专注下来。我自认为我属于后者，但是没法专注就意味着我对自己产出的东西不能保证质量，让我很痛苦。尤其是做小程序控制器的时候，中间有几次都想直接撂挑子，我想把东西做好，但是得到的就是质疑，没有理解。离开的时候，我跟 leader 说，我不想让自己变的戾气很重，但是在这里如果不这样，压力就会很大。</p>
<h3 id="怎样离开"><a href="#怎样离开" class="headerlink" title="怎样离开"></a>怎样离开</h3><p>其实 21 年底就已经有些打算想要回广州，再加对这里的种种不满意，所以从年初开始实际上就一直在看机会。但是赶上这个魔幻的时候，在各个厂都有大批量被毕业同学都在找工作的时候，对打工人来说，议价能力就会弱很多，上半年有四家都是在 HR 面报价之后，不推进或者明确表示给不了这么多。但是跳槽这种想法只要有了，就像一个火种，在心里燃烧起来，很难扑灭了。就在我已经对今年跳槽不抱什么希望的时候，有朋友介绍了个机会，就是我现在的公司，某央企，有个新项目需要一个有经验的人来做架构相关的。</p>
<h3 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h3><p>来到这边牵头做客户端，一切都从零开始，工作了三个月，感觉良好，我觉得自己的价值也能得到体现，我有很多对于客户端的理解也可以有地方应用，做的东西也充满了挑战。更重要的是，工作的节奏会更加合理一点，在没有压力的情况下，自己也能更有创造力一些，同时会觉得团队更有温度一些。目前觉得这个选择还是很满意的。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>工作的变化，让我的生活也产生了比较大的变化。今年增添了不少新嗜好。有时候跟朋友说回广州之后，我就变的“调素琴，阅金经。无丝竹之乱耳，无案牍之劳形”了。另外，去年的这个时候我以为或许在我的生命中要永远多了一个人，但是没想到这个人也是我人生路上的一个过客……我又开始独自旅行了。</p>
<h3 id="做饭"><a href="#做饭" class="headerlink" title="做饭"></a>做饭</h3><p>回广州之后，开始自己做饭，做了快两个月，慢慢的喜欢上了做饭，换了一口新的生铁锅，爱不释手。做饭之后慢慢有一种感觉，食开始“知味”了。相比现在，之前确实算是食不知味。只有自己做饭，才知道吃到的味道究竟是如何产生的，每一道菜，为何一吃就知道正宗不正宗，究竟是那些调料导致的。也开始沉迷研究做菜中产生的各种化学反应。在我看来，做饭与吃饭是相辅相成的，不做饭便吃不出饭菜的好，有点类似正念饮食，要用心体会食物的味道，这对食物也是一种尊重；只做不吃就不能让自己的厨艺更加精进。</p>
<h3 id="弹琴"><a href="#弹琴" class="headerlink" title="弹琴"></a>弹琴</h3><p>双十一买了心心念念的电钢琴，说是心心念念了几年也不过分，但是买之前也挣扎了很久，也怕买了之后变成晾衣架，怕自己只是三分钟热血。但事实证明，并没有。平均每天练一到两个小时。跟着教材学习，也会结合一些视频学习乐理，对乐理的学习，让我对音乐有了新的认识，渐渐的觉得音乐是一种非常严谨的东西。即使它本身算是一种感性的东西(类似《禅与摩托车维修艺术》中所说的浪漫范畴)，但它也是有规律且严谨的。</p>
<h3 id="学粤语"><a href="#学粤语" class="headerlink" title="学粤语"></a>学粤语</h3><p>宜家我学紧白话(手动狗头)。每天利用上下班通勤坐地铁的时候加一起半小时，开始系统的学习粤语，现在感觉看粤语字没啥问题了，发音不太标准，但是可以知道一句普通话怎么写成粤语，明年两个小目标，一是可以说的标准，二是可以掌握粤拼。</p>
<h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><p>今年我在很多问题上有了全新的认识，或许也是因为这魔幻的一年，也或许是因为到了而立之年。郭德纲说：三十岁之前不狂没有出息 三十岁之后还狂肯定没有出息。读库老六说：三十五岁必死。想必这大概说的是一个意思，人总会在三十岁左右有一个时间有一个全新的变化，就仿佛是突然开窍。如果没有，可能这辈子也就不会有了。或许我很幸运正在经历这种变化。如果用一个词来概括，那大概是“认识自我”。同时我越来越发现我自己其实是有一些偏唯心主义，而这让我在这个魔幻的一年精神压力小了不少。</p>
<p><strong>夫唯不争,故天下莫能与之争。</strong>这一年我变得更加平和，执念少了许多。可能这就是精神内守吧，向内求得一种安定。也正因为如此，让我能够正视自己，更全面的看到自己的喜好与长短板。我擅长的，不一定是我热爱的；我热爱的，也不一定是我擅长的。我要做的，不是将它们对齐，而是正确的认识这两种，然后遵从自己的内心，做我想做的。当我不再想去证明自己的时候，会更加的专注于眼前，反而会有意外的收获。</p>
<p><strong>求仁而得仁。</strong>这句话指如愿以偿，我以前经常觉得自己是求不得，直到今年突然有一种感觉，便是也许我已经得了，只是我不认为这是我所求，所以我一直认为求不得。人最难的是知道自己想要什么，想要什么听起来是一个再明确不过的东西，但有很多时候，人是会被周围的环境和其他人所左右的，也许一件东西我原本不想要，只是因为其他人都要，我也便觉得要了也是很好的，但这就并非是我想要。所以求仁得仁，首先要知道求什么“仁”，而这就要排除其他因素，遵从自己的内心，才知道自己真正求的是什么“仁”。</p>
<p><strong>够用就行。</strong>我不再追求“折腾”，反而一切都抱着够用就好的心态，这在别人看来，可能是一种躺平，但我觉得恰恰是因为自己不再创造需求，才更容易发现生活中真实存在的需求。如果自己不断地给自己创造需求，那就没有精力去发现那些生活中真正的需求。</p>
<p>就像伍尔夫所说『走向人内心的路，永远比走向外部世界要漫长的多』。认识自己的过程应该是漫长的，期待我在新的一年能有更进一步的认识。</p>
<h2 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h2><p>入职的体检也没有什么大问题，整体良好。这一年因为疫情防控，零零散散的居家办公，加一起将近两个月，但是在年底一波大开放之后，周围的亲戚、朋友、同事基本都阳了一遍，我算是比较幸运，放开之后就天天上班，但是好在将阴性保持到了 22 年结束。对于防疫我没什么概念，但我觉得普通人能尽力做好的，就是对病毒有足够的敬畏之心，当然也许这敬畏不止要是对病毒，而是对任何事任何人。</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>今年的读书 KPI 完成情况比去年更糟糕，只看了五本书。但人毕竟是擅长找借口的动物，只能是归结为今年添了新嗜好，又比较花费时间，导致时间被稀释了很多。明年是时候要把时间的分配重新调整一下了。</p>
<h2 id="魔幻"><a href="#魔幻" class="headerlink" title="魔幻"></a>魔幻</h2><p>最后有必要谈一下何谓魔幻，我仔细想了一下，大概就是今年是我出生到现在，感受到最为动荡的一年，也许人的一生大部分的时候都处在一种不安和动荡之中，安定、平稳才是奢侈的。银行真的会跑路；楼房真的会烂尾；真的会出现无法自由出行的情况；真的会出现常见药买不到的情况；真的会出现道路以目的情况……防疫的千姿百态，让我不得不联想到《叫魂：1768年中国妖术大恐慌》，我没想到 2022 年依旧会看到一些类似的东西。也许历史真的是不断重复的。而世界也都处在一种剧烈的动荡之中，乌克兰和俄罗斯在打仗，塞尔维亚和科索沃要打仗，台湾地区越来越紧张……但愿这种动荡可以在不久的将来逐渐恢复平稳。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="年度书籍"><a href="#年度书籍" class="headerlink" title="年度书籍"></a>年度书籍</h3><p>(读过的评分在4星以上的)</p>
<ul>
<li><a href="https://book.douban.com/subject/26735206/">《亲密伴侣：爱和婚姻的模式》</a></li>
<li><a href="https://book.douban.com/subject/26613906/">《野生动物在长春·第壹辑》</a></li>
<li><a href="https://book.douban.com/subject/27133274/">《孩子们的诗》</a></li>
</ul>
<h3 id="年度关键词"><a href="#年度关键词" class="headerlink" title="年度关键词"></a>年度关键词</h3><p>认识自我、魔幻</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>年度总结</tag>
        <tag>人生经验</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年度报告</title>
    <url>/2023/12/31/annual-2023/</url>
    <content><![CDATA[<p>2023 年让我感受最深的是『周围的朋友谈论的最多的就是“润”』，这可能是今年值得记录的一个社会现象。就我个人而言，是过的比较舒服的一年，生活质量在上升。感觉我又可以重新把控自己了，或者说至少很多事情在按自己想象的方向发展了。</p>
<span id="more"></span>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>仔细想了一下，好像工作没什么可记录的，但某种程度说，这又可能是值得记录的一件好事。逐渐开始上下班时间变得固定，不再迟到，变得有规律。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>今年是毕业以后第一年觉得自己“存在”。我想原因大概是第一次体会到了传说中的 WLB (Work Life Balance)。我给自己的一个总结是“自己走入了一种『慢生活』状态”。整个人的重心会有很大程度倾斜到了生活这一侧，可以有很多时间做自己的事情。</p>
<h3 id="数字家庭"><a href="#数字家庭" class="headerlink" title="数字家庭"></a>数字家庭</h3><p>花了一些时间来折腾自己的 NAS，终于搞出了一点数字中心的雏形。</p>
<p>NAS 上部署了一些服务，方便自己日常使用：<br>Alist —— 云盘 All In One<br>Aria2 —— 远程下载<br>Calibre-web —— 电子书库<br>FRP —— 内网穿透<br>Gotify —— 短信转发推送<br>Homarr —— 导航<br>Lucky —— 反向代理<br>PhotoPrism —— 照片管理<br>qBittorrent —— BT 下载<br>Vaultwarden —— Bitwarden 私有化</p>
<p>重新规划了一下家里的网络拓扑，打算升级内网 2.5G，有初步方案，但是还没有采购设备，明年要把这块补上。</p>
<h3 id="做饭"><a href="#做饭" class="headerlink" title="做饭"></a>做饭</h3><p>今年自己做菜比较多，粗略统计了一下，大概做了半年菜。而且菜品更加丰富，凉菜热菜(包括一些过油的菜类似糖醋茄条、锅包肉等)和甜品都有尝试一些。</p>
<p>慢慢发现自己使用调料开始变得熟练，三个月前可能都还停留在只能严格按照菜谱来做的水平，现在也可以根据自己的经验灵活的调整用料，并且在跟菜谱做感觉有问题的情况下，会简单的做一些调整来补救。</p>
<p>为了买到合适的调料，自己也查了很多资料，花时间去超市看配料表。慢慢也摸索出了自己买调料的一套方法。这些方法还没有整理出来，后边看看如果有时间的话就整理成文。</p>
<p>去饭店吃饭的时候，能大概吃出用了什么料和基本的烹饪手法类似过没过油等。个人感觉是比以前会吃了，因为自己做饭做的比较多，就知道什么菜不好做，去饭店吃饭，会着重点的菜：自己不会做的菜、自己会做但在家做比较麻烦的菜、比较能看出厨师水平的菜(第一次去的饭店，用来判断饭店行不行)、预制菜大概率做不了的菜。</p>
<p>接近年尾的时候开始尝试早上带一部分早餐，比如鸡蛋等，究其原因还是食堂去晚了就没有鸡蛋了。</p>
<h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>《双人成行》跟女朋友一起玩双人成行，玩了大概百分之七十，解锁了自己一个人用俩手柄，清 BOSS 的成就(手动狗头)。</p>
<p>《Bloons TD 6》今年玩了 260 小时，有些上头，直接取代了 《QQ飞车手游》和 《扫雷》。22 年连续不间断的玩了一年扫雷，但是 23 年微软的扫雷改版了，不是很清楚策划的脑回路，基本没有看到这次改版的正面评价，实在忍受不了新版，果断弃坑了。</p>
<p>发现自己更喜欢玩带有一点策略(非庞大策略)和技巧(非动作技巧)的游戏，在这个基础上，如果剧情写的好，就是加分项。</p>
<h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><h4 id="珠海"><a href="#珠海" class="headerlink" title="珠海"></a>珠海</h4><p>因为女朋友没去过珠海，跟女朋友去珠海转了转。像第一次去珠海的游客一样，打卡了一些常规景点，也重游了一下当年在珠海总去的地方。对于她更像是旅游，对于我，可能更多的是想起珠海的一些人和事。值得一提的是，本来想去逛圆明新园，结果从里边上山走到了山上的栈道，从板障山下来，原本的游园直接改成了爬山，这是我没想到的</p>
<h4 id="昆明、大理"><a href="#昆明、大理" class="headerlink" title="昆明、大理"></a>昆明、大理</h4><p>正经的旅游，便是大理之行，五天，大部分时间都在大理，前后两天在昆明小逛了一下。去之前，周围的同事和朋友基本都说，五天的话，其实可以多去几个地方，但是前期做了攻略还是感觉，要玩就精玩，粗略的走马观花我和女朋友都不是很喜欢。</p>
<p>在昆明，去了传说中的网红菜市场；</p>
<p>在大理，赶上了三月街的集市；去喜洲学习做扎染，染了一条裙子；爬了苍山，打卡洗马潭；生态长廊骑电动车环洱海；游览双廊古镇；游览大理古城、走的时候还买了辣椒面和蘑菇带回来。</p>
<p>五天其实大理也没有按原定计划全部玩完，有一些地方因为时间没有去，但感觉还是不虚此行的。</p>
<p>一个插曲便是去的时候去机场有点迟了，行李没法托运，后来是走了特殊行李托运，行李跟着下一班飞机到，安检走了绿色通道一路狂奔。但是正因为如此，临时决定去昆明的网红菜市场，也算是无心插柳了。</p>
<p>没有工作电话的提心吊胆，可以完全沉浸在旅行之中。这种久违的放松，上一次还是 18 年自己出去旅行的时候。这一次便是两个人了。</p>
<p>之前想在大理旅行之后，剪个 vlog 出来，在大理玩的时候就拍了一些素材，但是回来之后剪了几次，总是感觉不满意，所以一直没有成片，这个只能到 24 年再琢磨了。</p>
<h3 id="年夜饭"><a href="#年夜饭" class="headerlink" title="年夜饭"></a>年夜饭</h3><p>第一次掌勺春节的年夜饭。做了油焖大虾、烤羊排、上汤娃娃菜、红烧金鲳鱼、山药火龙果(我妈做)、卤猪蹄(买的)。</p>
<h3 id="按时睡觉"><a href="#按时睡觉" class="headerlink" title="按时睡觉"></a>按时睡觉</h3><p>下半年自己算是“按时睡觉”了，每天十一点基本就会躺下，所以觉得今年的平均睡眠质量肯定是要好过前三年的，当然这些都要归功于女朋友。已经记不起自己是从什么时候开始逐渐变为守夜冠军，严谨点说可能从大学就开始了，但是越往后逐渐加深，这两年很多时候都是三点才睡，能明显感觉到三点睡觉，其实身体就已经有些不适了，会比较烦躁，但是到了晚上就是要嗨起来，完全控制不住。现在女朋友监督，就不敢再熬夜了，整个人状态好了不少。</p>
<h3 id="一阳"><a href="#一阳" class="headerlink" title="一阳"></a>一阳</h3><p>迟到的一阳，难忘的沪上阿姨，4.28 晚上喝了同事一杯沪上阿姨，就觉得太甜嗓子不舒服；4.29 嗓子就很疼了，晚上开始发烧；4.30 直接起不来请假没去上班了，同组的同事也有好几个是如此。整个五一泡汤了，都是在床上躺着度过的。本来计划着跟女朋友爬山，也没去成了。</p>
<h3 id="大件"><a href="#大件" class="headerlink" title="大件"></a>大件</h3><p>电视：索尼 X90K。要买电视的时候，仔细研究了一下电视的 SoC，原来只是有个粗略的印象索尼的贵，但是后边发现，其实索尼的电视也是很舍得堆料的，并且算法调教的也好，同等 SoC 的国产电视其实也并不便宜，算法做的也烂。同时也研究了一下 LED、MiniLED 和 OLED。最后根据自己预算选了 X90K。</p>
<p>冰箱：东芝雾语系列 PM137。当时找了很久，最开始看了东芝的大小白桃，后来又去看海尔和卡萨帝。不过法式门里边，都没有比较符合我要求的。如果想要制冰，就只能买日系冰箱。后来还是决定放弃制冰的需求，以后如果需要用冰格解决。然后买了这款，其实这款的设计应该是美的给的，虽然是东芝的牌子，因为日本的设计冷冻室都很小，不太可能是日本设计的，不过好在压缩机还行，就选了这款。</p>
<p>内衣裤洗衣机：美的 MNB10-01L。感觉内衣裤洗衣机目前还没什么标准，而且我总觉得智商税很多，毕竟普通洗衣机+消毒液完全可以覆盖掉，但是这东西满足了很多人的“精神需求”，所以还是有它的市场，当时只是关注了 95℃ 高温功能，再加上内衣轻柔洗，就买了这款。</p>
<p>净水器：世韩 2S。选购的时候主要关注：有桶机、桶容量、通用滤芯。通用滤芯这一条就过滤了很多牌子，基本没有几个选择了，就选择了这一款，价钱也还不错。</p>
<p>台上饮水机：飞利浦小白熊。积分购置，没什么太多选择。</p>
<p>今年在电器选购上，也有了很多新的经验，后续如果有时间，也要整理成文。</p>
<h3 id="调素琴、阅金经"><a href="#调素琴、阅金经" class="headerlink" title="调素琴、阅金经"></a>调素琴、阅金经</h3><p>今年读书比去年还少，只读了两本书，其余就是上班路上看的订阅的期刊。还有一大堆书买了没看，还有一大堆订阅的报刊没看。</p>
<p>琴弹得也比较少了，阳了之后，就没有再保持规律学习弹琴的节奏，只是偶尔拿出来弹一弹。</p>
<h3 id="恋爱"><a href="#恋爱" class="headerlink" title="恋爱"></a>恋爱</h3><p>终于知道，原来可以有”没有精神负担“的爱情，也可以有”不用委屈自己“的爱情。</p>
<h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><h3 id="i人e人"><a href="#i人e人" class="headerlink" title="i人e人"></a>i人e人</h3><p>今年很流行一个词就是 i人 e人，我想我应该是个 i 人。就像之前圆桌派里说『区分内向和外向并不是看这个人是否参加活动，而是要看这个人参与跟人活动的时候是消耗能量还是恢复能量，如果是消耗能量就是内向，恢复能量就是外向』，如果这么说我显然是前者。其实对于 i 人来说，生活是很累的，会很容易感受到周围人的情绪输出，而且很容易影响自己的情绪。</p>
<h3 id="关于快乐"><a href="#关于快乐" class="headerlink" title="关于快乐"></a>关于快乐</h3><p>今年最喜欢的话之一——『本质是在存在之后』。只有对“存在过”进行总结，才能提炼出“本质”。</p>
<p>之前跟很多朋友聊天，感觉他们过的很拧巴，我自己前几年也是这个状态，这两年就快乐很多。</p>
<p>以前经常因为这个世界不符合自己的认知而感受到痛苦，但是现在觉得，其实<strong>认知是用来认识世界的，而不是用来预测世界的</strong>，任何阶段的认知只是帮我们总结这个世界，但并不能用来预测下一阶段的世界。给人、给世界少下定义，避免将他们符号化，就会让自己快乐起来。</p>
<h3 id="关于选择"><a href="#关于选择" class="headerlink" title="关于选择"></a>关于选择</h3><h4 id="衡量选择"><a href="#衡量选择" class="headerlink" title="衡量选择"></a><strong>衡量选择</strong></h4><p>因为我们在任何时候只能总结世界，而选择是一种预测行为，所以对于自己来说，比较难的是如何衡量自己的选择。</p>
<p>好的选择分两种：“走对了”和“没走错”；看到了走对了很容易，但是看到没走错很难。但对于大部分人来说，能做出的好的选择，直接看到“走对了”的情况很少，更多的是“没走错”。</p>
<p>很多时候因为我们看不到自己“没走错”，就会质疑自己的选择。就像去年离开腾讯，有时候也会怀疑，是不是正确的选择。但当我在写今年的总结时候，至少可以确定的说在这一阶段，自己是没走错的。</p>
<p>能看到自己“没走错”，便越来越觉得这个世界是公平的，“老天爷”是公平的。</p>
<h4 id="主动选择？被动选择？"><a href="#主动选择？被动选择？" class="headerlink" title="主动选择？被动选择？"></a><strong>主动选择？被动选择？</strong></h4><p>跟朋友聊天，再加上我自己的感受，其实如果自己过的拧巴，大多时候是分不清选择是自己主动选择还是被动选择。人很容易把很多选择归为被动选择，但实际上是自己的主动选择。</p>
<p>就像我在腾讯觉得工作氛围不对，方法论也不对。因为又觉得收入还行，所以”不得不“在这里按头工作，这就推导出了被动选择，但其实真实是我因为收入不错主动选择在这里，如果我不在乎收入，可以选择不在这里，说到底还是自己既要又要的问题。</p>
<p>现实生活中，人很多时候会出现这种归类错误的问题，因为人总是更愿意把问题推给其他人，不愿意正视自己，不愿意承认自己既要又要。当归类到被动选择之后，人就多了很多”不得不“要做的事情，其实没有什么是”必须“”不得不“的事情，想做就做，不想做就不做，如果多归类于主动选择，当规则有问题的时候，主动去质疑规则，或许思路就打开了。</p>
<h3 id="关于时间"><a href="#关于时间" class="headerlink" title="关于时间"></a>关于时间</h3><p>今年的另一个感受是时间的流逝更快了，这也许是认识到自己正在变老的另一个佐证。总觉得自己没做什么有意义的事情，也没有太多可记录的东西。现在理解了小时候不爱记日记的原因，大抵是小时候最富裕的便是时间，太充裕了自然不会有”记录下来，防止它们流逝“的需求。</p>
<h3 id="关于成长"><a href="#关于成长" class="headerlink" title="关于成长"></a>关于成长</h3><p>成长的过程是对自己解构的过程，对自己逐渐有一个清晰的认识。知道自己的得失观，清楚的知道什么东西是一定不能失去的，什么东西是可有可无的，知道哪些人是重要的，哪些人是不重要的，开始敢于损失一部分可有可无的东西，敢于打破一部分关系，去换新的责任和新的体验，让自己有一部分”焕新“，去体验下一个人生阶段。而这一切在有些人看来是所谓的被迫选择，他们会用：枷锁、牢笼、桎梏，这种词语来形容，但其实他们并不知道也不理解，这其实是自愿选择。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>2023 总体满意，2024 再接再厉。要将自己的生活方面的活动系统的规划一下了，期待 2024……</p>
<h3 id="年度书籍"><a href="#年度书籍" class="headerlink" title="年度书籍"></a>年度书籍</h3><p>(读过的评分在4星以上的)</p>
<ul>
<li><a href="https://book.douban.com/subject/35092383/">《把自己作为方法——与项飙谈话》</a></li>
</ul>
<h3 id="年度人物"><a href="#年度人物" class="headerlink" title="年度人物"></a>年度人物</h3><ul>
<li>女朋友</li>
<li>道哥</li>
</ul>
<h3 id="年度关键词"><a href="#年度关键词" class="headerlink" title="年度关键词"></a>年度关键词</h3><ul>
<li>润</li>
</ul>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>年度总结</tag>
        <tag>人生经验</tag>
      </tags>
  </entry>
  <entry>
    <title>AVL树(自平衡二叉树)</title>
    <url>/2017/11/06/avl-tree/</url>
    <content><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>二叉树</li>
<li>同节点左右子树高度差不超过1<span id="more"></span></li>
</ul>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul>
<li>插入、查找、删除均为O(logN)</li>
</ul>
<h2 id="节点数"><a href="#节点数" class="headerlink" title="节点数"></a>节点数</h2><ul>
<li>最多(满二叉树) <code>2^h-1</code></li>
<li>最少 <code>2^(h-1)</code></li>
</ul>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="旋转："><a href="#旋转：" class="headerlink" title="旋转："></a>旋转：</h3><ul>
<li>左旋：节点的左旋，节点的右孩子指针指向节点右孩子的左孩子，节点的右孩子的左孩子指针指向节点。</li>
<li>右旋：节点的右旋，节点的左孩子指针指向节点左孩子的右孩子，节点的左孩子的右孩子指针指向节点。</li>
</ul>
<h3 id="平衡因子："><a href="#平衡因子：" class="headerlink" title="平衡因子："></a>平衡因子：</h3><ul>
<li>平衡因子&#x3D;左子树高度-右子树高度</li>
</ul>
<p><strong>导致AVL Tree不平衡的几种类型及调整方法:</strong></p>
<h3 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h3><ul>
<li>LL：节点的左(L)子树的左(L)子树因为存在非空子节点，导致与节点的右子树高度差超过1 <strong>(右旋)</strong></li>
<li>LR：节点的左(L)子树的右(R)子树因为存在非空子节点，导致与节点的右子树高度差超过1 <strong>(先左旋再右旋)</strong></li>
<li>RL：节点的右(R)子树的左(L)子树因为存在非空子节点，导致与节点的左子树高度差超过1 <strong>(先右旋再左旋)</strong></li>
<li>RR：节点的右(R)子树的右(R)子树因为存在非空子节点，导致与节点的左子树高度差超过1 <strong>(左旋)</strong></li>
</ul>
<h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><ul>
<li>删除叶子结点，删除之后判断一下是否平衡</li>
<li>删除只带有左子树或右子树的节点，直接把子树节点接上就行了</li>
<li>删除带有左右子树的节点，找其左子树的最大节点或者是其右子树的最小节点交换值，然后删除被交换节点(规则跟删除叶子结点一样了)。选择左子树的最大节点还是右子树最小节点可以根据左右子树高度选择，优先选高的子树，这样更快趋于平衡。</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书笔记】大教堂与集市-黑客圈简史</title>
    <url>/2018/09/05/book-djt-js-1/</url>
    <content><![CDATA[<p>研究计算机的开源文化，就不得不说起早期的极客(geek)，比起其他行业来说，计算机行业很幸运，一群牛逼的人开了一个好头，他们身上的特质，直接影响了整个行业，以及后来的计算机人。向他们致敬。</p>
<span id="more"></span>
<h1 id="黑客圈简史"><a href="#黑客圈简史" class="headerlink" title="黑客圈简史"></a>黑客圈简史</h1><ol>
<li><p>真程序员</p>
</li>
<li><p>早期的黑客</p>
<blockquote>
<p>计算机问世之后迅速涌现了一批编程爱好者，他们编写软件只是出于乐趣，慢慢形成了一些技术文化。这批人被称之为真程序员(Real Programmer)。他们通常具备了工程学和物理学的背景，并常常是业余无线电爱好者。在现在的眼光看来，应该叫做极客(geek)。在这些真程序员的带动下，形成了一种所谓的黑客(Hack)文化。初期的黑客文化主要是集中在大学的圈子里，不流俗，不走寻常路，极具创新精神。</p>
</blockquote>
</li>
<li><p>UNIX的兴起</p>
<blockquote>
<p>1969年，APRAnet(第一个高速互联网)、UNIX和C语言都诞生在这一年。UNIX和C的组合凭借着(KISS)哲学(Keep It Simple, Stupid)迅速风靡，马上就形成了一股新生力量，可以把这一力量叫做<strong>Unix&#x2F;Usenet文化</strong>，与此相对应的就是之前的黑客文化，可以简要叫做<strong>ITS(不兼容分时系统)文化</strong>。1975年第一台个人电脑进入市场，1977年苹果公司成立，马上又有一拨人出现，他们用BASIC，可以把这批人称为<strong>没有组织的微机爱好者</strong>，不过这股力量遭到上面两种力量的共同鄙视。</p>
</blockquote>
</li>
<li><p>远古时代的终结</p>
<blockquote>
<p>三种文化其实代表了三个不同的技术体系。1980年，力量最强的是PDP-10文化，但是却也逐渐显得疲软，主要是人才在不断向其他文化转移，技术也略显过时。1983年ITS文化的依赖ITS被宣布不再继续研发，因为不可移植的东西是没有未来的。显然微型计算机是大势所趋，只有能跑在所有机器上的技术，才是王道。</p>
<p>就在这时，Richard M. Stallman(Emacs的发明者)坚决反对将实验室研究成果商业化。他离开了实验室，创建了自由软件基金会(FSF)。Steven Levy(《黑客》作者)称他为“最后一个真正的黑客”。</p>
<p>1982年RMS开始用C重新构建UNIX的克隆，并且免费发布，这就是大名鼎鼎的GNU(Gnu is Not Unix)这是一个递归式的缩写。此后GNU成为了所有黑客文化的焦点，ITS文化和Unix文化汇入了一起，准确的说是Unix文化将ITS精神融入了自己的圈子，此后的十多年，自由软件基金会统治了黑客文化的意识形态，RMS本人也便是黑客文化的最高精神领袖</p>
</blockquote>
</li>
<li><p>“专有UNIX”时代</p>
<blockquote>
<p>1984年，黑客文化的圈子分为了两个阵营，一部分是围绕着Internet和Usenet的网络派，还有一部分是不联网的微机爱好者。也正是这一阶段，出现了一些关于计算机的攻击事件，媒体将黑客这一词用来描述这些做坏事的人，一直沿用至今。<br>这个阶段Sun和其他公司生产的工作站级别的电脑出现，大家的关注点便放在了让其进行更高效的图形处理和更快捷的网络传输上。</p>
<p>在网络传输方面，Berkeley UNIX提供了对APRAnet协议的内置支持，解决了UUCP点到点连接慢带来的网络问题，促进了互联网的进一步发展;</p>
<p>而在图形处理方面，则出现了<strong>X Window</strong>。在若干尝试中，X Window脱颖而出，正是由于吸纳了十多家公司数百名员工的贡献，而关键在于开发者愿意遵守黑客盗的免费提供源码，而且通过互联网发布。，在几年间<strong>X Window</strong>战胜<strong>专有图像处理系统</strong>这件事深深地影响了整个UNIX</p>
<p>随着1990年最后一台ITS机器关机，ITS文化正式消失了，这部分力量放下立场，融入了UNIX文化。<br>紧接着就是UNIX的内战，最重要的两个便是Berkeley UNIX与AT&amp;T UNIX，代表了免费与商业的斗争。</p>
<p>20世纪90年代基于Intel 386芯片的PC出现了，MS-DOS和Mac的用户如雨后春笋般，然而并没有发展出什么带有自我意识的文化。与此同时商业的UNIX贵的一批且没有可移植性，而自由软件基金会也没能给出易用的可移植的UNIX。以至于在UNIX青黄不接之时，微软凭借Windows操作系统，抢占了市场份额。当然自此便经常可以看到媒体发声，“UNIX要玩完”的言论，直到现在依旧如此
 </p>
</blockquote>
</li>
<li><p>早期的自由UNIX</p>
<blockquote>
<p>1994年Berkeley UNIX研究组彻底失去了经费支持，看似UNIX是彻底玩完了。但是其实在人们关注之外，自由软件基金会一直未完成的可移植内核让一个大学生起了兴趣，这个人就是Linus Torvalds。</p>
<p>1991年，他开始使用FSF提供的套件为386开发自由Unix内核，他成功了，并且还吸引了很多黑客跟他一起做这件事情。这个产物就是Linux，全功能的Unix，免费而且代码完全公开，可以再发布。</p>
<p>Linux的开发成功，让人们得到了不一样的思考。以前的人们一直觉得对于如此复杂的系统必须要一个小而美的团队来做，团队要紧密互动，在Linux之前几乎所有的项目都是如此。而Linux从一开始就走了一条截然不同的路线，没有约束，各位合作者随意发挥，只有一个简单的约定，每周发布，得到用户反馈，并改之，让人惊讶的是这却工作的很好。一个很好的比喻便是<strong>物竞天择</strong>。</p>
<p>1993年底，Linux的稳定性已经和商业Unix不相上下了，加之商业Unix贵，很多人已不再使用商业Unix，导致很多商业Unix关门大吉。一些商业软件也已经开始考虑一直到Linux，不再支持Unix。至此黑客们对外界唱衰Unix便不再理会，开始用自己的观点重塑商业软件世界.
 </p>
</blockquote>
</li>
<li><p>WEB大爆发</p>
<blockquote>
<p>20世纪90年代，也就是Linux的早期，互联网也开始大行其道，变得便利，而黑客们的工作也就变成开发Linux，宣传互联网。Linux也借到了互联网便利的东风，迅速流传开来。当互联网成为主流，黑客群体便受到了尊重。也出现了一些政治影响。</p>
<ol>
<li>黑客们通过抗议阻止了一个强加密算法置于美国政府的控制下</li>
<li>黑客们通过发动同盟阻止了“通信合宜法(CDA)”。CDA指的是当时的美国为了避免色情内容流传于互联网影响青少年，提出监管网络内容。而这一做法遭到了美国公民自由联盟的起诉，理由是侵犯了公民言论自由的权利，CDA最终在1997年被废除。</li>
</ol>
</blockquote>
</li>
</ol>
<p><strong>至此黑客文化终于在这个世界上有了一席之地</strong>
    </p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>极简 OBS 编译流程</title>
    <url>/2020/07/12/build-obs/</url>
    <content><![CDATA[<p>最近在搞 Nimo 主播端，主要是基于 OBS 魔改。所以就给组里同事写了一个极简的 OBS 编译流程。</p>
<span id="more"></span>
<p>这里以 OBS 25.0.8 为例。</p>
<ol>
<li>拉取 OBS 代码 <a href="https://github.com/obsproject/obs-studio">https://github.com/obsproject/obs-studio</a> (<code>source path</code>)</li>
<li>切换到 25.0.8 tag</li>
<li>下载依赖的 Qt 库 <a href="https://cdn-fastly.obsproject.com/downloads/Qt_5.10.1.7z">https://cdn-fastly.obsproject.com/downloads/Qt_5.10.1.7z</a> (<code>Qt path</code>)</li>
<li>下载编译过程需要的依赖 <a href="https://obsproject.com/downloads/dependencies2017.zip">https://obsproject.com/downloads/dependencies2017.zip</a> (<code>dependency path</code>)</li>
<li>安装最新版的 CMake  <a href="https://cmake.org/download/">https://cmake.org/download/</a></li>
<li>安装Windows 10 SDK (10.0.19041.0) <strong>(注：低于这个版本会因为找不到一个 winrt api 编不过)</strong></li>
<li>新建工程目录 (<code>build path</code>)</li>
<li>打开 CMake GUI 。 并设置 Source 为 <code>source path</code>， 设置 Build 为 <code>build path</code></li>
<li>点击 Configure</li>
<li>编译 x64 不需要填额外参数点 Finish</li>
<li>Configure 出错莫慌，设置 DepsPath 为 <code>dependency path</code>，设置 QTDIR 为 <code>Qt path</code> 的下级目录(指定位数这一级) msvc2017_64</li>
<li>再次点击 Configure</li>
<li>点击 Generate</li>
<li>这个时候就可以在 <code>build path</code> 看到解决方案了，用 VS 打开编译即可</li>
<li>生成的 obs64.exe 在 <code>UI\Debug\</code> 下</li>
</ol>
<p>这只是 OBS 不带任何其他开关的编译方法。如果需要其他非默认模块，Configure 之前将需要的宏定义加入，再生成解决方案。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OBS</tag>
      </tags>
  </entry>
  <entry>
    <title>编译Qt</title>
    <url>/2016/01/03/build-qt/</url>
    <content><![CDATA[<p>参考:</p>
<ul>
<li><a href="http://wiki.qt.io/Building_Qt_5_from_Git">Building-Qt5-from-Git</a></li>
</ul>
<p>Windows 下自己准备自己想要的编译器。编译自己想要的 Qt 版本<br>最近 5.6 出来了，有好多新的变化，第一时间准备尝鲜。<br>我自己的是 MSVC2015 Qt5.6</p>
<span id="more"></span>
<p>首先要准备：</p>
<ul>
<li>Perl</li>
<li>Git</li>
<li>python</li>
</ul>
<p>如果要是编译webkit的话，还需要 icu 套件，这次为了熟悉流程先不编这个，因为 Qt5.6 已经把 webkit 移除了，换成了 webengine ，官网的文档还没有更新，暂时还没研究</p>
<p><strong>一定要先装Perl再装Git，以免用了老的Git，会导致脚本失败</strong><br>而且安装Git的时候需要选择<strong>可以在cmd使用Git命令</strong>，不然就只能用Git自己带的那个命令行了<br>Qt的代码使用Git做版本管理，但是他的子库很多，每个模块都是单独的一个仓库，所以检出的时候为了避免麻烦则用Perl写成了脚本。</p>
<p>为了方便的话，可以直接用VS的命令行，这样免了设置MSVC的环境了。<br>设置一些环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET _ROOT=C:\qt5</span><br><span class="line">SET PATH=%_ROOT%\qtbase\bin;%_ROOT%\gnuwin32\bin;%PATH%</span><br><span class="line">SET QMAKESPEC=win32-msvc2015</span><br><span class="line">SET _ROOT=</span><br></pre></td></tr></table></figure>

<ul>
<li>注：_ROOT设置成自己检出Qt代码的目录(你检出代码之后再去设置这些也是可以的)，QMAKESPEC 设置成自己用的编译器</li>
</ul>
<h3 id="取顶层仓库"><a href="#取顶层仓库" class="headerlink" title="取顶层仓库"></a>取顶层仓库</h3><blockquote>
<p>git clone git:&#x2F;&#x2F;code.qt.io&#x2F;qt&#x2F;qt5.git</p>
</blockquote>
<p>或者是</p>
<blockquote>
<p>git clone <a href="https://code.qt.io/qt/qt5.git">https://code.qt.io/qt/qt5.git</a></p>
</blockquote>
<p>这样会在你的目录下检出Qt顶层仓库。</p>
<p>然后执行Perl脚本检出子库</p>
<blockquote>
<p>perl init-repository</p>
</blockquote>
<ul>
<li>注：这里边官方文档说是可以使用–no-webkit来屏蔽webkit相关子库，但是我这里是不能用这个参数的，无法解析这个参数，看脚本内容也没有跟–no-webkit相关的。虽然把webkit的代码检出了，但是编译的时候，如果你没有安装上边说的icu套件，编译会自动跳过的。</li>
</ul>
<p>接下来是configure</p>
<blockquote>
<p>configure -prefix f:&#x2F;qtsrc&#x2F;qt-msvc2015-x64 -debug -static -platform win32-msvc2015 -c++11 -opengl desktop -qt-libpng -qt-libjpeg -nomake examples -nomake tests -mp</p>
</blockquote>
<p>这是我的配置，基本上都是一眼就能看出来的选项。(从我的观察来看Qt5以上应该已经不支持<em>demos</em>这个选项了，如果加了会报错)</p>
<p>然后编译</p>
<blockquote>
<p>nmake</p>
</blockquote>
<p>转移到其他目录(就是-prefix指定的目录)</p>
<blockquote>
<p>nmake install</p>
</blockquote>
<p>在目录下就能看到已经编好的工具还有lib了。想要dll什么的改下configure的参数就可以了</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云(CentOS7.4、专有网络)配置shadowsocks-server</title>
    <url>/2017/11/12/centos7-shadowsocks/</url>
    <content><![CDATA[<p>双十一在阿里云剁了一个服务器，随便搞搞，找了一些教程，搭了个梯子。</p>
<span id="more"></span>

<h3 id="安装Python、pip"><a href="#安装Python、pip" class="headerlink" title="安装Python、pip"></a>安装Python、pip</h3><p>这一步在阿里云的预装系统上，不需要，系统带了</p>
<h3 id="安装配置shadowsocks"><a href="#安装配置shadowsocks" class="headerlink" title="安装配置shadowsocks"></a>安装配置shadowsocks</h3><p>安装 shadowsocks：</p>
<blockquote>
<p>$ pip install shadowsocks</p>
</blockquote>
<p>安装完成后，创建配置文件，路径可以自选，自己能找到就行</p>
<p><code>/etc/shadowsocks/config.json</code></p>
<blockquote>
<p>{<br>​    “server”:”0.0.0.0”,<br>​    “local_address”:”阿里云公网ip”,<br>​    “local_port”:”15645”，<br>​    “port_password”:{<br>​         “8838”:”password”,<br>​         “8839”:”passworda”<br>​     }<br>​     “timeout”:300,<br>​     “method”:”aes-256-cfb”,<br>​     “fast_open”:false<br>}</p>
</blockquote>
<p><code>port_password</code>配置客户端连接的时候访问端口，和需要的密码</p>
<p><code>method</code>配置加密方法</p>
<p><code>server</code>不要写阿里云的公网ip，这样启动的时候会报连接不上加载不起来</p>
<p><code>local</code>的两项目测配置server不是必须的</p>
<h3 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h3><p>创建启动脚本<code>/etc/systemd/system/shadowsocks.service</code>:</p>
<blockquote>
<p>[Unit]</p>
<p>Description&#x3D;Shadowsocks</p>
<p>[Service]<br>TimeoutStartSec&#x3D;0<br>ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;ssserver -c &#x2F;etc&#x2F;shadowsocks&#x2F;config.json<br>ExecReload&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPID<br>ExecStop&#x3D;&#x2F;bin&#x2F;kill -s QUIT $MAINPID<br>PrivateTmp&#x3D;true<br>KillMode&#x3D;process<br>Restart&#x3D;on-failure<br>RestartSec&#x3D;5s</p>
<p>[Install]<br>WantedBy&#x3D;multi-user.target</p>
</blockquote>
<p>这个时候要让防火墙对刚才配置的端口放行</p>
<blockquote>
<p>查看状态：$ systemctl status firewalld<br>启动：$ systemctl start firewalld</p>
</blockquote>
<blockquote>
<p>$ firewall-cmd –zone&#x3D;public –add-port&#x3D;8838&#x2F;tcp –permanent<br>$ firewall-cmd –zone&#x3D;public –add-port&#x3D;8839&#x2F;tcp –permanent</p>
</blockquote>
<p>将<code>8838</code>、<code>8839</code>两个端口放行。阿里云还有个安全组，在阿里云的控制台可以找到，然后添加规则将上边两个端口放行(授权对象写0.0.0.0&#x2F;0就好)</p>
<p>执行以下命令启动 shadowsocks 服务：</p>
<blockquote>
<p>$ systemctl enable shadowsocks.service<br>$ systemctl start shadowsocks.service</p>
</blockquote>
<p>查看启动状态：</p>
<blockquote>
<p>$ systemctl status shadowsocks.service -l</p>
</blockquote>
<p>如果发现失败了，这里的报错信息是不全的</p>
<p>可以手动启动ss，看一下是什么错误</p>
<p>以指定配置启动ss ：</p>
<blockquote>
<p>$ ssserver -c &#x2F;etc&#x2F;shadowsocks&#x2F;config.json</p>
</blockquote>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title>【复音口琴】单音技巧</title>
    <url>/2014/12/20/dan-yin-ji-qiao/</url>
    <content><![CDATA[<p>单音里边又分旧式单音和新式单音。</p>
<p>旧式单音就很容易学了，有两种方法</p>
<ol>
<li>口型缩到最小，然后吹一排孔，也很容易分辨自己是否吹干净，没杂音就算是吹对了；</li>
<li>或者是吹三个孔，拿3为例，吹234这三孔，因为旁边两孔均是吸音，所以只能吹出3这个音。吸音也是如此；</li>
</ol>
<p>第一种方法如果想验证是不是只吹了一个孔而不是吹成了第二种方法的三个孔，有一个小技巧，找一个吹音，例如3，保持口型不变，旁边移动一个格子，继续吹，如果是第二种方法会吹出三度和音的效果(吹到了3和5)，如果你的口型是第一种口型正确的话应该是吹不出声音，因为4是吸音，吹是不发声的。</p>
<p>旧式单音的两种方法均可以，而且也很好练习，就不做过多叙述了。</p>
<span id="more"></span>

<p>而新式单音则是新手的第一道门槛，也是舌堵单音。口含7孔堵住6个。</p>
<p>看到很多人会纠结是不是含七个，我自己的亲身体会是没必要纠结。因为我也是前几天在练习分解和音的时候偶然发现，我一直都是含5个堵住4个。但是只要掌握了这个技巧，改过来是很好改的。所以在新式单音的学习上，重点还是在舌堵，而不是多少个孔。</p>
<p>练习的时候，我比较推崇闲庭落木的方法，附上<a href="http://tieba.baidu.com/p/2741702530">他的教学视频</a>。文字叙述的话，便是先吹空气伴奏，也就是七个孔一起吹，然后舌头堵上去，之后向左摆动调整位置，直到吹的单音干净。开始的时候，一个音一个音的练习，基本上把大部分的音都可以吹到干净，舌头在口中的相对位置便记熟了。</p>
<p>然后便练习新式单音在口琴上直接移动爬音阶。其实这个就很好练习了。放松自己的舌头，然后在琴上滑动吹奏各个音。需要注意的只是舌头只是搭在琴上，而不是黏在琴上，这一点尤其重要，所有的乐器在演奏的时候都是很放松的，如果舌头紧绷那必然也是不对的。</p>
<p>在可以熟练的吹奏音阶之后，找一些简单的曲子，我自己当时是吹奏《口琴考级曲集》里面的一二级曲子，当然事实上，什么简谱都可以拿来练习。但是刚开始一定不要求快，而是先吹每个音都吹准，然后才是快，这点很重要，不然养成了习惯，单音很容易吹不干净。</p>
<p>这些过程学习的时间因人而异，关键是看效果，效果吹到位了，单音吹干净了，便是学成了。</p>
<p>新式单音的练习可以锻炼自己的舌头的感觉，并且如果想学习复音口琴后面的技巧，干净的单音是前提。如果单音吹不干净，伴奏或者是后面的五度八度和音感觉都会很差。</p>
<p>关于练习时口水的问题，是很多刚开始学习的人都有的一个经历，如果特别讨厌这种感觉，那就不要学习了，勉强自己也不好。但是值得一提的是，随着自己的练习，口水就没有之前流的那么任性了，现在我吹琴，有时候吹着吹着反而觉得在琴上划不动了，口水流的太多只是刚开始的一个反应。还有就是，要注意保持口琴的清洁，吹奏结束要倒一倒口水，然后再用点酒精消消毒，擦干净，要不然时间长琴不卫生，而且还会有异味……</p>
]]></content>
      <categories>
        <category>口琴吹奏技巧</category>
      </categories>
      <tags>
        <tag>harmonica</tag>
        <tag>复音口琴</tag>
      </tags>
  </entry>
  <entry>
    <title>写在深夜</title>
    <url>/2015/03/13/deep-night/</url>
    <content><![CDATA[<p>自己刚开始搞博客是去年12月份，弄得热火朝天，结果到头来写了两三篇日志就辍笔了。真是尴尬。寒假回家的时候就有心上来弄一下，但是玩的不亦乐乎也就忘了这茬了。在公司，晚上就有很多机会搞这个博客了。今天的收获不小，把之前一直搞不定的文件夹权限的问题搞定了，FTP连接也搞定了，现在的WordPress总算是稳定了。自己也能专心写写博客。但是还有phpmyadmin搞不定。没办法，自己nginx实在是不懂，搞了个反向代理也是现学现卖，其实原理还是傻傻的分不清，有时间再去详细弄弄。</p>
<span id="more"></span>

<p>这两天都是蛮开心的，毕业设计方面有比较大的进展，一直搞不定WP的TCP通信，昨天偶然想起我在图书馆借的一本《Windows Phone8开发技巧与案例精解》，最喜欢看这种书了，有例子一看就明白。果然，有一个现成的例子，照着敲了一下，还真的跑起来了。不过WP的TCP通信强行用异步的方式我也是醉了，没个例子只看文档的话还真是傻傻的弄不清。明天白天开始撸开题报告，感觉在公司就比较充实了，在学校玩心太重，真是罪过。港澳通行证也到了，还不错的样子。</p>
<p>《苏东坡传》回家之后看完了，感觉还是和我最初看的时候有一点点不一样，慢慢的接受了林对苏的赞美，也开始欣赏苏的为人。有时候想想自己对于很多事情太过武断，总是以为自己是见微知著，但是到最后却发现自己其实是坐井观天罢了。希望自己以后对事情能够更加认真些吧，这样也让自己看起来更稳重些吧。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>DLL 导出符号的两种方式</title>
    <url>/2019/04/28/dll-export-function-way/</url>
    <content><![CDATA[<p>最近恰好需要用 C++ 实现一个供 C# .NET 调用的模块，用<code>dllexport</code>导出符号的时候出现了一点问题，明明已经看到了导出符号，但是 .NET 在调用的时候，就是找不到方法。然后用 def 文件的方式导出符号就正常，突然对这两种方式的区别产生兴趣，之前一直没有研究过，就仔细了查阅一番。</p>
<span id="more"></span>
<p>以导出名为 TESTFUNC 方法为例：</p>
<h2 id="def-文件方式"><a href="#def-文件方式" class="headerlink" title="def 文件方式"></a>def 文件方式</h2><p>，正常在程序中定义方法，然后新建一个 .def 文件，内容类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIBRARY</span><br><span class="line">EXPORT</span><br><span class="line">    TESTFUNC</span><br></pre></td></tr></table></figure>

<p>在其他工程使用这个方法的时候需要头文件，然后在连接时指定 .def 文件目录。</p>
<h2 id="dllexport方式"><a href="#dllexport方式" class="headerlink" title="dllexport方式"></a>dllexport方式</h2><p>在定义 TESTFUNC 方法时，在声明前加上 <code>__declspec(dllexport)</code>。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>这里就不得不说导出符号在 DLL 中的形式。实际上对于 C++ 来说，当导出的时候，不会以原名导出，因为会加上一些符号字母后缀，实际上如果了解 C++ 的人，也会知道 C++ 在处理函数重载的时候，其实也用了这个套路，实际上编译之后就没有重载的概念了，而是根据参数生成了独一无二的方法名。</p>
<p>那说回来既然名字不同，那为什么其他模块调用还没问题呢。回答这个问题之前要先知道其他模块如何引用。</p>
<h3 id="调用导出函数的方式"><a href="#调用导出函数的方式" class="headerlink" title="调用导出函数的方式"></a>调用导出函数的方式</h3><p>一般有三种形式：</p>
<ul>
<li>.h 提供声明之后，直接调用，在连接的时候指定 .def 文件目录；</li>
<li>.h 提供声明之后，直接调用，链接的时候指定 .lib 文件地址</li>
<li>内部声明要调用函数的函数指针，loadlibrary 之后，直接取到函数地址，调用函数；</li>
</ul>
<p>了解了这三种方式之后，就可以回答上边的问题。</p>
<ul>
<li>对于1、2两种方式，由编译器自动转换函数名，寻找到正确的地址，链接之；</li>
<li>对于第3种方式，如果不把真正的函数方法名写对，就找不到函数了。</li>
</ul>
<p>所以其他模块调用没问题。</p>
<p>话说回来，那也不可能每次都把<code>@</code>那些符号写对。所以会看到有时候导出的时候<code>_extern &quot;C&quot; _declspec(dllexport)</code>这样写，这是为了让函数以 C 的方式来编译，这样导出的方法就是没有那些符号的了，但这样有个问题，就是函数必须以 C 方式调用，而且也不能用来导出类对象，原因是显而易见的……</p>
<p>其实当了解上边之后，不难发现，1、2才是我们最想要的，3就很局限。这样问题就来了，1、2两种方式又有什么区别呢：</p>
<p>区别就在这个 .lib 上，如果在 C++ 或者 C 工程这个范围来说，确实没区别。但是假如调用工程不是 C++ 工程呢，他就是个 C# 工程呢，他是没办法用 .lib 的。</p>
<p><strong>综上所述：.def 文件的方式才是最通用的做法</strong>。那回到我最初的问题，我的 C# 工程之所以在调用使用 <code>dllexport</code>导出的方法失败，就是因为，我没有写对真正的方法名(带一堆符号的那个)。而使用 .def 文件的话，就没有这个问题了。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>dll</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈 DLL 注入的几种方式</title>
    <url>/2020/08/01/dll-injection-ways/</url>
    <content><![CDATA[<p>云游戏的键鼠捕捉用到了 Hook 这个技术，就顺便翻了一下核心编程，写下来备忘。</p>
<span id="more"></span>

<h2 id="使用注册表注入"><a href="#使用注册表注入" class="headerlink" title="使用注册表注入"></a>使用注册表注入</h2><ul>
<li>x32 : <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows</code></li>
<li>x64 : <code>HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Windows</code></li>
</ul>
<p>这个位置下 <code>AppInit_DLLs</code> 和 <code>LoadAppInit_DLLs</code>。 将后者置为 1，然后在前者的值输入待注入 DLL 名称（多个 DLL 用 <code>Space</code> 分隔，第一个可以带路径，后边的不行）。</p>
<ul>
<li>优点：方法简单</li>
<li>缺点：只有引用了 User32.dll 的才会被注入，而且被注入进程一启动就会注入，结束才会反注入，注入周期不可控</li>
</ul>
<h2 id="使用-Windows-Hook-注入"><a href="#使用-Windows-Hook-注入" class="headerlink" title="使用 Windows Hook 注入"></a>使用 Windows Hook 注入</h2><p>核心方法：</p>
<ul>
<li><code>SetWindowsHookEx</code></li>
<li><code>UnhookWindowsHookEx</code></li>
</ul>
<p>设置挂钩的时候，可以指定挂钩类型、线程 ID 、回调方法、DLL 句柄。这些已经可以准确的注入到一个进程中了。通过 Set、Unhook 两个方法可以准确的控制注入周期。</p>
<ul>
<li>优点：准确的控制注入周期</li>
<li>缺点：依赖消息循环，没消息循环的线程没法注入</li>
</ul>
<h2 id="远程线程注入（大杀器）"><a href="#远程线程注入（大杀器）" class="headerlink" title="远程线程注入（大杀器）"></a>远程线程注入（大杀器）</h2><p>核心方法：</p>
<ul>
<li><code>CreateRemoteThread</code></li>
<li><code>VirtualAllocEx</code></li>
<li><code>VirtualFreeEx</code></li>
<li><code>ReadProcessMemory</code></li>
<li><code>WriteProcessMemory</code></li>
</ul>
<p>可以用 <code>CreateRemoteThread</code> 在指定进程中创建一个线程，让它执行我们自己的代码，这样可以让远程线程 Load 一个我们自己的 DLL，这就可以为所欲为了……需要注意的是，<code>CreateRemoteThread</code> 的参数 <code>PTHREAD_START_ROUTINE</code> 这个函数地址，需要调用 <code>GetProcAddress</code> 。如果直接传函数地址，是本进程的……显然是不对的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Kernel32&quot;</span>)), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>而函数参数也要使用 <code>VirtualAllocEx</code> 来分配内存，然后 <code>WriteProcessMemory</code> 写入。这才是远程进程可以获取的。</p>
<ul>
<li>优点：可以为所欲为</li>
<li>缺点：写起来有点复杂</li>
</ul>
<h2 id="同名-DLL-替换"><a href="#同名-DLL-替换" class="headerlink" title="同名 DLL 替换"></a>同名 DLL 替换</h2><p>如果已知一个程序必然载入一个 DLL ，则可以做一个同名 DLL 然后将方法跟原 DLL 保持一致，在方法调用中间做点其他手脚。这种如果程序校验 DLL ，就没戏。或者直接修改程序的 EXE 的导入段，这就要求对 PE 结构非常熟悉。</p>
<h2 id="作为调试器注入"><a href="#作为调试器注入" class="headerlink" title="作为调试器注入"></a>作为调试器注入</h2><p>核心编程没说的太细，看起来要写 CPU 代码，没太细看。感觉也挺复杂，不太实用。</p>
<h2 id="修改子进程的主线程开始位置代码"><a href="#修改子进程的主线程开始位置代码" class="headerlink" title="修改子进程的主线程开始位置代码"></a>修改子进程的主线程开始位置代码</h2><p>如果要注入的进程是子进程，可以创建它的时候挂起它，然后从 exe 模块中拿到子进程的主线程起始地址，把这里记下来，之后改成执行自己的代码，这个时候恢复子进程主线程，就可以执行自己的代码了，然后再把之前保存的执行一波。看起来也挺复杂，核心编程也没给具体例子。</p>
<h2 id="API-拦截"><a href="#API-拦截" class="headerlink" title="API 拦截"></a>API 拦截</h2><p>第一种：把要拦截的 API 起始位置的几个字节保存起来，然后将此位置改写为 CPU 的 JUMP 指令，跳转到自己的方法。不过这种方法非常危险，不建议用。</p>
<p>第二种：修改模块导入段拦截 API</p>
<p>核心方法：</p>
<ul>
<li><code>ImageDirectoryEntryToData</code></li>
<li><code>WriteProcessMemory</code></li>
<li><code>VirtualProtect</code></li>
</ul>
<p>获取到模块的导入段信息，之后查找到指定方法，用自己的方法替换原来的方法。如果 <code>WriteProcessMemory</code> 失败，就用 <code>VirtualProtect</code> 修改一下页面保护属性。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>dll</tag>
      </tags>
  </entry>
  <entry>
    <title>一只狗</title>
    <url>/2015/12/01/dog-say/</url>
    <content><![CDATA[<p>一只狗是我微信的名字，这个名字确实蛮滑稽的。但确是我用过这么多的昵称名字里边最喜欢的，可以说除了QQ昵称之外最喜欢的。</p>
<p>经常有人问我，为什么会叫一只狗呢。我说：因为狗是人类最好的朋友啊……</p>
<span id="more"></span>

<p>在世上活了二十几载，却发现，单纯的朋友关系有多么的珍贵，保有一份朋友间的单纯有多么的难。如果重新选择，或许我更愿作他人身边的一只狗，这样在朋友高兴的时候，离开我我也不会觉得难过；朋友难过的时候找我倾诉，我依旧很高兴。</p>
<p>人就是这么复杂，七情六欲，高兴、生气、猜疑、嫉妒……或许狗就没有，到了狗那里就是摇尾巴啦~~</p>
<p>如果选择做一只狗，或许就不会因为其他的利益纠葛衍生出背叛，决裂。因为狗忠诚。这样看或许人不如狗……</p>
<p>我确实喜欢狗，但是和其他人的喜欢还是不同的。我不喜欢把动物放在对立面。我喜欢狗，是因为狗忠诚、单纯、阳光；我不喜欢猫，是因为猫高冷、忧郁、复杂……</p>
<p><em>那个人好奇怪，他好像一只狗……</em></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>开发工具备忘</title>
    <url>/2018/08/12/develop-tool-archive/</url>
    <content><![CDATA[<p>工作时候用到的工具繁多，进行一波归档备忘，方便以后使用。</p>
<span id="more"></span>

<h1 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h1><ul>
<li><a href="http://www.voidtools.com/">Everything</a> 搜索文件利器</li>
<li><a href="http://www.listary.com/">Listary</a> 文件管理器与程序打开窗口联动</li>
<li><a href="http://cmder.net/">Cmder</a> Windows 下最好用的命令行</li>
<li><a href="https://notepad-plus-plus.org/">Notepad++</a> 文本文件编辑利器(x86版本插件比较多)</li>
<li><a href="http://www.funduc.com/search_replace.htm">Search and Replace</a> 文件内容查找利器，查找速度秒杀一切 </li>
<li><a href="https://github.com/ehnap/gal">Gal</a> 我自己写的快速启动工具</li>
<li><a href="http://www.ghisler.com/">Total Commander</a> 处理文件比文件管理器好用</li>
<li><a href="https://www.scootersoftware.com/download.php">Beyond Compare</a> 目录、文件内容对比工具，比 <em>git diff</em> 更专业</li>
<li><a href="https://windirstat.net/download.html">WinDirStat</a> 文件夹大小扫描工具，速度飞快</li>
</ul>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><ul>
<li><a href="https://www.ieinspector.com/">HTTPAnalyzer</a> Windows下简单好用的抓包工具</li>
<li><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">Process Explorer</a> 进程观察利器</li>
<li><a href="https://github.com/processhacker/processhacker">Process Hacker</a> 比 PE 更好用的东东</li>
<li><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon">Process Monitor</a> 进程监视利器</li>
<li><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/">SysinternalsSuite</a> 微软出品的系统工具合集</li>
<li><a href="http://www.torchsoft.com/en/rw_information.html">Registry Workshop</a> 加强版注册表，历史记录跳转功能超级好用</li>
<li><a href="https://www.apimonitor.com/">API Monitor</a> 软件调用 Win32 API 捕捉利器</li>
<li><a href="https://oldj.github.io/SwitchHosts/">SwitchHosts</a> Host 管理、切换工具</li>
<li><a href="https://git-scm.com/">Git</a> 源代码管理工具</li>
<li><a href="https://www.sourcetreeapp.com/">SourceTree</a> Git 的可视化客户端，观察文件变化比较方便</li>
<li><a href="http://www.tortoisegit.org/">TortoiseGit</a> Git 的另一个可视化客户端，合分支比较方便</li>
<li><a href="http://www.hostbuf.com/">FinalShell</a> SSH 工具，非常不错</li>
<li><a href="https://www.tightvnc.com/">TightVNC</a> 免费的 VNC 软件</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 .NET 与 Qt Timer 实现</title>
    <url>/2020/08/07/dotnet-qt-timer/</url>
    <content><![CDATA[<p>前两天刚好跟同学提起如何实现一个 Timer 。提到了 Kafka 的时间轮和 Go 语言的四叉堆实现。所以就看了下 .NET 是如何实现 Timer 的。</p>
<span id="more"></span>

<p>.NET Timer 分为两种，一种是 <code>System.Windows.Threading.DispatcherTimer</code> , 另外一种是<code>System.Timers.Timer</code> 。</p>
<h2 id="System-Windows-Threading-DispatcherTimer"><a href="#System-Windows-Threading-DispatcherTimer" class="headerlink" title="System.Windows.Threading.DispatcherTimer"></a>System.Windows.Threading.DispatcherTimer</h2><p>.NET Framework 相关源码路径：</p>
<ul>
<li>System\Windows\Threading\DispatcherTimer.cs</li>
<li>System\Windows\Threading\Dispatcher.cs</li>
<li>System\Windows\Threading\DispatcherOperation.cs</li>
</ul>
<p>简要实现原理：在每次新增 DispatcherTimer 的时候，都会将回调的委托存入 Dispatcher 中的 DispatcherOperation 优先队列里，但是优先级是最差的。然后将 Timer 本身存入当前 Dispatcher 的 Timer List 中。还有一个值得关注的是，时间间隔会加上系统运行时间 <code>Environment.TickCount</code> ，变成绝对时间保存下来，这是为了后边 <code>WM_TIMER</code> 到达之后，对比是否超时做准备。接下来就要关注 Dispatcher 了，当 Dispatcher 新增、删除、响应 Timer 事件以及 DispatcherTimer 调整时间间隔的时候，会调用 <code>UpdateWin32Timer()</code> , 这个方法会在当前 Dispatcher 的 Timer List 中检索最近要触发的 DispatcherTimer，如果当前没有调用过 <code>SetTimer()</code> 或者调用过的 <code>SetTimer</code> 时间间隔比当前最近要触发的长，就取时间间隔，调用 <code>SetTimer()</code>。当收到 <code>WM_TIMER</code> 消息之后，将根据程序运行时间，对比时间间隔，选出已经超时的 Timer，将之前提到的 DispatcherOperation 优先级提升，等到下一个消息循环来到时，回调 Operation 将会被从优先对列取出，并执行。</p>
<h2 id="System-Timers-Timer"><a href="#System-Timers-Timer" class="headerlink" title="System.Timers.Timer"></a>System.Timers.Timer</h2><p>.NET Framework 相关源码路径：</p>
<ul>
<li>services\timers\system\timers\Timer.cs</li>
<li>system\threading\timer.cs</li>
<li>coreclr\src\vm\comthreadpool.cpp</li>
</ul>
<p>简要实现原理：<code>System.Timers.Timer</code> 只是对 <code>System.Threading.Timer</code> 包装，所以实现上看 <code>System.Threading.Timer</code> 就好。这就不得不提到 <code>System.Threading.Timer</code> 中的 <code>TimerQueue</code> 。 这是存有 <code>TimerQueueTimer</code> 的双向队列。每增加一个 Timer 的时候，都会将一个 <code>TimerQueueTimer</code> 放入 <code>TimerQueue</code> 队列。同时调用运行时的 Native 的代码 <code>AppDomainTimerNative::CreateAppDomainTimer()</code> 。后边就是 Native 的代码逻辑了，具体细节不表了，简单理解就是在线程池中搞一个线程，在线程中调用 <code>SleepEx()</code> 阻塞线程，当线程走完之后触发回调，再调回 .NET 托管代码，找到 <code>TimerQueueTimer</code> ，再执行用户回调。</p>
<h2 id="QTimer"><a href="#QTimer" class="headerlink" title="QTimer"></a>QTimer</h2><p>相关源码路径：</p>
<ul>
<li>qtbase\src\corelib\kernel\qeventdispatcher_win.cpp</li>
<li>qtbase\src\corelib\kernel\qtimer.cpp</li>
<li>qtbase\src\corelib\kernel\qobject.cpp</li>
</ul>
<p><code>QTimer</code> 的实现就比较简单了，当增加一个 <code>QTimer</code> 的时候，会在 <code>QEventDispatcher</code> 中调用 Win32 API，同时在 <code>QObject</code> 中将 TimerId 保存到 Vector 中。唯一的细节是，时间间隔在 20ms 以下或者指定 QTimerType 为 Qt::PreciseTimer 的 <code>QTimer</code> 会在底层调用 <code>timeSetEvent()</code> （源码注释中也提到了，虽然方法废弃了，但是精度还是高依旧使用），而其他的就调用 <code>SetTimer()</code> 方法。</p>
<h2 id="谈谈-SetTimer"><a href="#谈谈-SetTimer" class="headerlink" title="谈谈 SetTimer"></a>谈谈 SetTimer</h2><p><code>SetTimer()</code> 的调用是有限制的。不管别人信不信，反正我是信了。这一点在 MSDN 中 SetTimer 的描述并没有，不过通过一些现象，以及网上的一些其他帖子可以得到认证。据 SO 上的一位吃瓜网友表示，<code>SetTimer()</code> 会创建<strong>用户对象</strong>（虽然这一点微软也没说过），而用户对象在系统中是有限制的（这一点是微软明确说过的），而用户对象的数量上限是在注册表中的，根据微软的文档指示应该是在： <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\USERProcessHandleQuota</code> 我看了一下 x64 系统应该是在 <code>HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Windows\USERProcessHandleQuota</code> 。默认数量是 10000 。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>分析过以上几种 Timer 的实现，就知道 .NET 的 Timer 还是做了一些微小的优化的。这也是为什么我跟同事说， 即使都是拿来做 Windows 桌面开发，.NET 框架的上限还是要比 Qt 高的原因。这大概是因为 .NET 本身从一开始就不是以桌面开发作为目标的，所以它更要考虑性能问题，但正因为如此，源码看起来比 Qt 就更为困难；而 Qt 这么实现，对一般的桌面应用来说，完全够用，代码也更容易看懂。虽然两者的实现在极端情况下都会拉闸，但是显然 Qt 的 Timer 实现会更快拉闸……</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>C#</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈双十一书单以及图书优惠</title>
    <url>/2021/11/07/double-eleven-buy-books/</url>
    <content><![CDATA[<p>公众号未更新应该有近四个月之久了。最近也是事情有点多，八月份也算是处理了一件人生中算得上是里程碑的大事吧，所以就一直都没有比较整块的时间读书。呃，当然也可以说是懒，而且懒应该是一贯的，只是为自己的懒找到了更为心安理得的借口罢了。然后在加上最近看书看的比较慢，又同时开了几本，都没看完。所以就一点内容都没有了……而且感觉今年的读书 KPI 堪忧。</p>
<p>不过恰逢双十一，像我一贯是买书如山倒，读书如抽丝，双十一又成了我一个很好的买书的借口，看不看的就另说了。恰好狗东的优惠力度也不小，就在待买书单里边挑了一些来囤。这样内容终于就有了，借着晒书单的机会，倒是也可以谈谈我是怎么来看图书优惠力度，以及通过哪些渠道获取书籍推荐，这或许也是一个不错的内容。</p>
<span id="more"></span>

<h2 id="关于图书优惠"><a href="#关于图书优惠" class="headerlink" title="关于图书优惠"></a>关于图书优惠</h2><p>其实每年有茫茫多的图书优惠，但实际上电商的逻辑我们早已烂熟于心，三天两头这个节那个节，提价再降价的套路已经不够新鲜了，所以对于很多人不怎么买书的，其实根本就分辨不了图书的优惠到底是不是真的优惠了。就像不总买菜的年轻人，是永远不知道菜卖的贵还是便宜的，因为没有一个日常的基线做比对。</p>
<p>这里我先说日常买书，我指的日常就是啥活动没有的平常时间，我通常都是不买……(手动狗头)，但是如果必须要买，那就</p>
<ul>
<li>dangdang 的淘宝店</li>
<li>文轩网淘宝店</li>
</ul>
<p>我会优先选择 dangdang 的淘宝店。为什么会这样，是因为我发现一个非常诡异的地方，不知道是不是跟它的运营模式有关，它的淘宝店卖的竟然比它的平台便宜，这就有点疯起来连自己都杀的意思了，我就很喜欢；再其次就是文轩的淘宝店了，其实就是新华书店网店，书籍比较全吧，而且全国都有仓库，配送也比较快。</p>
<p>那对于活动来说，一个书籍活动优惠力度大不大要从两方面来看：</p>
<ul>
<li>书籍覆盖面是否够广</li>
<li>是否真的便宜</li>
</ul>
<p>根据这两方面去评价，基本上不会有太大偏差。但是还是那个问题，对于不怎么买书的人，没有一个比较基准，就没法评判这两种。这里可以套用其他品类的多平台比较大法。我买书的时候一般都会现在有活动的平台选好我自己要买的书，看一下最终要付多少钱，之后在另外一个平台选出同样的书，看下最终要付多少钱。这招基本上可以通杀所有活动。因为书籍这块商家现在还没那么奸，我怀疑可能是纸质书买的人实在有限，导致商家不像其它品类有那么多热情设计一堆特别复杂的规则来掩盖要赚钱的事实，说白了就是懒得装了。</p>
<p>关于活动，我还要多说两句，永远怀念我上大学在亚马逊买书那个时代。把所有卖书的平台放在一起，只有亚马逊的活动是永远没有花里胡哨，满减就是白送钱，狗东和当当加入进来之后，满减开始变成提价再减，只不过活动的时候提价再减也是比平价优惠的。但是人多点纯粹不好吗，好好的图书市场让精于算计的运营搅和的乌烟瘴气，一个个以为眼花缭乱的活动就算是自己的胜利，但殊不知是用一己之力来一点一点改变这个世界的纯粹，让人变得不再信任，典型的劣币驱逐良币罢了。这块就不再拓展了，拓展开又可以开一篇了。</p>
<p>今年比较值得买书的活动应该就没有了。</p>
<ul>
<li>618</li>
<li>文轩9月</li>
<li>狗东双十一</li>
</ul>
<p>这三个是力度比较大的。文轩9月我没赶上，因为是在小程序，我也是在豆瓣看到的，等我知道就来不及了，力度应该是这三个里边最大的。刚过去的狗东双十一，如果有抢到『满 400 - 60 』的券再叠加『每满 100 减 50 』可以做到满 400 - 260，力度也是很大的，多平台大法比对了一下，我买书的总价要比某宝便宜一百多。</p>
<h2 id="关于双十一所购书籍的书单"><a href="#关于双十一所购书籍的书单" class="headerlink" title="关于双十一所购书籍的书单"></a>关于双十一所购书籍的书单</h2><h3 id="《平如美棠：我俩的故事》"><a href="#《平如美棠：我俩的故事》" class="headerlink" title="《平如美棠：我俩的故事》"></a>《平如美棠：我俩的故事》</h3><p>这本书我应该是听过不止一个人跟我推荐，一个是 B 站的 UP 主小圆脸；还有一个是 B 站的关于书籍的纪录片。说是当时听说了这个故事之后，编辑第一时间跑去问出书的事情，出版社为了能拿到这本书的出版权，也是大费了一番周章，当时听了就觉得这一定是一本非常值得看的书，所以进了我的待买书单。</p>
<h3 id="《纳兰词-全词插图注释版-》"><a href="#《纳兰词-全词插图注释版-》" class="headerlink" title="《纳兰词(全词插图注释版)》"></a>《纳兰词(全词插图注释版)》</h3><p>因为在 B 站看个综艺《我的音乐你听吗》，有首歌叫 《若》，讲纳兰容若和妻子的故事觉得挺好，想看看纳兰词，所以就买了这本。说来我是比较喜欢果麦文化出的书的，虽然果麦文化因为用轻型纸，所以被许多看书的人唾弃。我对纸的要求倒是没那么高，所以自己是买了不少果麦文化的书，其中《红楼梦》感觉编的也还挺好的。</p>
<h3 id="《杜撰集》"><a href="#《杜撰集》" class="headerlink" title="《杜撰集》"></a>《杜撰集》</h3><p>博尔赫斯的书，我之前买了一本《小径分岔的花园》，还没看。但是之前是看梁文道的《一千零一夜》介绍了他的书，感觉也是相当值得一看的。另外就是上海译文出版社的书，基本可以无脑买，没有太差的。</p>
<h3 id="《何为良好生活》"><a href="#《何为良好生活》" class="headerlink" title="《何为良好生活》"></a>《何为良好生活》</h3><p>我忘了这本书是怎么加入我的待买书单的了，因为那个时候我的待买书单刚刚建立，所以很多维度还没有，没法追溯因为什么加入书单了。只有一点印象，说陈嘉映哲学这块研究很深，所以感觉他出的书比较值得一看。</p>
<h3 id="《看不见的城市》"><a href="#《看不见的城市》" class="headerlink" title="《看不见的城市》"></a>《看不见的城市》</h3><p>卡尔维诺的书，也是看梁文道的《一千零一夜》种草的。当时就觉得一定要买的。</p>
<h3 id="《占有还是存在》"><a href="#《占有还是存在》" class="headerlink" title="《占有还是存在》"></a>《占有还是存在》</h3><p>B 站 UP 主智能路障推荐，他应该是因为讲鲁迅火的，其实他的视频我没怎么看，但是有一期关于读书日的视频，因为和读书相关刷到了，我就看了其中推荐了这一本，听介绍也是比较吸引人的，就落入了待买书单</p>
<h3 id="《大众的反叛》"><a href="#《大众的反叛》" class="headerlink" title="《大众的反叛》"></a>《大众的反叛》</h3><p>同上。智能路障的视频是比较偏理性的，所以感觉推荐的这类书籍应该是比较值得一看的。这本书我印象中他是跟《乌合之众》，对比的说的，就是说《乌合之众》好像很火，但是实际上这本书要比《乌合之众》强很多。</p>
<h3 id="《如何成为不完美主义者》"><a href="#《如何成为不完美主义者》" class="headerlink" title="《如何成为不完美主义者》"></a>《如何成为不完美主义者》</h3><p>书名倒是一股浓重的鸡汤味儿，这本书是 B 站 UP 主 CaaaaaR 推荐，这个 UP 主我还是很喜欢的，然后加上我本人有点偏蓝色性格，经常饱受这种困扰，所以就觉得这本书值得一看。说起来后浪好像特别愿意出这类书籍，我还有一本后浪出的书《沟通的艺术》，不过据说都是名字听着鸡汤，但是很受用。</p>
<h3 id="《那些古怪又让人忧心的问题》"><a href="#《那些古怪又让人忧心的问题》" class="headerlink" title="《那些古怪又让人忧心的问题》"></a>《那些古怪又让人忧心的问题》</h3><p>也是 B 站 UP 主 CaaaaaR 推荐，据说作者兰道尔·门罗非常擅长科普，所以书的内容非常有趣。所以也进了我的待买书单。未读出的书我也有几本，像《存在主义咖啡馆》、《睡眠革命》，我感觉都还比较不错。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>就买了这些书籍，还不知道什么时候能开始读，已经买了很多书，都还没拆封，就在书架放着。不过我倒是挺喜欢史航说的那句话：这些书跟自己都有着或多或少的缘分，有的是一个封皮的缘分，有的是几页的缘分，有的是半本的缘分，也有的是翻来覆去看的缘分，顺其自然就好。</p>
<p>总有一天它们应该都能跟我有完整的一本的缘分。</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Qt</title>
    <url>/2018/10/09/effective-qt-ing/</url>
    <content><![CDATA[<p>标题是非常的哗众取宠了。这里主要是用来记录一些使用 Qt 的小经验。之前在工作中，会有一些关于 Qt 的经验总结，加之平时自己写一些小东西也有使用 Qt ，所以使用起来会有一些经验教训，聚集起来，姑且叫做 Effective Qt 了。随时想到会随时更新内容。（<strong>注：这里会有一些代码设计的思路，不存在绝对的正误，只是一种习惯</strong>）</p>
<span id="more"></span>

<ol>
<li>避免在子控件中使用 <code>parentWidget()</code> 方法获取 <code>QWidget</code> 指针强制转换为父控件指针，调用父对象方法。<blockquote>
<p>在对子控件布局的时候，某些情况下实例化子控件时传递的父指针会被置空，例如对子控件设置一些特殊的窗口标志。</p>
</blockquote>
</li>
<li>在 <code>void paintEvent(QPaintEvent* e)</code> 方法中的逻辑要避免出现间接调用 <code>update()</code> 方法。<blockquote>
<p>由于 <code>update()</code> 方法与 <code>repaint()</code> 机制不同，所以当出现上述情况，并不会直接爆栈，迅速发现问题。而是在某些会导致频繁重绘的操作下，程序异常卡顿，但是不涉及重绘的操作，程序又看起来没问题。</p>
</blockquote>
</li>
<li>避免匿名空间内声明 Qt 类型、避免类外声明<code>static</code> Qt 类型。<blockquote>
<p>避免 Qt 类型的某些内容比 <code>QCoreApplication</code> 更早的初始化，导致一些数值异常。比如在更早的时机调用 <code>QStyle::dpiscaled()</code>，导致无法得到正确的系统DPI。</p>
</blockquote>
</li>
<li>获取 <code>connect()</code> 方法的返回值，可以在 debug 时快速的发现自己的槽和信号没有正确的连接。</li>
<li>如果槽失效了，99% 是以下几种情况，剩下 1% 我没遇到过<blockquote>
<ol>
<li>类没有继承自 QObject</li>
<li>没有写 Q_OBJECT 宏</li>
<li>槽(信号)的定义没有写在 slots(signals) 下边</li>
<li>connect 的时候写错了槽(信号)的名字或者参数</li>
</ol>
</blockquote>
</li>
<li><code>adjustSize()</code>、<code>updateGeometry()</code>以及<code>sizeHint()</code>是处理复杂界面布局变动的利器。<blockquote>
<p>简单来说 <code>adjustSize()</code> 是根据子控件调整自己的大小，<code>updateGeometry()</code> 是根据自己的大小和子控件的大小调整子控件的布局。在处理复杂布局时，还需要配合每一个控件本身的 <code>sizePolicy()</code> 以及布局的 <code>sizeConstraint()</code> 方可显示出Qt动态布局的威力</p>
</blockquote>
</li>
<li><code>updateGeometry()</code> 并不是每次调用都一定会生效，有时候你需要 <code>QLayout::invalidate()</code> 来辅助你更新布局。<blockquote>
<p>Qt只会在它觉得需要重新更新的时候才更新(具体的判断可以参考源码，大意是说调过了 <code>setXXXSize()</code> 这种方法以后，Qt才认为需要重新更新)。这个时候你可以选择拿到控件的 <code>QLayout</code> 然后循环对每个布局调用 <code>QLayout::invalidate()</code> ；在<strong>比较特殊</strong>的情况下你可以选择用 <code>setFixedSize(sizeHint())</code> 这种奇怪的调用代替循环，当然请在你非常熟悉你在做什么的时候才去用这种方式代替循环。</p>
</blockquote>
</li>
<li>在发现有一个需求需要用到 Qt 的某些东西而又调不到时，请再三确认， Qt 有没有提供一些虚方法可以重写，大部分的需求都是可以通过某些虚方法完成，只有极少数需要将 Qt 内部的东西移出来用。</li>
<li>尽量使用 <code>QLayout</code> 来控制控件的位置，而不是套用一个又一个的 <code>QWidget</code> ，因为永远不能预料到产品会把一个页面上的哪两个控件联系在一起，如果这些控件相隔了几个 <code>QWidget</code> ，拿到它们的指针将是一件非常蛋疼的事</li>
<li>槽的命名应该以反映他被调用的时机，而不是他的功能。方便后边的人想在某个信号发送的时候，快速的找到一个准确的槽位置，而不会同一个信号在同一个类里绑定了多个槽</li>
</ol>
<p><strong>未完待续……</strong></p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>我与复音口琴</title>
    <url>/2014/12/19/harmonica-with-me/</url>
    <content><![CDATA[<p>自从尺神经卡压之后就再也没弹过吉他。但是我这个人又是闲不住的人。我爸年轻的时候是吹口琴，家里有几只口琴，复音，布鲁斯，半音阶倒是都有。有幸都吹过吧。于是就决定把口琴捡起来。我自己有个习惯，在入坑之前都要提前踩踩点，在逛复音口琴吧的时候偶然听到了盛叔的《龙的传人变奏曲》，当时觉得特别神奇，为什么一只口琴可以吹出这种感觉，再加上对三种口琴价格的比较，最终还是决定选择复音口琴。如今已是大四，两年过去了，复音口琴的技巧学的七七八八了。更准确的说《龙的传人变奏曲》需要的技巧已经学的差不多了，最近又入了一只ANm的复音口琴，就是专门为了练习这首曲子。</p>
<span id="more"></span>

<p>回头想想自己吹口琴的日子，其实也并不好过。而且当时觉得这首曲子似乎就是遥不可及。幸好开始的时候拿到了《口琴考级曲集》这本书，当时只知道，这本书学的差不多就应该能吹了。目的很单纯，学技巧。我也特别喜欢对技巧的掌握。</p>
<p>开始学习复音口琴，我是直接学习新式单音的，因为旧式单音初中我就可以吹了，只是捡了捡，便投入了新式单音的学习当中。口水流的不行，但是我知道这首曲子的基础就是这个东西，不会我肯定吹不了，而且我心里是有一个感觉的，就和我当初玩吉他弹唱一样，如果一直吹旧式单音，到最后就是找歌曲简谱，每天吹一吹，这种开始还好，后来就会非常无聊。所以自己开始时也很卖力的学习复音口琴。在这种驱动下，新式单音吹了两个礼拜便学会了，当时一个最大的体会就是前一个礼拜或者是一个多礼拜可能每天吹都是吹不干净，口水流的到处都是，但是很可能就在某一天自己突然吹准了一个音，就入门了，后面吹音阶就都“口到琴来”了。但我自己很清楚，没有自己前面一个多礼拜的碌碌无为，也不可能在某一天入门，所以在乐器上至少我相信量变是可以到质变的。</p>
<p>新式单音学会之后，下一个坎马上就来了，就是前后伴奏了。前后伴奏，刚开始的时候舌头很不灵活，在参考了很多资料以后，自己摸索出来一套练习方法，也就入了门，吹过一年多之后，发现这个方法和傅豪久老师的提倡的练习方法也是不谋而合，自己也是心里暗喜。前后伴奏大概吹了三四个礼拜，将近一个月的样子。每天都是打开《口琴考级曲集》从头开始，一首首的吹，然后再把自己正在练习的曲目着重吹一下，再和复音口琴吧拿到的一些录音对比一下，看看是不是吹的不正确。就这样前后伴奏拿下了。在拿下了前后伴奏，我庆幸自己在逛贴吧的时候看到了大家的心得：不要乱加伴奏，要时刻注意按照曲子编排的伴奏来吹，不然就会走向歪路。这也一直在警醒着我自己，到现在来看，是非常有用的，按照曲子编排的伴奏可以练习你对舌头的控制能力，以至于现在对大多数节奏的伴奏自己也是烂熟于心。</p>
<p>当时学习了前后伴奏以后还是很兴奋的，但是其实大家听来听去，我每天也就是吹那些老掉牙歌曲或者是一些儿歌，当然这些都是考级曲集里的，当时自己的想法是要让自己更加熟练，每天都要吹一吹。这种状态持续了一段时间，基本没学新的技巧，一直是在巩固。</p>
<p>之后自己开始考级曲集四级的内容，但是仔细回忆一下四、五级的内容我基本上并没有严格按照考级上的顺序来，而是自己先看看哪些技巧好学或是自己比较喜欢，就优先尝试一下，而且当时的自己觉得四、五级的内容其实很简单，类似手震音、琶音、波音一两句话实际上就说的很明白了，尝试一下还有点味道，所以当时的自己觉得很快就学会了。于是开始每天重复吹一到五级的曲子，但在当时实际上自己已经陷入了大坑，但并没有意识到。偶尔也会吹一下其他级别的曲子，但技巧先不加。这种状态持续了一段时间之后，那个时候就刚好找实习了，找到以后去实习，大概三四个月就没吹琴了。</p>
<p>三四个月过后，刚拿起琴的时候伴奏都有点打不利索，不过练一练马上就缓过来了。这个时候开始真正的用心琢磨我自己的技术水准，在反复比较标准的录音，还是自己找到了坑。四、五级的技巧是很简单，但是真正的难点是可以很从容的使用在曲子里，并且效果到位。重新审视自己之后尤其明显的发现自己的手震音效果很差，于是开始在贴吧开贴问，在Q群问。然后重新练习。就这样还是比较短的时间就把自己的一些毛病都纠正过来了。这个时候自己才算是准五级水平，因为后来发现自己的爵士卡尔实际上之前打的并不好。</p>
<p>在学习五级左右的时候就开始发现一些问题，吹到五级之后网上很多曲子找不到标准录音，自己也就没了参照，一些比较熟悉的歌曲，自己还能知道吹的是不是这个意思，不熟悉的就很麻烦了。</p>
<p>这个阶段就是一般看六级往上的技巧，自己摸索一下，然后看看是不是有大神吹的曲子带有这个技巧。基本上后面学的技巧都肯定是和一个视频有关。就像小鼓奏法，我在网上看到了王仁计老师的巡逻兵，第一次明白了考级曲集中说的舌头打滚是什么意思，真是书上说的就是不如视频形象，当时感动的要哭，很快这个技巧就学会了。再比如曼陀铃奏法，之前也是一直不知道是什么效果，当时是看了一个口琴比赛，一位盲人演奏家吹奏的《火车向着韶山跑》，当时也是看了震撼的不行，他的技术基本也是上乘。还有很多视频，很有启发，想起来我再整理整理。这个时候恰好自己一次逛贴吧，偶然得知了，傅豪久老师的教材，便果断买了，又加上配套视频，第一次知道除了考级上面的内容，还有其他技巧，真是开阔了眼界。</p>
<p>回学校一直到现在，我觉得自己的收获要比前半段收获大了不少，而且也深刻认识到学习乐器，如果能有一个老师指导，那肯定是要比自学好太多了。这里边除了自己真正开始琢磨复音口琴之外，也是太多偶然，看到了太多对我有启发的视频，如王敬民老师的相关演出和讲座。而且不知不觉我发现自己在学习新的技巧比较快了，一个是舌头的灵活程度和控制性上比刚开始好太多，在一个可能就是琴感吧，这两种东西帮我太大忙。</p>
<p>从公司回来，也是偶然拿到了《龙的传人变奏曲》的谱子。这个值得一说的是，在我刚开始吹口琴就想求这个谱子，但是贴吧的阳光老师说，这谱子难度大，一般人拿到也是吹不了，除非是十级左右的水平可以练习一下，而且可能不确定这个谱子是不是可以公开。所以当时一心练习技巧，以便有机会求谱子。结果这次偶然就拿到了。在分解和音会吹了之后，自己最近便开始研究这个谱子。我给自己三个月的时间，争取把它能吹的比较好一点。</p>
<p>最近便是在练习双琴和龙的传人，因为高音伴奏刚学会，也兼顾着复习高音伴奏。但是每次都要用四把琴练习，也导致酒精特别费，O(∩_∩)O哈哈~</p>
<p>洋洋洒洒写了很多，是总结，也是对我自己的警醒。回头看这些，感触太深，收获太多。自己终于有一个东西可以说比较了解。但是自己最近也比较动摇，之前其实是想着这首曲子吹会了便入布鲁斯的坑，现在可能又有了新的选择。不经意间逛了一下指弹吧，又想起了吉他，但是最主要的是一个东西触动我，那就是和弦。</p>
<p>自己最近在和弦上也是看了几篇视频和文章。主要是杨敬民老师在清华大学的讲座，他首要讲的就是和声合理化，在演奏西方古典音乐或是交响乐时，复音口琴采用多把琴移调完成和声合理化，当时听了觉得特别机智，真的好神奇。就在前两天刚好看了布鲁斯口琴的关于和声问题的一个帖子，感触很深。也让我彻底明白自己为什么一直都这么喜欢吉他，或者键盘类乐器。</p>
<p>最关键就在于口琴的一个点，因为他的构造所以导致和弦单一，即使是复音口琴有了分解和弦，但不得不承认自己的舌头再溜，也不可能分瓣，所以也只能在三五八度和弦上变化，这在乍听的人上会觉得很惊讶，就像我当初听到《龙的传人》，我的第一反应是很神奇，为什么一只口琴靠吹吸可以同时变化几个音。但是如果我们一直玩下去，我们自己就会觉得单调，甚至觉得不好听。而键盘类乐器和吉他这种弹奏乐器则截然不同。所以我们在长时间听这些曲子就不会觉得疲劳，真正觉得是好听。</p>
<p>话说回来，因为以上的原因自己很动摇，所以很可能在练习完《龙的传人》，就在大学毕业之后转而学习别的乐器了。不过在学别的之前，还是要认认真真学会这首我最想吹的曲子，并且把我自己练习各个技巧的心得体会整理出来，一是做个记录，二是如果将来有人可以用的上，那就是最好了。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>harmonica</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频大行其道的今天，关于读书还能说点什么？</title>
    <url>/2020/03/18/harpertalk-av-book/</url>
    <content><![CDATA[<p>在互联网这个范围内，人工智能、大数据、云、音视频或短视频(下边都将用视频代替)，都将是未来的或者说已经是开始起风的风口了。大批量的视频平台如雨后春笋般涌现，抖音、快手、B站这种以视频为主的平台用户量快速飙升，直逼传统的社交应用。在这种背景下，关于读书，我一直思考还能说点什么。</p>
<span id="more"></span>
<p>说到读书，读是动作，书是客体。由此而衍生出的就是，怎么读，读什么书的问题。而这篇文章不是阐述读书方法的工具文，也不是介绍书单的读书笔记。这两个问题，我想归结到一点：将读书分为，读纸质书、读电子书(包含网文)，这两种。我将读书，看作是一个信息传播的行为，这种行为会导致信息在群体中传递。显然视频也具有同样的性质。而本文只局限于对看视频和读书的这一种性质进行一些粗略分析。</p>
<p>就信息传递而言，视频所擅长的是将抽象的信息具象化，更容易被理解，而书籍则擅长将繁多的信息抽象化、精炼化，不容易被理解。通俗一点说，在大多数情况下，表示相同的信息时，因为更抽象，所以书籍所用的篇幅会小一点，但不容易被理解；而视频所用的篇幅会大一点，但更容易被理解。这里我并不会讨论二者的信息承载量的问题，因为一不小心就会陷入到“哪种效率更高”这样没有意义的争论之中。</p>
<p>而基于上述的比较，在信息传递成本大幅下降的今天，似乎很容易得到的结论是，视频将是信息传递的不二选择。因为信息传递成本低，而且又易于人们理解，看起来书籍好像并没有什么太大优势。我也曾经对此深信不疑。但在我大量的刷一些视频平台之后，兜兜转转，我又回头来重新思考书籍的必要性。或者说，我将这个问题细化成了更加小的子问题。</p>
<h3 id="相比书籍为什么视频更流行？"><a href="#相比书籍为什么视频更流行？" class="headerlink" title="相比书籍为什么视频更流行？"></a>相比书籍为什么视频更流行？</h3><h4 id="为什么我们更能接受视频？"><a href="#为什么我们更能接受视频？" class="headerlink" title="为什么我们更能接受视频？"></a>为什么我们更能接受视频？</h4><p>视频获取信息不需要在大脑中转化。我认识这个世界，都将通过所见、所闻。而通过视频来传递信息，跟我认识这个世界的方式是一样的。大部分的时候，当我看一段视频，我不怎么加以思索，便可以感知视频所要传递的主要内容(注意是内容不是内涵)。而书籍则不同，需要大脑对文字进行转化。因为我不能对文字本身有任何感知，我只能通过文字对应到我之前的所见、所闻，然后转化为我所能知道的信息，这就要进行一次转化。而这次转化也就是二者具象与抽象的区分。诚然这种区分不是决定流行程度的本质原因，最根本原因还是在于人是有惰性的，越是在舒适圈的东西越容易被接受，这才是视频更加流行的原因。</p>
<h4 id="泛娱乐化"><a href="#泛娱乐化" class="headerlink" title="泛娱乐化"></a>泛娱乐化</h4><p>在网上可以查到一些对泛娱乐化的解释。所谓“泛娱乐化”现象，指的是一股以消费主义、享乐主义为核心，以现代媒介(电视，戏剧，网络，电影等)为主要载体，以内容浅薄空洞甚至不惜以粗鄙搞怪、戏谑的方式，通过戏剧化的滥情表演，试图放松人们的紧张神经，从而达到快感的一种文化现象。</p>
<p>在生活节奏非常紧张的时候，人们更容易接受娱乐化的作品。那这和我要阐述的大问题有什么关系呢？</p>
<p>相比书籍，视频更容易被市场当作“泛娱乐化”工具。这主要可以通过以下几个方面进行论证。视频存在传播信息更具象的性质；视频的制作与发行成本要比书籍更低，这里我想表述的并不是AE和文本编辑器哪个更容易学的问题，而是视频制作之后，可以通过主流网络平台很轻松的传播给大众观看。也有人会觉得写文字也会更容易，不过我在这里讨论的是书籍而非单纯的文章，所以公众号之流并不在讨论范围内；</p>
<p>也有人会将网文(即网络小说)拿出来探讨，这就是我说的下一个方面，二者的传播域。</p>
<h4 id="传播域"><a href="#传播域" class="headerlink" title="传播域"></a>传播域</h4><p>就是传播范围。为什么我会说二者的传播域会造成流行程度的差异呢？</p>
<p>书籍的发行在书店、电商平台、网络小说平台(网文发行)，书籍的传播域是主动的，简单来说，只有想看，自己才会选择去所在的传播域获取。</p>
<p>视频的发布在主流的视频平台。而视频的传播域是被动的，无论我想看不想看，它都会到我眼前。这个不是视频本身决定的，而是市场决定，因为视频易于传播，易于被接受，市场是趋利的，所以会造成视频在任何地方都会存在。</p>
<p>所以从这三点来说，视频会比书籍更加流行</p>
<h3 id="通过两种媒介，得到的信息质量如何？"><a href="#通过两种媒介，得到的信息质量如何？" class="headerlink" title="通过两种媒介，得到的信息质量如何？"></a>通过两种媒介，得到的信息质量如何？</h3><p>我认为这是一个很重要的问题。我对两种媒介获取信息的方式，是这样的看的。</p>
<p>阅读书籍是主动的。观看视频是被动的。(主动：由自己控制节奏。被动：由媒介控制节奏)这是显而易见的。读书的快慢取决于自己，看的快的就快点翻，慢的就慢点翻。当然之前网络上广泛流传的玄之又玄的“量子读书法”并不在我要讨论的范围内。而观看视频，绝大多数的情况是由内容决定。</p>
<p>我极少会将一个视频根据自己的节奏选择快放、慢放，这其中的原因有两点：1、自己认为自己对视频的掌握能力足够的好，不需要通过慢放或者回放反复观看；2、影响整体观感。而这两点中最重要的就是第一点，对于视频来说，我经常会认为自己看到了这个画面，听到了这个声音，我就了解了全部，但事实呢？譬如说，其实很多人并不会在第一次看到一个视频，就能轻松的发现视频中的彩蛋(如果视频有彩蛋)，也不能很直接的就感知到作者想表达的内容。这就造成我对视频中的信息获取是存在缺失的。但看完视频之后，自己又会有一个信号，这个我看完了，我懂了。就不再重新看过。对这一点的体会，也是因为自己偶然将某几个电视剧反复观看之后，得到的。</p>
<p>一言以蔽之，因为主动与被动的分别，就会得到这样的结论：一本书读完了，是可以称之为读完的；但一段视频看完了，却未必真的看完了……书籍的形态，会让大众更容易看全。也有人会说看全了不一定是看懂了，但其实看全是看懂的必要不充分条件，如果连看全都满足不了，看懂更是无从谈起。所以我个人认为，读书获取的信息更完善，质量会更高一点。</p>
<h3 id="二者的文化内涵"><a href="#二者的文化内涵" class="headerlink" title="二者的文化内涵"></a>二者的文化内涵</h3><p>提到这个，就不得不先说文化内涵。而说到文化内涵，又不得不说狭义文化。根据《中国文化概论》：狭义文化又称人文文化，是指某一社会集体（民族或阶层）在长期历史发展过程中经过传承积累而自然凝聚的共有的人文精神极其物质体现总体体系。我们把一些不属于狭义文化的事物中所具有的人文特性，称为事物的文化内涵。如果让我去做一个通俗解读，我认为是事物本身带给人的意义(当然这并不一定准确)。</p>
<p>而要谈这个，则要从二者的创作、发行传播出发，做分析。</p>
<p>二者的创作过程。书籍，它的内容是精炼的，何为精炼？当人把一些智慧结晶转化为文字的时候，都会力求简洁，所以大部分书籍是无一字废话。(网文可能不符合这个规律，这也是网文一直被大众声讨质量低下的原因)；视频，创作分为几种，对于电影、电视剧质量如何先不谈，但确实是存在门槛的。而短视频或者现在所谓的自媒体，emmm，无法评论，所有人都懂。而且即便说很多视频是有意义的，但却不够精炼，内容有意义，但制作太粗糙，这种情况在人人都是up主的年代是非常普遍的。</p>
<p>二者的发行传播。纸质书籍的发行，要有版号，要有编辑，有出版公司。因为整个发行链条长而复杂，也就意味着一本书的出版不易，所以对质量要求高。即使是网文，处在推荐位的，也必是网络小说平台编辑看过的，当然这个也不能保证它的质量一定就高，但是总归是有门槛的。而视频发行，分两种情况，电影、电视剧，和个人自媒体视频。但无论是哪一种，基本不存在对其内涵的审核，只审核内容的合法性。这是导致视频会出现大量的辣鸡作品的根本原因。</p>
<p>所以综上，在大部分情况下，我认为书籍的文化内涵会比视频好一点。</p>
<p>基于以上的几个问题的思考，我认为从书籍中获取信息的质量更高一点，书籍文化内涵会更高一点。所以在音视频大行其道的背景下，书籍本身依旧有它的必要性。读书在现代人的生活中也有着不可替代的地位。</p>
<p>但我要强调的是，这篇文章不是对书籍与视频进行捧一踩一，视频有视频自己的优势所在。诚然书籍在信息质量上高一筹，但因为书籍发行的不易，导致很多个人的智慧无法通过书籍媒介来传播，所以对于视频来说，优势在于降低了信息传播的门槛，与此同时才导致了质量会更差一些。毕竟事物都是双面的。所以无论是书籍还是视频，都将在信息传播中有不可替代的地位……</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>关于美学其实我一无所知</title>
    <url>/2020/11/17/i-do-not-understand-aesthetics/</url>
    <content><![CDATA[<p>距离读完《谈美》已经有一段日子了，这些日子因为更换工作的原因，再加上牙齿出了一些问题，疼的毫无心思写读书笔记，所以一直拖到现在。我最想写的《禅与摩托车维修艺术》的读书笔记也一直迟迟没动笔……就很尴尬。说回《谈美》这本书，其实在我上高中的时候便已经知道这样一本书了，因为有同学看过这本书，当时老师还质疑他是不是看得懂。如果那个时候我有足够的好奇心，也不至于与这本书错过如此之久。当我看完这本书之后，最终在我的评价体系之下，给到 4 星（5 星制）。</p>
<span id="more"></span>
<p>这本书算是朱光潜写给大众的美学分析随笔，并非是一种严肃的分析，而是像跟大众谈话一样随意的写出来。随意但是内容却不随便。在书中，朱光潜“系统地”谈论了美学相关的内容（之所以系统打引号，是因为对于大众而言是系统的，但对于美学家来说可能并不是），内容包括<strong>美是什么、如何区分是不是美、美如何分类、如何审美、如何创造美、近代实验美学与传统美学</strong>等。</p>
<p>说来实在惭愧，我依稀记得，大学的时候还上过《大学美育》这门课，不过到现在讲的什么是一点都记不得了。所以在我看来，这本书是真正意义上对我美学认知的一次启蒙，也给我现实中一些问题的解决得到了启发。朱光潜的很多观点不单是对美学研究很有意义，对于其他方面，也可以借鉴一二。而我只是粗浅的看一遍，自然是不能领会到全部，但只是粗浅的一遍便是受益匪浅。</p>
<p>在书的前半部分，内容主要还是集中在美本身上面，书中提出了广义美与狭义美的概念，并且提到了<strong>美感经验</strong>，『<strong>所谓美感经验，其实不过是在聚精会神之中，我的情趣和物的情趣往复回流而已</strong>』。这算是贯穿全书的一个准则，可以看出朱光潜对美学的很多理论，都是建立在这个基础上。在后文也借古松的欣赏，说明美是“我”与“物”二者的共同参与得到。而在明确了美的概念之后，书的后半部分，便顺势写到如何欣赏美、创造美。</p>
<p>我经常认为美是很主观的东西，没有标准，没有定义，也一度导致我觉得审美本身是一种玄学，用很俗的话来说完全依赖于审美者的吹逼能力。但读完这本书之后，我倒是觉得，美在某种程度上来说，是客观的，我所谓之客观就是一件具有美感的物，在具有审美能力的人看来，会得出具有美感的一致结论，并非玄学。美是可以被定义的，但是在不同的美学体系下，标准是不一样的而已。（我这里要强调的是，看起来跟我之前的想法没什么差别，但实际上并不一样。标准不一样，不等于没有标准，举个直接一点的例子：这就像说春秋战国时期百家争鸣，涌现很多思想，但是不能因为不是统一的思想就说没有思想）。</p>
<p>当然因为标准的不一样，也会有互相 diss 的情况。按照我个人的感受，朱光潜认为美是整体的，所以对于近代实验美学那种拆解开来对美进行理论研究是持一种批判态度的。不过我隐约也能理解他的态度，因为通读全书就会发现，朱光潜的美学理论是有非常浓厚的东方美学的味道的，或者说是建立在东方美学基础上的一种革新，将东方美学更加系统化，但是大方向还是东方美学。而且在书中他也批判了写实主义与理想主义，这本身就是一种东方的中庸思想。</p>
<p>书中关于创造美这部分内容，在我看来，是非常有价值的，价值在于朱光潜不仅给出了非常具有可操作性的方法，同时也给出了为什么这样可以创造美的解释，这是最让人可以信服的东西，等于“鱼和渔都给了”。</p>
<p>当然仅有这些内容，其实并不足以给到 4 星，因为这都是局限在美本身来说的。真正让我觉得在我的评价体系里，这本书应该是 4 星，而不应该给 3 星的原因是：朱光潜提出的一种精神，“<strong>无所为而为</strong>”。他认为审美活动就是要本着“无所为而为”的精神去进行，才能真正得到一种美感经验。</p>
<p>而且他将这种精神从审美活动扩展开来，说了下面这段话，我就顺便作为我这篇读书笔记的结束语吧。</p>
<p>『<strong>我以为无论是讲学问或是做事业的人都要报有一副“无所为而为”的精神，把自己所做的学问事业当作一这件艺术品看待，只求满足理想和情趣，不斤斤于利害得失，才可以有一番真正的成就。伟大的事业都出于宏远的眼界和豁达的胸襟。</strong>』</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>未来已来，样子跟他说的还真差不多</title>
    <url>/2021/06/28/inevitable/</url>
    <content><![CDATA[<p>鸽了很久，主要还是工作太忙，当然跟自己的懒惰也是分不开。不过书是一直在读的。三月份读了凯文凯利 (KK) 的大作，三部曲之一《必然》。但是很久都没能抽出时间去写读书笔记。最近在写的时候，就又粗略的翻了一遍。</p>
<p>其实了解到 KK 已经是很久之前了。应该是 15 年左右的时候，读了他的《失控》。当时就觉得太神奇了，我愿称之为“大预言家”，总觉得他看待事物的角度是上帝视角。不过后边就没有关注了，《必然》这本书也是某次大促的时候，找凑单书籍的时候恰好翻到，一看是 KK 的书，就毫不犹豫地买了。</p>
<span id="more"></span>
<p>传说中的KK三部曲：</p>
<ul>
<li>观察：《失控》</li>
<li>反思：《科技想要什么》</li>
<li>展望：《必然》</li>
</ul>
<p>中间的一本还没有读，找时间也要读了才好。</p>
<p>KK 的厉害之处如果用一句话总结：《失控》精准预言了1994年往后的三十年的互联网；而《必然》正在预测2016年以后三十年的互联网。</p>
<p>在《必然》中， KK 用了十二个关键词，来表达他对未来趋势的总结：<br><strong>形成(Becoming)、知化(Cognifying)、流动(Flowing)、屏读(Screening)、使用(Accessing)、共享(Sharing)、过滤(Filtering)、重混(Remixing)、互动(Interacting)、追踪(Tracking)、提问(Questioning)、开始(Beginning)</strong></p>
<p>下边就分开说说：</p>
<h3 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h3><p>一般人们都用乌托邦来代表向往的美好世界，没有问题，没有烦恼，一切都是好的，都是公平的。而 KK 直接表达了对乌托邦的另一种看法：『<strong>没有不适的世界会停滞不前；某些方面过于公平的世界，也会在其他方面上不公平得可怕。乌托邦中没有问题可烦恼，但乌托邦也因此没有机遇存在。</strong>』，但他对另一个极端，反乌托邦也并不认为会是未来发展的趋势。并提出了一个进托邦(protopia)的概念。一个不断出现新的问题，不断解决，不断进步的社会，事物都在一个很小的方面一点点进化，感知不明显但确实存在。这就是他所谓的“形成”。</p>
<p>在这一部分，他还提到了关于比特化，互联网的形成过程就是将事物比特化，其实这个观点在我上大学的时候，我倒是有那么点感触，互联网的强大之处就是可以构造一个绝对虚拟的世界，那互联网的机会在哪里呢，就在于现实世界有，虚拟世界没有的，而从现实世界到虚拟世界的转化，这应该就是 KK 说到的比特化。但是这本书里他不是强调这个，而是强调<strong>比特化将会延伸进时间</strong>。它可以轻松的回溯过去，也可能对未来的某个时间节点做出预测。这应该才是未来的发展趋势……</p>
<h3 id="知化"><a href="#知化" class="headerlink" title="知化"></a>知化</h3><p>所谓知化：<strong>将事物赋予认知能力</strong>。提到这个，在现在的社会，估计是个人都能脱口而出人工智能。而 KK 在这里则提出了一个很有趣的观点：人工心智。我也试图去提炼他的观点，他将宇宙中的思维想法，叫做心智，这个宇宙存在各种各样的心智，而人工智能属于人工心智。他提出：<strong>人工心智不是比人类想的更好更快，而是可以思考人类理解不了的。</strong>这一点倒是让人工智能清晰了不少。</p>
<p>在这里他还提到了云计算，指出<strong>云计算遵循收益递增(increasing returns)法则，又叫做网络效应(network effect)。网络规模扩大的速度远远赶不上其价值增加的速度。</strong>进一步得出了结论，<strong>未来的人工智能将由两到三家寡头公司主导，并以基于云端的多用途商业产品为主。</strong></p>
<p>（相关产业：云计算、人工智能、大数据）</p>
<h3 id="流动"><a href="#流动" class="headerlink" title="流动"></a>流动</h3><p>这一章就很神了。直接从媒介的角度出发，指出新媒介最初的形态是模仿将要取代的媒介。所以第一阶段我们的计算机存在桌面、存在文件夹。第二阶段则是出现了网络组织，但现阶段已经走入了流时代。一切的信息都是流动的。其实在 KK 来看，一切事物都遵循流动这个底层逻辑。都具有流动的四个阶段：</p>
<ol>
<li>固定、罕见</li>
<li>免费、无所不在</li>
<li>流动、分享</li>
<li>开放、变化</li>
</ol>
<p>这里我举个例子：</p>
<p>比如音乐：最开始的音乐获取的成本是很高的，需要买碟，或者买票去现场听。第二阶段，比特化之后，音乐的获取变得更方便(不考虑正版盗版的问题)，变得开始无所不在。第三阶段，人们开始去分享给其他人自己拥有的音乐，这个时候就开始流动。第四阶段，人们开始对音乐进行剪辑、改编再次创作，甚至是草根一族也可以轻松做到，这就是开放、变化。</p>
<p>其实还有很多例子：书籍、电影，甚至是我们觉得无法比特化的鞋子、衣服、摩天大楼……</p>
<p>另外就是 KK 还提到了“价值轴心的变化”，当一种东西从稀缺变得易得，价值轴心就会反转，原来与之相对的易得的东西变得稀缺也就更贵。『<strong>当复制品免费时，你就要销售那些无法复制的东西。』</strong>他如是说，什么东西无法复制呢，答具有<strong>原生性</strong>的东西。而再回头看流动的四个阶段，这恰好是由2到3的变化所需要的驱动力（其实我觉得这里也暗含了人是趋利的）。所以最终他指出，流、租赁化将会是未来二三十年的一个趋势。</p>
<h3 id="屏读"><a href="#屏读" class="headerlink" title="屏读"></a>屏读</h3><p>可能很多人都会不理解屏读跟阅读的区别在哪里。其实 KK 所说的屏读，是指屏幕固定，内容不断变化。而阅读是客体固定，人类需要不断变化客体。如果觉得拗口，把客体换成书代入进去就好了。因为阅读的对象不仅仅只是书，所以用客体更为准确。</p>
<p>与之一起而来的就是内容的比特化，因为屏读这种方式的产生，会促进内容的比特化。人们会更加需要把东西可以在支持屏读的屏幕上展示出来。</p>
<p>其实 KK 提到的屏读让我想起了博尔赫斯的小说《阿莱夫》，其实某种意义上说，现在的屏幕就跟博尔赫斯笔下的阿莱夫差不多。这么看还是博尔赫斯更厉害点，毕竟他 1994 年就写了这本小说。也或者说是哲学厉害，很早就想到了会存在着一种这样的东西来解决一个一直存在的问题。</p>
<p>（相关产业：电子书阅读器、AR\VR）</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>减物质化(轻资产)、租赁、去中心化、平台协同、云，将是未来三十年的趋势。</p>
<p>减物质化代表着用更少的物料制作更好的东西。而租赁、平台协同和云将满足人们对按需使用的即时性的要求。这些都是人类刚需的东西。</p>
<p>（相关产业：平台化产品(应用商店、Airbnb、滴滴)、SaaS产品(Adobe 订阅制、Microsoft Office 订阅制)、云盘）</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>这里的共享，有分享和协作两部分。KK 提到了一种数字化的”社会主义“，颇为有趣；或者说叫数字化的”集体主义“。这让我突然想起了一句话叫<strong>集中力量办大事</strong>。另外就是人本身都会存在分享的欲望，所以 KK 认为共享会是未来的一个趋势。</p>
<p>值得一提的是这里对协作的看法，跟《大教堂与集市》的观点还是很像的。扩展阅读的话，可以看看，这本讲开源世界观的书籍</p>
<p>（相关产品：社交软件、wiki）</p>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>在这个信息爆炸的时代，好的过滤器必须是人类的刚需。因为人的注意力是有限的。</p>
<p>这里就要谈到注意力价值的衡量。KK 提到了 CPM，在广告行业中会用 CPM(Cost Per Thousand) 来衡量获取注意力的成本。他还用互联网产品的年收益总和除以时间，来计算单位时间内产生的价值，用来当作注意力价值。具体的统计就按下不表了，互联网是最高的，这倒也能解释为什么大家都在研究让用户成瘾。他还提出了衡量个人注意力价值的一种方法，简单来说，看一场电影，就用电影票价除以电影时长，来得到单位时间内的个人注意力价值。如果从这个维度看的话，互联网上的个人注意力价值仿佛是最低的。这些统计方法也并不一定科学，但它提供了一个新的角度来衡量我们与互联网的关系。（实际上信息聚合平台，就是在想办法节省人们的注意力。）</p>
<p>至于过滤器，也并不一定就是传统意义的过滤器，像推荐系统本身其实就算是过滤器的一种……</p>
<p>（相关产品：Google AdSense、推荐系统、信息聚合平台）</p>
<h3 id="重混"><a href="#重混" class="headerlink" title="重混"></a>重混</h3><p>重混：<strong>对已有事物的重新排列和再利用，对传统的财产观念和所有权概念产生了巨大的破坏。</strong>这里毫无意外的提出了法律上的问题，KK 认为需要一个更为适合的法律来对此进行约束，既能保留社会的进步性、但又能对权利得给予必要保护。这也是之前提到的事物流动中的四个阶段，其中的第四个阶段。</p>
<p>（相关产品：视频剪辑片段、同人小说）</p>
<h3 id="互动"><a href="#互动" class="headerlink" title="互动"></a>互动</h3><p>未来的几十年，人类会对不断与之互动的事物进行拓展：</p>
<ol>
<li>我们会继续给自己制造的食物添加新的传感器和感官功能</li>
<li>互动发生的区域将会继续向我们靠近</li>
<li>最大程度的互动会要求我们欣然融入技术本身</li>
</ol>
<p>（相关产品：VR&#x2F;AR、计算机视觉）</p>
<h3 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h3><p>对事物的追踪会产生大量的数据，而这些数据会给人类改善生活提供更好的方向。追踪之后的分析用来进行知化，将会让设备变得更加智能，做进一步追踪。这又恰好印证了进托邦的微改善。好家伙，套上娃了。</p>
<p>（相关产品：物联网、智能穿戴、大数据、智能家居、智能出行等）</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><p>网络让人失去了沉思的能力，蜂巢式的心智让人们变得不愿意思考。巴勃罗 · 毕加索对作家威廉 · 费菲尔德说：计算机是无用的。它们只能给你答案。好的问题在这个时代是需要的。那什么是好问题？关于这个，KK 没有对其直接下定义，而是举了一些例子：</p>
<ul>
<li>一个好问题值得拥有 100 万种好答案。</li>
<li>一个好问题就像爱因斯坦小时候问自己的：“如果和光线一起旅行，你会看到什么？”这个问题开启了相对论、质能方程 E&#x3D;MC^2 以及原子时代。</li>
<li>一个好问题不能被立即回答。</li>
<li>一个好问题挑战现存的答案。</li>
<li>一个好问题与能否得到正确答案无关。</li>
<li>一个好问题出现时，你一听见就特别想回答，但在问题提出之前不知道自己对此很关心。</li>
<li>一个好问题创造了新的思维领域。</li>
<li>一个好问题重新构造自己的答案。</li>
<li>一个好问题是科学、技术、艺术、政治、商业领域中创新的种子。</li>
<li>一个好问题是探索、设想、猜测，带来差异和分歧。</li>
<li>一个好问题处于已知和未知的边缘，既不愚蠢也不显而易见。</li>
<li>一个好问题不能被预测。</li>
<li>一个好问题是机器将要学会的最后一样东西。</li>
<li>一个好问题代表受教育的头脑。</li>
<li>一个好问题能生成许多其他的好问题。</li>
</ul>
<p>这些例子让我们可以抚摸到好问题大致的轮廓。</p>
<p>在现在的世界上，正如 KK 说的<strong>『提问比回答更有力量』。</strong></p>
<p>（相关产品：问答社区、wiki）</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>互联网将这个世界连接，如果将整个世界看成一台计算机，这个世界上的每一个大脑都变成了其中的一块芯片。这些组合在一起就是一个世界大脑，有人把它叫做<strong>心智圈(Noosphere)，</strong>KK 把这个称之为<strong>『全息圈(Holos)』</strong>，而这个全息圈将会在未来通过上述这些能力向更好的方向进化。仿佛整个世界是在进行一场类似机器学习的训练……</p>
<p>正像 KK 在结尾说的<strong>『未来 30 年，全息圈将沿着与过去 30 年同样的方向挺进，那就是：更多的形成、知化、流动、屏读、使用、共享、过滤、重混、互动、追踪以及提问。我们正站在开始的时刻。已经开始。当然，也仅仅是个开始。』</strong></p>
<p>总之，这本书提到的很多东西，在现在已经看到有很多产品得到了印证，初看的时候我觉得这就是对现在社会规律的总结而已。但其实，这本书写于 2016 年，那个时代还看的并不那么明显，五年以后的现在仿佛已经有很多方面得到了证实。</p>
<p>其实让我受益匪浅的，不是 KK 的这些结论，而是他推导这些结论所依据的底层逻辑。实际上整本书是网状结构，因为读到最后，会发现，他的结论或者说这个世界的运行都在依照着某种形态或某种规律，这些规律就是我所谓的底层逻辑。而这些东西，在他 1994 年写的那本《失控》中，就已经初见端倪。整个世界依照着这个底层逻辑在不断的往前运行着，所有事物都无法逃脱。这让我不得不觉得，KK 开了上帝视角。</p>
<p>我并不能对这本书做一个非常完美的提炼，或许是因为书中的金句太多，每一句拿出来都可以让人得到醍醐灌顶般的体验。凯文凯利，永远滴神……</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>跑断腿的租房过程杂谈</title>
    <url>/2019/03/23/it-life-tenement/</url>
    <content><![CDATA[<p>工作搞定之后，便开始了让人烦恼的看房租房的流程之中。这次比以往都要艰难，相隔一小时车程的两个地点，跑断腿这个形容词真的难以形容。整个过程历时三天，看了将近十套房子。过程中倒也积累了一些人生经验。</p>
<span id="more"></span>

<p>其实租房子，最难的是确定自己的需求，因为人的内心是非常善变的，很多人妄图靠感觉找到最合适自己的房子，我只能说无异于盲人摸象。只有真正对自己了如指掌的人，方能少走弯路，任何事情都是同理。</p>
<p>对于我而言，最重要的是私人空间，所以从一开始就将自如等合租方案排除了，最开始的时候我是有考虑带独卫的主卧，不过后来觉得做饭还是麻烦，所以就不考虑合租了。<strong>至此定下整租的基调</strong>。</p>
<p>另一个重点是公寓 or 小区房。二者在管理、户型、其他费用上有很大的不同。对于我来讲，还是喜欢小区房，毕竟住户不会太奇葩，而且水电物业的开销会小一些。</p>
<p>下一个重点是选址，每个人选址有不同的需求，而我比较看重的是与公司的距离，以及关于价格的参考。当在几个 APP 中简单看过之后，大概确定了价格范围，一公里内和三公里内两个能接受的范围，一公里以内比外边三公里以内租金贵五百块，这是我的实际情况，但考虑到，如果房源质量优秀，还是可以接受的，所以还是联系了一公里以内的一套房。是一个标准的商用公寓，一居室户型规规矩矩，但是没有阳台，只有飘窗，这样晾衣服着实捉急，加之价格不美丽，果断直接排除了一公里以内的所有房源。开始看另外一部分，幸运的是，在另外一个范围，一居室只有一个小区的一栋楼有，这极大的帮助我缩小了范围。开始了小区里的漫漫看房之路。</p>
<p>这里要说下我使用的 APP ：</p>
<ol>
<li>链家 &amp;&amp; 贝壳（因为他俩应该算是一家的 APP ）</li>
<li>zuber租房</li>
<li>自如</li>
<li>安居客</li>
<li>房天下</li>
<li>58</li>
</ol>
<p>使用频率最高的是前二的三个 APP 。zuber租房的图或者是视频质量也是极好的，但是房源太少，且联系了业主很多都不回话，留了微信不知道是不是微商套微信好友的。之所以非常高频的使用第一个，是因为房源是绝对真实的，图也是实拍，后三个的话，看看参考参考就好，很多真的是胡说八道。虽然我不考虑自如合租，但是还是下载了自如看整租，然后发现根本没几套，所以也就没怎么用。</p>
<p>锁定了小区之后，其实在 APP 中查询便是很容易的了。根据自己能接受的价格，找了几套，这里要注意的是，略高一点的价格也可以作为备选，因为很多房源是有议价空间的。在链家的 APP 选房，顺理成章地是选择链家中介的服务，但是我并没有在一棵树“吊死”，而是选择去小区楼下找附近中介实体店，让他们也帮忙带我看房。事实证明，这个选择是对的。一是有很多中介是有独家房源的，只在这一家中介挂，所以如果只选择一家中介，那必然看不全；二是当找了几个中介的时候，就会无形中让中介形成一种竞争关系，可以为以后杀价增加一些优势。<strong>但是尤其要注意，看房期间，可以让他们知道自己有找其他中介看房，但是不能让他们知道自己找了哪家中介看房以及看的哪套房</strong>。这是一种自己主动制造的信息不对称，是对自己有利的。</p>
<p>三天的时间里，看了将近十套房。主要关注<strong>价格</strong>、<strong>房屋位置</strong>、<strong>屋内配套</strong>、<strong>邻居</strong>、<strong>楼层楼号</strong>、<strong>房东信息</strong>。根据这几项，对十套房进行一个初步评分，筛选出三套，进入决赛，决赛很简单，就是看议价空间，这个时候反馈给中介，让他们去跟业主杀价，并且这个时候要透漏给中介，自己也有找其他中介在杀价，谁杀的低杀的快，就选谁。然后拿到房屋的低价，最后复看一遍决赛房屋，开始检查细节，包括柜子、屋子角落。一是根据细节调整评分，二是有时候会有意外收获（比方说翻到了之前的租房合同，就可以很清楚的知道自己拿到的是不是底价了，一般非首次出租的房屋，底价就是上次出租的价格）。</p>
<p>我在检查房子的时候，除了基本的配套设施是否齐全且能正常使用，另外要把柜子拉开，看看有没有味道，或者是发霉、或者是因为新柜子会有甲醛，另外顺带询问业主和上一个租客的信息，房子是不是首次出租等等。</p>
<p>就这样选出了想租的房子。这中间还有个小插曲：在看房的时候我发现房屋的东南向一两公里有陵园，其实我本人是不太介意的，但是我这人对合作的人会有一些判断影响我的合作意愿，所以我假装不知道，问中介那是什么地方，但是很遗憾，所有的中介都没有给我想要的答案，有的是不知道，有的是罔顾左右而言他。人性果然经不住考验，不过也可以理解，毕竟这个事一说，这单大概率泡汤。</p>
<p>其实根据这个套路选出的房子，不一定是性价比最高的，但一定是自己最喜欢的，因为租房的选择就有很强的主观意愿，而在自己打分的过程中，其实并不一定自己打分会很客观，而是这个分数可以在日后作为自己很强大的安慰，最终选出来的，在能想到的方面一定是自己满意的，即使不满意自己也有理由说服自己……</p>
<p>主观问题的正确答案，其实就是最能说服自己的答案而已。而且我相信天道酬勤，当自己付出了大量的精力在这方面，没理由会收获一个比较差的结果。</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>人生经验</tag>
        <tag>租房</tag>
      </tags>
  </entry>
  <entry>
    <title>面试问题整理</title>
    <url>/2018/06/08/job-interview-summary/</url>
    <content><![CDATA[<p>最近一段时间整理了一些我遇到的面试题，各个方面都有，写在这里，做个记录。大厂偏好算法和数据结构，小厂偏好项目经验。这算是一个比较鲜明的特点了。</p>
<span id="more"></span>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ul>
<li>static 的作用<blockquote>
<ol>
<li>static的最主要功能是隐藏，</li>
<li>其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. </li>
<li>用于类成员声明，所有实例共享。</li>
</ol>
<p><a href="https://www.cnblogs.com/songdanzju/p/7422380.html">C++中static关键字作用总结</a></p>
</blockquote>
</li>
<li>extern “C” 的作用<blockquote>
<p>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。</p>
<p><a href="https://blog.csdn.net/jiqiren007/article/details/5933599">extern “C”作用详解</a></p>
</blockquote>
</li>
<li>sizeof(char)、sizeof(char*)、sizeof(int)、sizeof(int*)<blockquote>
<p>1、4 or 8、4、4 or 8</p>
<p><a href="https://blog.csdn.net/xunfeng13/article/details/51011509">C&#x2F;C++中sizeof()的用法</a></p>
</blockquote>
</li>
<li>指针是多少字节由什么决定<blockquote>
<p>程序位数决定</p>
</blockquote>
</li>
</ul>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><ul>
<li>shared_ptr 如何解决循环引用<blockquote>
<p>使用weak_ptr</p>
<p><a href="https://www.cnblogs.com/diegodu/p/6370736.html">std::shared_ptr 和 std::weak_ptr的用法以及引用计数的循环引用问题</a></p>
</blockquote>
</li>
<li>Vector、List、Queue分别在什么情况下用<blockquote>
<ul>
<li>查找操作使用较多，使用Vector</li>
<li>增删操作使用较多，使用List</li>
<li>先进先出的使用场景，使用Queue</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>完全二叉树是什么<blockquote>
<p>完全二叉树：倒数第二层是满二叉树，最后一层靠左对齐</p>
</blockquote>
</li>
<li>满二叉树是什么<blockquote>
<p>满二叉树：结点要么是叶子结点，要么它有两个孩子结点。</p>
</blockquote>
</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>进程与线程分别都是什么<blockquote>
<p>进程：程序在执行过程中分配和管理资源的基本单位。每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。(资源独立，创建销毁代价大)<br>线程：CPU独立运行和独立调度的基本单位。(堆公有，栈私有，创建销毁代价小)</p>
</blockquote>
</li>
<li>进程与线程能否多对多<blockquote>
<p>可以多对多。1. 地址空间映射；2. 进程间通讯。 做好这两部分。(云计算比较有用)</p>
</blockquote>
</li>
<li>线程切换上下文需要保存什么信息<blockquote>
<ul>
<li>CONTEXT结构中保存着特定于处理器寄存器的数据。系统使用CONTEXT结构执行各种内部操作。参考WinNT.h</li>
<li>见《Windows核心编程》P174</li>
</ul>
</blockquote>
</li>
<li>线程安全与可重入分别都是什么<blockquote>
<ul>
<li>线程安全：某个方法，在多线程下调用，跟顺序执行一致，即安全的，就叫做线程安全方法</li>
<li>可重入：某个方法，执行过程中，中断，然后继续执行，结果不受影响，即方法可重入</li>
<li>二者没什么概念上的必然联系。一个方法是可重入的，不一定就是线程安全的；一个方法是线程安全的，不一定是可重入的</li>
</ul>
</blockquote>
</li>
<li>给两把锁、两个线程如何构造死锁<blockquote>
<p>线程T1、T2；锁L1、L2。T1获取L1，等待L2，获取L2，释放L2，释放L1；T2获取L2，等待L1，获取L1，释放L1，释放L2。</p>
<p><a href="https://blog.csdn.net/u010915032/article/details/52060232">多线程死锁例子</a></p>
</blockquote>
</li>
<li>同步异步和阻塞非阻塞的区别</li>
<li>A线程while循环，B线程打印，先后开启A、B线程，能否输出内容</li>
</ul>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li>TCP 三次握手<blockquote>
<ul>
<li>A -&gt; B  SYN</li>
<li>B -&gt; A  SYN+ACK</li>
<li>A -&gt; B  ACK</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>什么是主键和外键<blockquote>
<ul>
<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
</blockquote>
</li>
<li>DROP、DELETE、TRUNCATE的用途<blockquote>
<ul>
<li>DELETE是DML，可以回滚，需要显式提交，删除单条数据。</li>
<li>DROP是DDL，隐式提交，不能回滚，不触发触发器。删除表结构。</li>
<li>TRUNCATE是DDL， 隐式提交，不能回滚，不触发触发器。清空表内容。</li>
</ul>
<p><a href="https://www.cnblogs.com/zhizhao/p/7825469.html">drop、truncate和delete的区别</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【复音口琴】空气伴奏、爵士卡尔、小提琴奏法、曼陀铃技巧</title>
    <url>/2014/12/22/kong-jue-xiao-man/</url>
    <content><![CDATA[<p>空气伴奏是最简单了，就是直接吹七个孔。但是吹奏的时候要注意，如果平时是含五孔堵四孔，吹空气伴奏要注意口型的变化。空气伴奏也被叫做和弦伴奏，因为你吹七个孔123456[1]实际上吹出的只是135这是一个和弦。但是口琴的构造特殊，所以标准和弦一把琴就能吹一个两个的，如果想吹奏其他和弦，就要多只口琴，利用移调来实现。这个我觉得自娱自乐没必要纠结了，毕竟编谱还是和我们比较遥远的。</p>
<span id="more"></span>

<p>爵士卡尔奏法，也被叫做手哇音。吹奏主音的同时捂住的双手放开，声音便如呜哇一般。好像布鲁斯口琴上也是有这个技巧的。这个技巧也是说起来很容易说清，效果上比较难做到位。要自己反复体会。我在自己吹奏的时候有一种体会，可以稍稍拖一点舌伴奏，也就是在空气伴奏上把这个手哇音做出来，听起来会饱满一些。如果是伴奏的铿的声音出来的一瞬间，做出了手哇音，效果则没那么好。</p>
<p>小提琴奏法，口型缩到最小，吹琴格上排一个孔，同时用手轻微晃动口琴，使口琴发出小提琴般的声音。这里边我自己刚开始吹奏的时候发现，不像，一晃动口琴音就断了。这里边还是和杨敬民老师的讲座里学习了一下，下嘴唇放到琴格贴上下排孔，无论如何晃动，只要下嘴唇不离开琴格，音就不会断了，可以通过嘴的感觉来调整你自己晃动口琴的幅度，这方法简直是太机智了；另外就是如果自己觉得技巧游刃有余了，可以尝试在吹奏小提琴奏法时，根据乐曲需要加入滑音，有奇效。不过要看口琴，我自己的口琴感觉滑音控制不好，会发出啸音。</p>
<p>曼陀铃奏法，一种非常清脆悦耳的奏法，如曼陀铃一般。吹奏琴格上排单孔，口型缩到最小，舌头在里面前后或左右摆动。我自己习惯左右摆动，因为这样够快。但实际上我特意在网上听了曼陀铃这种音色，并没有特别快，所以前后也可以的。其实我听了好多视频，感觉很多人把曼陀铃都快演奏成风铃了。这里边的坑主要是：左右摆动频率要一致，不然自己就会听出来效果很差。而且在移动口琴时经常会因为不熟练，而导致乐曲演奏不连贯突然失声了，这也是在练习时要注意的。</p>
<p>以上的这四种技巧在练习的时候也是，每天练一段，时间一长自然感觉就到位了。</p>
]]></content>
      <categories>
        <category>口琴吹奏技巧</category>
      </categories>
      <tags>
        <tag>harmonica</tag>
        <tag>复音口琴</tag>
      </tags>
  </entry>
  <entry>
    <title>写作入门到底应该看点什么</title>
    <url>/2021/02/17/literary-mind-notes/</url>
    <content><![CDATA[<p>1 月份读了两本书，19 年和 20 年未读完的两本书，一本是《文心》、一本是《呐喊》。</p>
<p>其实对于鲁迅，应该是每一个中国人都不陌生，但是知道名字和了解作品是两码事，从这一点上来说，我对他还是挺陌生的。真正觉得他的作品有意思，应该也是 19 年看了他的 《朝花夕拾》，才觉得他要比我听到的厉害得多。本来是想写写关于他的感想，但后来觉得读的太少，目前除了觉得牛逼之外，真的无法评价，所以还是暂且搁置一下。主要还是说说《文心》。</p>
<span id="more"></span>
<p>《文心》这本书读的跨度是有点长了。19 年读，然后忙起来之后，就一直没看，搬家倒是一直带着，开年想起来还是要把之前未完成的收尾，便又重新拾起来读。读这本书主要是看知乎的一些答主推荐的，当时工作不是很忙，就想要写点东西，也是搜了一下写作推荐的书籍，很多答主都不约而同的推荐了这本书，所以就买来阅读。</p>
<p>其实这本书是写给中小学生看的一本关于写作、文体的入门书籍，书的作者是叶圣陶和夏丏尊，现在普遍认为是他们提出了语文的概念，这书还没等写完呢，这俩人就结亲家……也许这就是传说中的门当户对吧。基本上能看到的对这本书的评价都是『<strong>相见恨晚</strong>』。我想如果我更早一点接触这本书，估计在学生时代，对语文的理解和兴趣应该能更精进一些。</p>
<p>这本书的字数并不多，但是内容却很丰富。不太客气地说，我觉得叫《写作概论》也可。行文也非常轻松，用一些角色，通过讲他们之间的故事来介绍写作。读完之后方知推荐的好，它不是那种简单直接的教你怎么写故事的方法书籍，而是为读者了解写作这种东西提供了一些基本的方法论。</p>
<p>关于写作的基本问题：</p>
<ul>
<li>写作是什么</li>
<li>为什么要写作</li>
<li>怎么写作</li>
<li>写什么</li>
<li>怎么写的更好</li>
<li>怎么避免写的烂</li>
</ul>
<p>这些问题在书中都能得到答案。而且难得的是，在说清楚这个的基础上，又通过书中故事传递了一种比较好的语文教育观念，所以也有人说这本书其实是老幼皆宜，家长、老师、孩子看了都能有收获。</p>
<p>对于我个人来说，让我感到很大触动的是书中很多内容让我觉得这跟之前读到的《谈美》有一种呼应，或者说思想上的相通性。比如对于文章风格的品鉴，其实就是一种审美体验；另外书中“大文”同学提到的『不免偏于“为有国文科目而学习国文，为有算学科目而学习算学”。现在经王先生点醒了，不再升学的人倒不必措意，因为再没有什么特设的科目摆在面前了；而升学的人却必须特别牢记，要使一起科目与生活打成一片，那才是真正的“升学”』，这又有点『无所为而为』的味道了。</p>
<p>朱自清在序言中说『有了指点方法的书，仿佛夜行有了电棒』。在我看来《文心》应该称得上是每一个喜爱写作的人的“夜行电棒”了。</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇读《毛姆读书随笔》的随笔</title>
    <url>/2020/03/31/maugham-reading-notes/</url>
    <content><![CDATA[<p>《毛姆读书随笔——阅读是一座随身携带的避难所》这本书是朋友送给我的。第一时间拜读了一下。对于毛姆，我之前是不太了解的。唯一印象就是《月亮与六便士》好像是他写的。然而，我也没读过。看过这本读书随笔之后，倒是对毛姆多了几分崇拜，有点路转粉的意思。</p>
<span id="more"></span>
<p>这本书的译者是罗长利，然而我也并不认识。但是在我看来，前言中他对这本书的评价，以及对毛姆本人的评价是非常客观、公道、准确的。</p>
<p>这本书总共分为三个部分</p>
<h3 id="第一部分：怎样读书才有乐趣"><a href="#第一部分：怎样读书才有乐趣" class="headerlink" title="第一部分：怎样读书才有乐趣"></a>第一部分：怎样读书才有乐趣</h3><p>在这其中，他写了关于读书的一些看法以及阅读的方法。</p>
<p>毛姆认为读书一定要是享受的，如果觉得不爽、不享受那就不应该读。尤其是在听多了那种鸡汤，“告诉人们读书多好多好，要坚持，要努力，刚开始读费劲，后来就会很爽”这种言论之后。突然看到有人跳出来说，觉得不爽就不要读，喜欢就读，不喜欢就不读，尤其他本人又是个著名作家，这是让人感到非常新鲜的。</p>
<p>而谈到读书的方法，他认为跳读是一种很好的方法，值得所有人使用，不过他也表示并不是所有的作品都适合跳读，但大部分作品都可以采用这种方式。他甚至认为，很多作品的内容是有些冗余的，如果能够正确的跳过那些冗余的部分，会让人觉得作品更加完美。</p>
<p>对于畅销书，毛姆的看法是畅销不等于好，但畅销也不代表一定坏。只要作品畅销，不管它好与坏，就一定有它值得称道的点。在这一点上，我认为毛姆的看法是足够客观的。他不像大众所感受到的大部分作家那样不食人间烟火，将文学捧上神坛，让经典文学作品跟大众越走越远。相反是非常接地气。这一点在全书都能感受的到。</p>
<p>他还认为小说有一定的深度固然是好的，但这一切的前提都要有好的故事，不能奢求小说家还是什么别的家，小说家能写好故事已经实属不易。如果为了追求其他，而忽略了小说本来的东西，也不能算作是好的作品了。</p>
<p>不得不说，当时看过这一部分之后，我已经对这本书产生了一些兴趣，因为他说的话，我爱听……不管是他故意说的，还是他真的是这样想的，总之，我认为他的这些观点很能引起我这种读者的共鸣。</p>
<h3 id="第二部分：怎样的人写出怎样的书。"><a href="#第二部分：怎样的人写出怎样的书。" class="headerlink" title="第二部分：怎样的人写出怎样的书。"></a>第二部分：怎样的人写出怎样的书。</h3><p>名字虽然是这样，但实际上内容是写他推荐的一些文学作品，类似《堂吉诃德》、《高老头》、《战争与和平》等等。在书评这方面，毛姆的角度也是相当奇特。正如前言中译者说的，他对这些作品其作者的生活经历做了深入的研究，试图挖掘他们的人生经历与作品的关系，而看过他对这些作品的评价，其实就会有种感觉，这些巨作，跟作家本身的经历有着千丝万缕的联系。有联系并不代表是严格意义上的一一映射，但总能找到在这个经历下，作品产生的合理原因。对于很多人总想在现实中作家经历上找到与作品人物性格雷同的人这样的行为，他也是持批判态度的，他认为大部分的作品对人物的构造是源于现实中某些人的特质，但也存在一些作品的人物，作家根本就不是依托他周围人的性格写出来的，而是完全靠作家想象的。他认为大多数情况下人们对作家的想象力还是不够有信心，认为不存在可以完全虚构一个性格鲜明人物的作家。</p>
<p>另外他在书中也提到，作家是否为钱写作，并不影响作品本身，在他看来，相反部分作家以钱为写作目的，还更有动力，需要钱，作品就写的好。</p>
<p>除了评价作品的角度新奇，他的语言也足够的幽默，让我看过之后，非常有冲动想看一下这些推荐的作品，这一点他确实是厉害。毕竟他推荐的这些作品，我在小学时候就拉黑了，那个时候就觉得，很难读，很没意思。但是看过他的推荐，好像又激发了我对它们的兴趣。</p>
<h3 id="第三部分：怎样思考就有怎样的人生"><a href="#第三部分：怎样思考就有怎样的人生" class="headerlink" title="第三部分：怎样思考就有怎样的人生"></a>第三部分：怎样思考就有怎样的人生</h3><p>这一部分讲了他对宗教、哲学、伦理学的一些看法，感觉也非常通俗易懂。他的看法不是那种站在天上俯视众生的感觉，而是讲他的切实体会。这一点是难能可贵的。让人觉得跟这位著名作家丝毫没有距离感。而在作品的最后他还讲到他对真、善、美的看法。他认为，真、美都不算人生的内在价值，当然这不是直接得出的结论，而是在之前有过一番他自己的推理与思考。对于善，他有深刻体会，这也跟他个人经历有关。最后他以雷昂修士的话结束全书：生命的美别无其它，不过顺应其天性，做好分内之事罢了。</p>
<br>
我也曾思考，为什么说阅读是一座随身携带的避难所。读完整本书之后，我觉得这不仅仅是说读者可以从阅读中汲取到自己所迫切需要的。更是在说，对于作家自身而言，将自己在现实中得不到的追求与向往写成作品，作品对于作家本身也正是一种避难所的存在。
<br>
<br>
这本书从始至终，毛姆就像是一个跟你书信往来的朋友，在讲述他对读书、对文学作品的看法以及他在哲学上的一些感悟。我也看过一些其他书评相关作品，不过跟这本书比起来，就觉得有些遥远。在我看来，毛姆这个作家丝毫没有架子，又能将很微妙的一些东西深入浅出地表达出来，实在是高。


]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>【复音口琴】前后伴奏技巧</title>
    <url>/2014/12/21/qian-hou-ban-zou/</url>
    <content><![CDATA[<p>单音之后紧接着技巧的学习大概有两种套路。</p>
<p>学习单音的相关技巧，如手震音、琶音、装饰音(倚音)、波音、咳音等<br>学习伴奏的相关技巧，如前后伴奏、大小伴奏等<br>值得一提的是，如果下定决心学下去，最后这些技巧肯定是都要学习的。那就无所谓先后了。</p>
<span id="more"></span>

<p>这里就先说伴奏技巧。简单的伴奏就是前伴奏、后伴奏。</p>
<p>硬要说区别就是：</p>
<ul>
<li>前伴奏：在吹奏单音的同时加上舌头伴奏</li>
<li>后伴奏：先吹奏单音，保持单音不断，加入舌头伴奏</li>
</ul>
<p>也就是说舌头伴奏加的时机就是前后伴奏的区别。</p>
<p>在学习新式单音之后，舌头会稍微灵活了一点。</p>
<ul>
<li>吹前伴奏：在吹奏单音的同时，将舌头迅速靠上去，既有主音，又可以发出清晰地：铿、铿、铿的音。</li>
<li>吹后伴奏：新式单音吹出主音之后，在谱子标记的位置收起舌头，再快速弹出，达到主音不断，又可以清晰的发出：铿、铿、铿的音。</li>
</ul>
<p>这里解释一下铿、铿、铿的音是怎么来的，主要就是极短的空气伴奏就会是铿、铿、铿的音了。</p>
<p>很多复音口琴的技巧其实一句两句便能说清楚，但是练习是要很长时间的。</p>
<p>在前后伴奏上可能遇到的坑就是：</p>
<ol>
<li>刚开始舌头灵活性较差，不能快速贴琴，听到的就是空气伴奏的声音；</li>
<li>另外就是前后伴奏分不开，本来应该吹前伴奏的，吹成了后伴奏，或者是本来应该吹成后伴奏的，吹成了前伴奏。</li>
</ol>
<p>对于第一个情况，就是一个原则，由慢到快。做专项练习。吹一个音，舌头先是慢慢贴琴，然后逐步加快，每天做做，舌头就练出来了；对于第二种情况，一定要严格按照谱子来吹，而且自己要注意分辨是否吹错。如果这个不强行纠正自己，就会走向歪路，这对以后吹奏变奏曲，有很大影响。</p>
<p>而且关于节奏实际上有很多种，但是常用的就那么几种，类似于什么前八后十六，前十六后八，等等。所以遇上一个新的节奏舌头反应不过来，只要自己停下来，专门练习这个节奏，大概十几分钟就掌握了，而且下次吹就很容易了。所以遇上新节奏不要强行求快，一定要分解下来练习，有奇效……</p>
]]></content>
      <categories>
        <category>口琴吹奏技巧</category>
      </categories>
      <tags>
        <tag>harmonica</tag>
        <tag>复音口琴</tag>
      </tags>
  </entry>
  <entry>
    <title>亲密关系的失败与成功是否有规律可言</title>
    <url>/2022/07/23/qin-mi-guan-xi-shi-fou-you-gui-lv/</url>
    <content><![CDATA[<p>这半年基本没有完整的读过什么书，忙总归是“常用常新”的借口，但归根结底还是懒在作祟。直到这周才看完了《亲密伴侣——爱与婚姻的模式》，不可多得的好书，在还没有到年底统一打分的时候，便能提前预定今年五星书籍的一本书。说来也是幸运，这本书不是别人推荐，而是在去年逛书店的时候随手翻了，觉得内容还比较新鲜，就买回来看，没想到捡到宝。</p>
<span id="more"></span>
<p>特别要说明，一提到这一类的内容，总是先想到被到处推荐的《亲密关系》，这两个并不是同一本书，为了避免混淆，所以还是有必要着重点明。</p>
<p>那说回《亲密伴侣》这本书，我更愿意称之为《夫妻关系百科全书》。作者麦琪·斯卡夫是美国的婚姻心理学专家，这本书的内容是她基于200多对夫妻的普通访谈和32对夫妻深入访谈，总结的夫妻关系失败与成功的原因，以及一些扭转关系的可行方法。正如名字所说，爱与婚姻的模式，作者挑选比较有代表性模式的夫妻，借着访谈的内容阐述这种模式形成的原因、会导致的问题以及扭转的方法。在结尾进行了夫妻关系的总结，将夫妻关系分成了五个层次，逐一介绍。之所以我愿意把它叫做《夫妻关系百科全书》是因为在我有限的阅历里，没有发现有情侣或夫妻关系的模式逃脱出作者所总结的这些模式中，而对于模式形成的原因，跟作者的分析不说一毛一样，也是没差多少。</p>
<p>整本书看下来我对它的评价可谓是跌宕起伏……<br>看前边：好厉害，大预言家。<br>看到中间：是不是两头堵，作者在P我？<br>看到后边：我还是跪着看吧</p>
<p>作者对于亲密关系的模式有很独到的见解，并且有理论的总结，其实有时候会觉得，她的很多理论，对于普罗大众可能会有一些经验性的东西重合，但是大众的问题是不成体系，只是有一个很模糊的经验。还有一部分概念的提出，让人有醍醐灌顶的感觉，给人一个非常高的视角，所以这本书在我的打分体系下预定五星。这也是当初看前边的时候，让我觉得这书太有东西的一个原因，鉴于书中的内容，可以说是字字珠玑，作为读书笔记，也只能挑一些点来阐述。</p>
<h2 id="家族谱系图"><a href="#家族谱系图" class="headerlink" title="家族谱系图"></a>家族谱系图</h2><p>作者在给夫妻做治疗或者访谈，都会绘制家族谱系图，绘制方法在书中有介绍，但不建议看了之后就开始自己琢磨画这个，最好是将全书看完，知道这东西是用来干啥的，再去琢磨自己画这个。为什么要画这个，是因为作者的一个结论，<strong>『人总是会不自觉地将与伴侣的关系带入到一种熟悉的模式上』</strong>，所以伴侣的问题，多半都可以在其中一方的家庭上找到诱因。值得一提的是，作者认为，人总是会找到一个伴侣，这个伴侣会跟自己家庭中的某一个人非常相似，这里的家庭指的是家族，作者说虽然没找到原因，但根据她的一些研究，就是这么神奇。</p>
<h2 id="伴侣之间的矛盾本质"><a href="#伴侣之间的矛盾本质" class="headerlink" title="伴侣之间的矛盾本质"></a>伴侣之间的矛盾本质</h2><p>双方对亲密与自主的界定存在矛盾，这个矛盾可能是各自自身的，也可能是双方的。所以所有的矛盾都可以一言以蔽之。但一句话就能说完了，为啥还要写一本书呢。因为展开来说，对于这二者的衡量标准的形成，原因则是多种多样的，这些原因也会影响着伴侣形成各种各样的模式。</p>
<h2 id="情感三角"><a href="#情感三角" class="headerlink" title="情感三角"></a>情感三角</h2><p>三角形的稳定结构，被作者引用到了情感关系中。伴侣之间的矛盾，其实本质上是双方或一方自身的矛盾，但双方不擅长处理矛盾，所以会不自觉在冲突的过程中，拉上另外一个人，这样形成了一个稳定的情感三角，导致问题永远得不到解决，因为双方意识不到矛盾是双方产生，转移了矛盾点。一个很自然能想到的，出轨的情况，夫妻双方与小三形成的三角结构。但实际上出轨实际上还是相对较少的情况，而更多的是，夫妻一方与孩子或夫妻一方与父母的一个人形成的情感三角，比如在教育孩子的冲突上，在涉及父母的冲突上，其实本质是双方的冲突，但大多数人都会根据这个“第三者”来进行争吵。情感三角的出现，在某种程度上来说是导致问题得不到根本性解决的原因之一。</p>
<h2 id="投射性认同"><a href="#投射性认同" class="headerlink" title="投射性认同"></a>投射性认同</h2><p>在上边我说到伴侣之间的矛盾，其实本质上是双方或一方自身的矛盾，情感三角可以说是双方的矛盾引发的一个现象。而投射性认同，则是一方自身的矛盾引发的现象。甚至这个概念可以引申到生活、工作的各种场景。这里借用一段原文来描述：<strong>『投射性认同是自我的一种防御行为，用来改变一个人对其亲密伴侣的认知，同时以一种互利互惠的方式，改变他对自己的看法』</strong>。这里的概念其实会非常晦涩但是如果有例子，则很直观。在一个歇斯底里的妻子和沉默寡言的丈夫这种模式下，其实并非双方的性格如此。拿丈夫来说，丈夫自己内心存在愤怒，但拒绝承认，所以这种愤怒则要投射给妻子，而妻子如果意识不到这一点，接受了这种投射，则两人达成了一个共谋，由妻子代替丈夫表达愤怒，在大多数的冲突场景，其实都是丈夫本身存在着愤怒，但是丈夫不会主动点火，而是会想尽一切办法激怒妻子。在这种例子中，丈夫本身存在着愤怒和温和的矛盾，但是自己拒绝接受这种矛盾的存在，就必须要把其中一面投射到伴侣身上，这也就是投射性认同。</p>
<p>至于我说这个概念可以引申到生活工作，也就不难理解了，最直观的场景，焦虑的老板其实存在着焦虑与迷茫没有思路的矛盾，但是他拒绝承认自己的矛盾，会把寻找思路的问题投射给下属，所以老板自己存在矛盾的时候，下边的人就会卷成麻花，但也不见成效，本质是老板自己就没有思路突破困境。</p>
<p>如果仅看这一段，其实很容易会有我之前的感觉，感觉作者在 PUA 我，但实际上如果把全书看完，会对这个理论有更深刻的认识。</p>
<h2 id="婚姻的周期"><a href="#婚姻的周期" class="headerlink" title="婚姻的周期"></a>婚姻的周期</h2><ol>
<li>幻想期(理想化阶段)，在有孩子之前，因人而异，对未来充满了美好的憧憬</li>
<li>生产阶段，一般是有孩子之后，孩子不是很大的时候，这个时候是最容易出轨的一个时期，因为这个时候最容易出现情感三角。但是也会存在在这个阶段双方关系更加亲密的。</li>
<li>第二次离家，指孩子青春期有了独立意识这一阶段，所谓的第二次离家，指的是独立于家庭，而第一次对应夫妻双方。在这一阶段，夫妻双方在第一次离家被搁置的问题，有可能会再次出现，并演变成伴侣的冲突</li>
<li>伴侣重新整合，指孩子彻底离开这个家里独自生活，这个时候伴侣又回归了二人世界</li>
</ol>
<p>各个阶段，都有具体的访谈伴侣，让读者更直观的感受到，这几个阶段的问题。</p>
<h2 id="夫妻相处的五种层次"><a href="#夫妻相处的五种层次" class="headerlink" title="夫妻相处的五种层次"></a>夫妻相处的五种层次</h2><ul>
<li>第五层次：悖论。认为亲密和独立是两个完全相悖的概念且是极其危险的，所以这一层次的人经常会在亲密和独立上反复横跳，及不能接受远离伴侣的孤独，但是与伴侣走近之后又立刻要开溜(呃，听起来有点像渣……)</li>
<li>第四层次：投射性认同。大部分的夫妻在这一层次上，与第五层次不同的是，第四层次能意识到对亲密和独立的需要，所以不会横跳，但是会彼此借用投射性认同形成合谋，让关系走到一个不太平衡的模式上</li>
<li>第三层次：有意识地剥离。简单来说就是能意识到模式中存在投射性认同，想做出改变，第四层次意识不到。</li>
<li>第二层次：容忍矛盾。意识到投射性认同，并可以内化自身的矛盾，避免投射给伴侣。</li>
<li>第一层次：一体化。亲密和独立都是极其安全的且是互相提升的状态，双方是一体的，无论是选择亲密还是独立，双方都不会认为这是一种冲突。</li>
</ul>
<p>其实回头来看，这五个层次其实代表了双方对于亲密和独立的界定，就像我之前说的，伴侣之间的矛盾本质是双方对亲密与自主的界定存在的矛盾。值得一提的是，大多数的关系在第二到第四层次其实会存在不断变化，可能一阵子是第四层次，但是意识到了就上升，也可能本来是第二层次，但是自己消化不了了，开始投射，下降了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上只是给我印象很深刻的点，但实际上这本书无一字废话，基本每一章都能给我眼前一亮的感觉。而本书又不会只谈理论不谈实际，也提供了一些具有可操作性的练习，来扭转糟糕的伴侣模式。可以说是从理论到实践都非常全面的书籍，本来内容就已经很有料了，然后书里的访谈描写的真是太细致了，会把访谈时人物的动作、神态都详尽的描述出来，就好像在看访谈录像一样。最后用三个关键词来评价：不可多得、相见恨晚、值得二刷。</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>aria2-pro 下载文件没有权限操作的解决办法</title>
    <url>/2022/07/11/qnap-aria2-pro-file-permission/</url>
    <content><![CDATA[<p>最近折腾 NAS，搞远程下载阿里云盘上的资源，用到了 Aria2。用的是 p3terx 的<a href="https://p3terx.com/archives/docker-aria2-pro.html">Aria2 Pro - 更好用的 Aria2 Docker 容器镜像</a>，属实是方便，但是发现下载之后的文件我没法移动文件，都是失败。就看了下权限，都是644。</p>
<span id="more"></span>

<p>解决方法：</p>
<ul>
<li>SSH 进入 NAS</li>
<li>执行命令 <code>docker exec -it aria2-pro-1 bash</code> 进入镜像(这里的 aria2-pro-1 是安装镜像的时候镜像名，威联通默认都是原名字后 -1 )</li>
<li>修改 run 文件中 <code>umask $&#123;UMASK_SET:-022&#125;</code> 为 <code>umask $&#123;UMASK_SET:-000&#125;</code>，然后保存。</li>
<li><code>exit</code>退出镜像</li>
<li>重启镜像</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>QNAP</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt源码笔记】从WinMain说起</title>
    <url>/2016/07/24/qt-source-begin_with_WinMain/</url>
    <content><![CDATA[<p>Qt在各个平台下都是对平台API进行了一些包装。Windows下是对Win32API的封装。如果是Windows平台的GUI Application就一定是从<code>WinMain</code>开始。</p>
<p>不难发现<code>WinMain</code>就在<strong>qtmain_win.cpp</strong>中。</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> APIENTRY <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, LPSTR <span class="comment">/*cmdParamarg*/</span>, <span class="type">int</span> <span class="comment">/* cmdShow */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    <span class="type">wchar_t</span> **argvW = <span class="built_in">CommandLineToArgvW</span>(<span class="built_in">GetCommandLineW</span>(), &amp;argc);</span><br><span class="line">    <span class="keyword">if</span> (!argvW)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> **argv = <span class="keyword">new</span> <span class="type">char</span> *[argc + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line">        argv[i] = <span class="built_in">wideToMulti</span>(CP_ACP, argvW[i]);</span><br><span class="line">    argv[argc] = Q_NULLPTR;</span><br><span class="line">    <span class="built_in">LocalFree</span>(argvW);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> exitCode = <span class="built_in">main</span>(argc, argv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc &amp;&amp; argv[i]; ++i)</span><br><span class="line">        <span class="keyword">delete</span> [] argv[i];</span><br><span class="line">    <span class="keyword">delete</span> [] argv;</span><br><span class="line">    <span class="keyword">return</span> exitCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里的<code>WinMain</code>仅仅充当一个入口，所有对命令行参数 这些 都交由<code>main</code>来处理。而这个<code>main</code>就是我们在自己的主程序中写的<code>main</code>。</p>
<p>入口找到以后，在Windows下的程序还有一个很重要的东西，那就是消息循环。Win32中经典的<code>PeekMessage()</code>、<code>DispatchMessage()</code>和<code>TranslateMessage()</code>。这些东西在程序中注册的回调函数中被调用，用来处理和解析消息。Qt本身也要依赖这些，只不过在上边进行了一些封装。调到我们自己的程序里看到的就是<code>winEvent()</code>或者是一些<code>QEvent</code>了。</p>
<p>我们写Qt程序的时候，一个很常见的套路是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argv, char **args)</span><br><span class="line">&#123;</span><br><span class="line">    QApplication app(argv, args);</span><br><span class="line">    //todo...</span><br><span class="line">    return app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个回调函数就是在<code>app.exec()</code>中被注册(准确的说回调函数是由在这个方法中调用的其他方法注册)。不难找到一个叫做<strong>qeventdispatcher_win.cpp</strong>文件，名字已经很明确了，就是处理Qt事件的。我们会找到一个类<code>QEventDispatcherWin32</code>。可以发现一个<code>processEvents()</code>方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QEventDispatcherWin32::processEvents</span><span class="params">(QEventLoop::ProcessEventsFlags flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_D</span>(QEventDispatcherWin32);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;internalHwnd) &#123;</span><br><span class="line">        <span class="built_in">createInternalHwnd</span>();</span><br><span class="line">        <span class="built_in">wakeUp</span>(); <span class="comment">// trigger a call to sendPostedEvents()</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        DWORD waitRet = <span class="number">0</span>;</span><br><span class="line">        HANDLE pHandles[MAXIMUM_WAIT_OBJECTS - <span class="number">1</span>];</span><br><span class="line">        QVarLengthArray&lt;MSG&gt; processedTimers;</span><br><span class="line">        <span class="keyword">while</span> (!d-&gt;interrupt) &#123;</span><br><span class="line">            DWORD nCount = d-&gt;winEventNotifierList.<span class="built_in">count</span>();</span><br><span class="line">            <span class="built_in">Q_ASSERT</span>(nCount &lt; MAXIMUM_WAIT_OBJECTS - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            MSG msg;</span><br><span class="line">            <span class="type">bool</span> haveMessage;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; QEventLoop::ExcludeUserInputEvents) &amp;&amp; !d-&gt;queuedUserInputEvents.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="comment">// process queued user input events</span></span><br><span class="line">                haveMessage = <span class="literal">true</span>;</span><br><span class="line">                msg = d-&gt;queuedUserInputEvents.<span class="built_in">takeFirst</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!(flags &amp; QEventLoop::ExcludeSocketNotifiers) &amp;&amp; !d-&gt;queuedSocketEvents.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="comment">// process queued socket events</span></span><br><span class="line">                haveMessage = <span class="literal">true</span>;</span><br><span class="line">                msg = d-&gt;queuedSocketEvents.<span class="built_in">takeFirst</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                haveMessage = <span class="built_in">PeekMessage</span>(&amp;msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE);</span><br><span class="line">                <span class="keyword">if</span> (haveMessage) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((flags &amp; QEventLoop::ExcludeUserInputEvents)</span><br><span class="line">                        &amp;&amp; ((msg.message &gt;= WM_KEYFIRST</span><br><span class="line">                             &amp;&amp; msg.message &lt;= WM_KEYLAST)</span><br><span class="line">                            || (msg.message &gt;= WM_MOUSEFIRST</span><br><span class="line">                                &amp;&amp; msg.message &lt;= WM_MOUSELAST)</span><br><span class="line">                            || msg.message == WM_MOUSEWHEEL</span><br><span class="line">                            || msg.message == WM_MOUSEHWHEEL</span><br><span class="line">                            || msg.message == WM_TOUCH</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_GESTURES</span></span><br><span class="line">                            || msg.message == WM_GESTURE</span><br><span class="line">                            || msg.message == WM_GESTURENOTIFY</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                            || msg.message == WM_CLOSE)) &#123;</span><br><span class="line">                        <span class="comment">// queue user input events for later processing</span></span><br><span class="line">                        d-&gt;queuedUserInputEvents.<span class="built_in">append</span>(msg);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (haveMessage) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">filterNativeEvent</span>(<span class="built_in">QByteArrayLiteral</span>(<span class="string">&quot;windows_generic_MSG&quot;</span>), &amp;msg, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">                    <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            retVal = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// still nothing - wait for message or signalled objects</span></span><br><span class="line">        canWait = (!retVal</span><br><span class="line">                   &amp;&amp; !d-&gt;interrupt</span><br><span class="line">                   &amp;&amp; (flags &amp; QEventLoop::WaitForMoreEvents));</span><br><span class="line">        <span class="keyword">if</span> (canWait) &#123;</span><br><span class="line">            DWORD nCount = d-&gt;winEventNotifierList.<span class="built_in">count</span>();</span><br><span class="line">            <span class="built_in">Q_ASSERT</span>(nCount &lt; MAXIMUM_WAIT_OBJECTS - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="type">int</span>)nCount; i++)</span><br><span class="line">                pHandles[i] = d-&gt;winEventNotifierList.<span class="built_in">at</span>(i)-&gt;<span class="built_in">handle</span>();</span><br><span class="line"></span><br><span class="line">            <span class="function">emit <span class="title">aboutToBlock</span><span class="params">()</span></span>;</span><br><span class="line">            waitRet = <span class="built_in">MsgWaitForMultipleObjectsEx</span>(nCount, pHandles, INFINITE, QS_ALLINPUT, MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);</span><br><span class="line">            <span class="function">emit <span class="title">awake</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (waitRet - WAIT_OBJECT_0 &lt; nCount) &#123;</span><br><span class="line">                d-&gt;<span class="built_in">activateEventNotifier</span>(d-&gt;winEventNotifierList.<span class="built_in">at</span>(waitRet - WAIT_OBJECT_0));</span><br><span class="line">                retVal = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (canWait);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较长，省略了一些暂时不关注的，在这里我们可以看到我们最熟悉的Win32的消息枚举和方法。现在问题来了<code>DispatchMessage()</code>以后，程序的调用会走到我们注册的回调函数，由我们自己来处理消息。所以要找到这个回调。</p>
<p>Qt的这个回调函数是<code>qt_internal_proc()</code>。那下一个问题就是在哪里注册的这个回调函数。<br>这个可以回顾一下Win32程序的一般套路：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WNDCLASSEX wc;</span><br><span class="line">HWND hwnd;</span><br><span class="line">MSG Msg;</span><br><span class="line"><span class="comment">//Step 1: Registering the Window Class</span></span><br><span class="line">wc.cbSize        = <span class="built_in">sizeof</span>(WNDCLASSEX);</span><br><span class="line">wc.style         = <span class="number">0</span>;</span><br><span class="line">wc.lpfnWndProc   = WndProc;</span><br><span class="line">wc.cbClsExtra    = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra    = <span class="number">0</span>;</span><br><span class="line">wc.hInstance     = hInstance;</span><br><span class="line">wc.hIcon         = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">wc.hCursor       = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">wc.lpszMenuName  = <span class="literal">NULL</span>;</span><br><span class="line">wc.lpszClassName = g_szClassName;</span><br><span class="line">wc.hIconSm       = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">RegisterClassEx</span>(&amp;wc))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">&quot;Window Registration Failed!&quot;</span>, <span class="string">&quot;Error!&quot;</span>,</span><br><span class="line">        MB_ICONEXCLAMATION | MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要写一个Win32的程序，都要先注册一个<code>Windows Class</code>,就是在<code>lpfnWndProc</code>中指明我们的回调方法。再回过头去看<code>processEvents()</code>方法中<code>createInternalHwnd()</code>的调用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QEventDispatcherWin32::createInternalHwnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_D</span>(QEventDispatcherWin32);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;internalHwnd)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    d-&gt;internalHwnd = <span class="built_in">qt_create_internal_window</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">installMessageHook</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start all normal timers</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d-&gt;timerVec.<span class="built_in">count</span>(); ++i)</span><br><span class="line">        d-&gt;<span class="built_in">registerTimer</span>(d-&gt;timerVec.<span class="built_in">at</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到一个名叫<code>qt_create_internal_window()</code>的方法，顾名思义。在此方法中会获取一个<code>QWindowsMessageWindowClassContext</code>,看一下他的构造函数，一目了然:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWindowsMessageWindowClassContext::<span class="built_in">QWindowsMessageWindowClassContext</span>()</span><br><span class="line">    : <span class="built_in">atom</span>(<span class="number">0</span>), <span class="built_in">className</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// make sure that multiple Qt&#x27;s can coexist in the same process</span></span><br><span class="line">    <span class="type">const</span> QString qClassName = <span class="built_in">QStringLiteral</span>(<span class="string">&quot;QEventDispatcherWin32_Internal_Widget&quot;</span>)</span><br><span class="line">        + QString::<span class="built_in">number</span>(<span class="built_in">quintptr</span>(qt_internal_proc));</span><br><span class="line">    className = <span class="keyword">new</span> <span class="type">wchar_t</span>[qClassName.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line">    qClassName.<span class="built_in">toWCharArray</span>(className);</span><br><span class="line">    className[qClassName.<span class="built_in">size</span>()] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc;</span><br><span class="line">    wc.style = <span class="number">0</span>;</span><br><span class="line">    wc.lpfnWndProc = qt_internal_proc;</span><br><span class="line">    wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">    wc.hInstance = <span class="built_in">qWinAppInst</span>();</span><br><span class="line">    wc.hIcon = <span class="number">0</span>;</span><br><span class="line">    wc.hCursor = <span class="number">0</span>;</span><br><span class="line">    wc.hbrBackground = <span class="number">0</span>;</span><br><span class="line">    wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">    wc.lpszClassName = className;</span><br><span class="line">    atom = <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line">    <span class="keyword">if</span> (!atom) &#123;</span><br><span class="line">        <span class="built_in">qErrnoWarning</span>(<span class="string">&quot;%s RegisterClass() failed&quot;</span>, <span class="built_in">qPrintable</span>(qClassName));</span><br><span class="line">        <span class="keyword">delete</span> [] className;</span><br><span class="line">        className = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难发现回调函数<code>qt_internal_proc()</code>就是在这里注册的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT QT_WIN_CALLBACK <span class="title">qt_internal_proc</span><span class="params">(HWND hwnd, UINT message, WPARAM wp, LPARAM lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message == WM_NCCREATE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    msg.hwnd = hwnd;</span><br><span class="line">    msg.message = message;</span><br><span class="line">    msg.wParam = wp;</span><br><span class="line">    msg.lParam = lp;</span><br><span class="line">    QAbstractEventDispatcher* dispatcher = QAbstractEventDispatcher::<span class="built_in">instance</span>();</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!dispatcher) &#123;</span><br><span class="line">        <span class="keyword">if</span> (message == WM_TIMER)</span><br><span class="line">            <span class="built_in">KillTimer</span>(hwnd, wp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatcher-&gt;<span class="built_in">filterNativeEvent</span>(<span class="built_in">QByteArrayLiteral</span>(<span class="string">&quot;windows_dispatcher_MSG&quot;</span>), &amp;msg, &amp;result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Qt就是这样将Win32的调用包装成了自己的调用。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt源码笔记】简要说说 Qt5 中的 HighDPI 支持</title>
    <url>/2019/03/06/qt-source-highdpi/</url>
    <content><![CDATA[<p>想起之前在公司做的关于 HighDPI 的适配，在 Qt4 下可以说是比较繁琐，代码敲到手疼。早就听说 Qt5.6 开始支持了 <strong>HighDPI</strong> ，一直没机会看详细的代码。一直到开始做 <a href="https://github.com/ehnap/gal/releases">Gal</a> ,才刚好在 Qt5 下需要 HighDPI 支持。用过之后，真的感叹，用起来太方便了。故看了一下详细实现。不过比较遗憾的是代码中有一个小瑕疵。</p>
<span id="more"></span>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>其实想得到 Qt 给予的 HighDPI 支持，是非常之简单。只要在 <code>QApplication</code> 构造之前，开启 <code>Qt::AA_EnableHighDpiScaling</code>  这个属性。其实在代码中使用这个属性，等于环境中开启 <code> QT_AUTO_SCREEN_SCALE_FACTOR</code> 环境变量。还有另外的环境变量支持其他的 HighDPI 功能。这个参考文档即可</p>
<p>这里有一个小 <strong>tip</strong> ：HighDPI 只是是根据显示器的像素密度来调整大小。在 Qt 中，用过 <code>QFont</code> 的人都会知道。<code>QFont</code> 中有两个方法：<code>setPixelSize</code>、<code>setPointSize</code>很多人对此不是很明白，为什么要设置这两个方法。这里便可以找到答案。设置字体的<em>Pixel Size</em>，则会根据显示器的像素密度去改变字体大小；而设置字体的<em>Point Size</em>则不会更改，因为<em>Point Size</em>是基于显示器的物理单元。</p>
<p>关于 HighDPI ，一个比较良好的代码习惯，其实在 Qt 的 HighDPI 文档部分中有提到：</p>
<blockquote>
<ul>
<li>Always use the qreal versions of the QPainter drawing API.</li>
<li>Size windows and dialogs in relation to the screen size.</li>
<li>Replace hard-coded sizes in layouts and drawing code by values calculated from font metrics or screen size.</li>
</ul>
</blockquote>
<p>总而言之，使用的时候只要一个开关即可开启 HighDPI 支持，这一点让我还是十分好奇的。迫不及待地翻看了源码。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>其实关于 HighDPI 的代码，基本就在两部分中。</p>
<h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>其中一部分在 <strong>qtbase\src\gui\kernel</strong> 目录下 <code>qhighdpiscaling_p.h</code>、<code>qhighdpiscaling.cpp</code>这两个文件中的 <code>QHighDpiScaling</code> 类里。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Q_GUI_EXPORT</span> QHighDpiScaling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">initHighDpiScaling</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">updateHighDpiScaling</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setGlobalFactor</span><span class="params">(qreal factor)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setScreenFactor</span><span class="params">(QScreen *window, qreal factor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isActive</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_active; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> qreal <span class="title">factor</span><span class="params">(<span class="type">const</span> QWindow *window)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> qreal <span class="title">factor</span><span class="params">(<span class="type">const</span> QScreen *screen)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> qreal <span class="title">factor</span><span class="params">(<span class="type">const</span> QPlatformScreen *platformScreen)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> QPoint <span class="title">origin</span><span class="params">(<span class="type">const</span> QScreen *screen)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> QPoint <span class="title">origin</span><span class="params">(<span class="type">const</span> QPlatformScreen *platformScreen)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> QPoint <span class="title">mapPositionFromNative</span><span class="params">(<span class="type">const</span> QPoint &amp;pos, <span class="type">const</span> QPlatformScreen *platformScreen)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> QPoint <span class="title">mapPositionToNative</span><span class="params">(<span class="type">const</span> QPoint &amp;pos, <span class="type">const</span> QPlatformScreen *platformScreen)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> QDpi <span class="title">logicalDpi</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> qreal <span class="title">screenSubfactor</span><span class="params">(<span class="type">const</span> QPlatformScreen *screen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> qreal m_factor;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> m_active;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> m_usePixelDensity;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> m_globalScalingActive;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> m_pixelDensityScalingActive;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> m_screenFactorSet;</span><br><span class="line">    <span class="type">static</span> QDpi m_logicalDpi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类最大的特色可以说就是纯静态的了。不过按照逻辑来说，也是合理的。其中 <code>initHighDpiScaling()</code>、<code>updateHighDpiScaling()</code>可以说是两个比较重要的方法了，这两个方法掌管着整个 HighDPI 支持的命脉。其实里边的内容只是一些方法的简单包装。只看堆栈调用的话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;   Qt5Guid.dll!QHighDpiScaling::initHighDpiScaling() 行 254	C++</span><br><span class="line"> 	Qt5Guid.dll!QGuiApplicationPrivate::createPlatformIntegration() 行 1301	C++</span><br><span class="line"> 	Qt5Guid.dll!QGuiApplicationPrivate::createEventDispatcher() 行 1403	C++</span><br><span class="line"> 	Qt5Widgetsd.dll!QApplicationPrivate::createEventDispatcher() 行 187	C++</span><br><span class="line"> 	Qt5Cored.dll!QCoreApplicationPrivate::init() 行 859	C++</span><br><span class="line"> 	Qt5Guid.dll!QGuiApplicationPrivate::init() 行 1431	C++</span><br><span class="line"> 	Qt5Widgetsd.dll!QApplicationPrivate::init() 行 569	C++</span><br><span class="line"> 	Qt5Widgetsd.dll!QApplication::QApplication(int &amp; argc, char * * argv, int _internal) 行 556	C++</span><br></pre></td></tr></table></figure>
<p>可以看出，在 <code>QApplication</code> 构造的时候，会走入 HighDPI 的相关逻辑，这也是文档中要求要在构造之前开启开关是一致的，因为构造的时候就要检查这个属性的状态。</p>
<p>实际计算缩放因子的方法，应该是这个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">QHighDpiScaling::screenSubfactor</span><span class="params">(<span class="type">const</span> QPlatformScreen *screen)</span></span></span><br></pre></td></tr></table></figure>
<p>逻辑也是十分简单了。不用做过多解释。不过这里边有一个<code>pixelDensity()</code>的调用，内容还挺有意思的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">QWindowsScreen::pixelDensity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// QTBUG-49195: Use logical DPI instead of physical DPI to calculate</span></span><br><span class="line">    <span class="comment">// the pixel density since it is reflects the Windows UI scaling.</span></span><br><span class="line">    <span class="comment">// High DPI auto scaling should be disabled when the user chooses</span></span><br><span class="line">    <span class="comment">// small fonts on a High DPI monitor, resulting in lower logical DPI.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qMax</span>(<span class="number">1</span>, <span class="built_in">qRound</span>(<span class="built_in">logicalDpi</span>().first / <span class="number">96</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里边的逻辑可以明显地看到，当我们在 Windows 系统下使用类似 125% 的缩放比例的时候，这里边计算到的缩放比例还是 1。然后去 Qt BugReport 看了一下。<a href="https://bugreports.qt.io/browse/QTBUG-70721">QTBUG-70721</a> 就是这个问题。</p>
<h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>上边说到，代码实现有两部分，另外一部分则是在 <strong>qtbase\src\widgets\styles</strong> 目录下的<code>qstylehelper_p.h</code>、<code>qstylehelper.cpp</code>中的<code>QStyleHelper</code>命名空间中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">dpiScaled</span><span class="params">(qreal value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_MAC</span></span><br><span class="line">    <span class="comment">// On mac the DPI is always 72 so we should not scale it</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> qreal scale = <span class="built_in">qreal</span>(<span class="built_in">qt_defaultDpiX</span>()) / <span class="number">96.0</span>;</span><br><span class="line">    <span class="keyword">return</span> value * scale;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 Qt4 下有做过 HighDPI 的相关逻辑，想必对这个方法是不陌生的。至此基本上 Qt HighDPI 支持的代码逻辑基本找全。</p>
<h2 id="小瑕疵"><a href="#小瑕疵" class="headerlink" title="小瑕疵"></a>小瑕疵</h2><p>上边我提到过代码中的小瑕疵。就在上边那段代码上。不难看出这个<code>scale</code>是一个函数中的静态变量，后续对这个函数再次调用已经不改变<code>scale</code>的值了。</p>
<p>看到这里会觉得，大概是个隐患，然后再来看<code>qt_defaultDpiX()</code>这个方法：(这个方法在 <strong>qtbase\src\gui\text</strong> 目录的<code>qfont.cpp</code>文件中)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Q_GUI_EXPORT <span class="type">int</span> <span class="title">qt_defaultDpiX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QCoreApplication::<span class="built_in">instance</span>()-&gt;<span class="built_in">testAttribute</span>(Qt::AA_Use96Dpi))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">96</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!qt_is_gui_used)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">75</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qRound</span>(screen-&gt;<span class="built_in">logicalDotsPerInchX</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PI has not been initialised, or it is being initialised. Give a default dpi</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里也就只有第三个 if 会导致这个方法的返回值不确定。</p>
<p>那很自然的就会想到，如果当 <code>dpiScaled</code> 调用的时候第三个 if 不起作用，那将是可怕的结果。所以紧接着探究这个 <code>screen</code> 。这部分过程略过，直接说结论。screen 能正常取到的前提是 <code>QGuiApplicationPrivate::screen_list</code> 这个列表是有内容的。而这个列表第一次被添加的时机堆栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;	Qt5Guid.dll!QPlatformIntegration::screenAdded(QPlatformScreen * ps, bool isPrimary) 行 478	C++</span><br><span class="line"> 	qwindowsd.dll!QWindowsIntegration::emitScreenAdded(QPlatformScreen * s, bool isPrimary) 行 110	C++</span><br><span class="line"> 	qwindowsd.dll!QWindowsScreenManager::handleScreenChanges() 行 546	C++</span><br><span class="line"> 	qwindowsd.dll!QWindowsIntegration::QWindowsIntegration(const QStringList &amp; paramList) 行 276	C++</span><br><span class="line"> 	qwindowsd.dll!QWindowsGdiIntegration::QWindowsGdiIntegration(const QStringList &amp; paramList) 行 59	C++</span><br><span class="line"> 	qwindowsd.dll!QWindowsIntegrationPlugin::create(const QString &amp; system, const QStringList &amp; paramList, int &amp; __formal, char * * __formal) 行 114	C++</span><br><span class="line"> 	Qt5Guid.dll!qLoadPlugin&lt;QPlatformIntegration,QPlatformIntegrationPlugin,QStringList const &amp; __ptr64,int &amp; __ptr64,char * __ptr64 * __ptr64 &amp; __ptr64&gt;(const QFactoryLoader * loader, const QString &amp; key, const QStringList &amp; &lt;args_0&gt;, int &amp; &lt;args_1&gt;, char * * &amp; &lt;args_2&gt;) 行 108	C++</span><br><span class="line"> 	Qt5Guid.dll!QPlatformIntegrationFactory::create(const QString &amp; platform, const QStringList &amp; paramList, int &amp; argc, char * * argv, const QString &amp; platformPluginPath) 行 72	C++</span><br><span class="line"> 	Qt5Guid.dll!init_platform(const QString &amp; pluginNamesWithArguments, const QString &amp; platformPluginPath, const QString &amp; platformThemeName, int &amp; argc, char * * argv) 行 1179	C++</span><br><span class="line"> 	Qt5Guid.dll!QGuiApplicationPrivate::createPlatformIntegration() 行 1383	C++</span><br><span class="line"> 	Qt5Guid.dll!QGuiApplicationPrivate::createEventDispatcher() 行 1403	C++</span><br><span class="line"> 	Qt5Widgetsd.dll!QApplicationPrivate::createEventDispatcher() 行 187	C++</span><br><span class="line"> 	Qt5Cored.dll!QCoreApplicationPrivate::init() 行 859	C++</span><br><span class="line"> 	Qt5Guid.dll!QGuiApplicationPrivate::init() 行 1431	C++</span><br><span class="line"> 	Qt5Widgetsd.dll!QApplicationPrivate::init() 行 569	C++</span><br><span class="line"> 	Qt5Widgetsd.dll!QApplication::QApplication(int &amp; argc, char * * argv, int _internal) 行 556	C++</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从这里可以看到，是在 <code>QApplication</code> 构造的时候。</p>
<p>所以可以得出一个结论，当在<code>QApplication</code>构造的之前调用<code>QStyleHelper::dpiScaled</code>得到的结果则可能不是准确的，也会导致，在以后得到结果都是错误的。没有经验的人也许会觉得在<code>QApplication</code>构造之前调用这个是没意义的，所以认为这个调用并不常见。此处我举一例以供参考。</p>
<p>很多人习惯提前定义一些比较固定的量，在某个 cpp 中，也许我们能看到这样一种代码，它有可能是直接写成，也有可能在实现 HighDPI 过程中更改而成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    qreal testa_width = QStyleHelper::<span class="built_in">dpiScaled</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> qreal testb_width = QStyleHelper::<span class="built_in">dpiScaled</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>如果在代码的上方出现了这种，则它们就属于是一种比较可怕的代码，可以影响全局调用<code>dpiScaled</code>得不到正确结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不过即使有一点点小瑕疵，但是 Qt 对 HighDPI 的实现，以及调用设计还是有很多值得借鉴之处的。本文也只是对 Qt HighDPI 支持比较简要的分析，还有很多细节，限于篇幅，并没有展开来说……</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt源码笔记】浅谈 Qt 中的控件绘制</title>
    <url>/2018/12/10/qt-source-paint-control/</url>
    <content><![CDATA[<p>在工作中经常要根据 UI 提供的稿子做自绘控件，而且在新项目中，我自己基于 Qt 做了一套项目自用控件库，还会涉及到换肤，所以对 Qt 的控件绘制，着重的研究了一下。看过代码之后，觉得 Qt 项目本身，确实是做 UI 发家，绘制流程清晰，可以说是做界面的范本了。将流程梳理记录一下。</p>
<span id="more"></span>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>对于自绘控件的分类，我将其分为两大类：</p>
<ul>
<li>基于 Qt 控件类派生</li>
<li>基于 QWidget 派生</li>
</ul>
<p>除非是行为跟 Qt 本身的控件相差太多，或者是缺少需要的交互逻辑，否则的话尽可能从 Qt 现有的控件类派生，这是一条基本的原则。因为绘制上来说重写 <code>paintEvent</code> 方法，基本就可以达到想要的目的，而控件类本身会提供一些现成的控件逻辑，这样会大大减少开发难度。</p>
<h2 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h2><p>其实提起绘制流程来说，无非就是重写 <code>paintEvent</code> 方法。但是如果要做一整套 UI 库，没有结构，都在 <code>paintEvent</code> 里边写死，在后期加换肤，或者是在代码整洁度上都会大打折扣。 Qt 本身的控件绘制，就可以给我们很大的启示。以绘制事件方法代码最简单的 QPushbutton 为例，足见一斑：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPushButton::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QStylePainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    QStyleOptionButton option;</span><br><span class="line">    <span class="built_in">initStyleOption</span>(&amp;option);</span><br><span class="line">    p.<span class="built_in">drawControl</span>(QStyle::CE_PushButton, option);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以简单理解为两个流程：</p>
<ol>
<li>装配绘制必要上下文</li>
<li>绘制</li>
</ol>
<p>Qt 考虑到对于按钮样式，开发者有着自己的需求，而对于逻辑状态可能开发者可以用现成的。所以 <code>initStyleOption</code> 是一个保护方法，如果开发者没有对按钮状态的特殊要求，用这个方法，就可以把图标，按钮的点击状态什么的放进这个 <code>option</code> 中。在绘制的时候直接拿来用。</p>
<p>而下边的绘制，可以看到这里是用了 <code>QStylePainter</code> 而不是常规的 <code>QPainter</code>。不过 <code>QStylePainter</code> 和 <code>QPainter</code> 差别不大，前者只是在里边保存了当前 <code>QWidget::style()</code>的指针。所以这段代码改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">QStyleOptionButton option;</span><br><span class="line"><span class="built_in">initStyleOption</span>(&amp;option);</span><br><span class="line"><span class="built_in">style</span>()-&gt;<span class="built_in">drawControl</span>(QStyle::CE_PushButton, option, &amp;p, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>也是一样的。如果你翻看其他控件，比方说 <code>QMenu</code> 就是下边这种用法，可能是开发人员的不同习惯，但是他们逻辑是一致的。</p>
<p>Qt 的绘制精髓就在于此。对于绘制， Qt 控件是交给 style 来管理的。打开源码路径 <strong>qtbase\src\widgets\styles</strong> 这里边保存了 Qt 绘制的基本样式。为什么说是基本样式呢，因为还有一部分 <strong>qtbase\src\plugins\styles</strong> 在这个目录下，这所有的加一起就是全部样式了。话说回来， Qt 正是因为将绘制逻辑都保存在了 style 中，所以 Qt 才可以在不同平台都表现的像一个原生控件一样，“千平台千面”。</p>
<p>走到这里，就不得不一探 <code>QStyle</code> 的究竟了。<code>QStyle</code> 是一个抽象类，头文件因为包含了太多枚举，所以特别长，就不粘了。里边关于绘制的几个方法是纯虚的，在绘制方法中，通过传进去的枚举类型，来找到对应控件的绘制逻辑。除了绘制方法，还有一些是计算绘制区域大小的方法，以及 <em>hitTest</em> 获取子控件的方法。这就是整个 Qt 绘制的大本营了。而对于 Qt 控件的实际绘制逻辑，其实也对做自绘控件库也十分有帮助，不过既然是浅谈，也就不再罗嗦。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt源码笔记】深谈 Qt 绘制</title>
    <url>/2018/12/19/qt-source-paint/</url>
    <content><![CDATA[<p>之前写了一篇 <a href="https://ehnap.me/2018/12/10/qt-source-paint-control/">浅谈Qt控件绘制</a> 。之所以叫浅谈是因为调用都是比较表层的调用。其实 Qt 的绘制，可以说用 Qt 的人都有用到，但是对于绘制底层，了解的人并不见得很多。我其实之前也是云山雾罩，从来没有深究过。所以想着知其然还是要知其所以然。</p>
<span id="more"></span>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在 Windows 平台 默认的 Qt 绘制，最终到底层，是直接调用<strong>指令集指令</strong>的，这有别于我最初的猜测，我以为是用 Windows API 。这着实让我吃了一惊。这让我对 Qt 的性能又放心了一些。</p>
<h2 id="探究过程"><a href="#探究过程" class="headerlink" title="探究过程"></a>探究过程</h2><p>其实研究这个，比其他的更好溯源。附上三段堆栈信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	Qt5Guid.dll!BLEND_SOURCE_OVER_ARGB32_AVX2(unsigned int * dst, const unsigned int * src, const int length) 行 184	C++</span><br><span class="line">	Qt5Guid.dll!qt_blend_argb32_on_argb32_avx2(unsigned char * destPixels, int dbpl, const unsigned char * srcPixels, int sbpl, int w, int h, int const_alpha) 行 253	C++</span><br><span class="line">	Qt5Guid.dll!QRasterPaintEnginePrivate::drawImage(const QPointF &amp; pt, const QImage &amp; img, void(*)(unsigned char *, int, const unsigned char *, int, int, int, int) func, const QRect &amp; clip, int alpha, const QRect &amp; sr) 行 1057	C++</span><br><span class="line">	Qt5Guid.dll!QRasterPaintEngine::drawImage(const QPointF &amp; p, const QImage &amp; img) 行 2250	C++</span><br><span class="line">	Qt5Guid.dll!QRasterPaintEngine::drawPixmap(const QPointF &amp; pos, const QPixmap &amp; pixmap) 行 2128	C++</span><br><span class="line">	Qt5Guid.dll!QPainter::drawPixmap(const QPointF &amp; p, const QPixmap &amp; pm) 行 5079	C++</span><br><span class="line">	Qt5Guid.dll!QPainter::drawPixmap(const QPoint &amp; p, const QPixmap &amp; pm) 行 796	C++</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line">Qt5Guid.dll!alphargbblend_argb32(unsigned int * dst, unsigned int coverage, const QRgba64 &amp; srcLinear, unsigned int src, const QColorProfile * colorProfile) 行 5771	C++</span><br><span class="line">	Qt5Guid.dll!qt_alphargbblit_argb32(QRasterBuffer * rasterBuffer, int x, int y, const QRgba64 &amp; color, const unsigned int * src, int mapWidth, int mapHeight, int srcStride, const QClipData * clip, bool useGammaCorrection) 行 5878	C++</span><br><span class="line">	Qt5Guid.dll!QRasterPaintEngine::alphaPenBlt(const void * src, int bpl, int depth, int rx, int ry, int w, int h, bool useGammaCorrection) 行 2723	C++</span><br><span class="line">	Qt5Guid.dll!QRasterPaintEngine::drawCachedGlyphs(int numGlyphs, const unsigned int * glyphs, const QFixedPoint * positions, QFontEngine * fontEngine) 行 2976	C++</span><br><span class="line">	Qt5Guid.dll!QRasterPaintEngine::drawTextItem(const QPointF &amp; p, const QTextItem &amp; textItem) 行 3183	C++</span><br><span class="line">	Qt5Guid.dll!QPainterPrivate::drawTextItem(const QPointF &amp; p, const QTextItem &amp; _ti, QTextEngine * textEngine) 行 6531	C++</span><br><span class="line">	Qt5Guid.dll!QTextLine::draw(QPainter * p, const QPointF &amp; pos, const QTextLayout::FormatRange * selection) 行 2615	C++</span><br><span class="line">	Qt5Guid.dll!qt_format_text(const QFont &amp; fnt, const QRectF &amp; _r, int tf, const QTextOption * option, const QString &amp; str, QRectF * brect, int tabstops, int * ta, int tabarraylen, QPainter * painter) 行 7702	C++</span><br><span class="line">	Qt5Guid.dll!QPainter::drawText(const QRect &amp; r, int flags, const QString &amp; str, QRect * br) 行 5955	C++</span><br><span class="line"></span><br><span class="line">   -------------------</span><br><span class="line"></span><br><span class="line">Qt5Guid.dll!qt_memfill32(unsigned int * dest, unsigned int value, int count) 行 262	C++</span><br><span class="line">	Qt5Guid.dll!qt_memfill&lt;unsigned int&gt;(unsigned int * dest, unsigned int color, int count) 行 901	C++</span><br><span class="line">	Qt5Guid.dll!blend_color_argb(int count, const QT_FT_Span_ * spans, void * userData) 行 4347	C++</span><br><span class="line">	Qt5Guid.dll!qt_span_fill_clipRect(int count, const QT_FT_Span_ * spans, void * userData) 行 4229	C++</span><br><span class="line">	Qt5Guid.dll!QSpanBuffer::flushSpans() 行 112	C++</span><br><span class="line">	Qt5Guid.dll!QSpanBuffer::~QSpanBuffer() 行 87	C++</span><br><span class="line">	Qt5Guid.dll!QRasterizer::rasterizeLine(const QPointF &amp; a, const QPointF &amp; b, double width, bool squareCap) 行 1191	C++</span><br><span class="line">	Qt5Guid.dll!QRasterPaintEngine::fillRect(const QRectF &amp; r, QSpanData * data) 行 1858	C++</span><br><span class="line">	Qt5Guid.dll!QRasterPaintEngine::fillRect(const QRectF &amp; r, const QBrush &amp; brush) 行 1882	C++</span><br><span class="line">	Qt5Guid.dll!QPainter::fillRect(const QRect &amp; r, const QBrush &amp; brush) 行 6971	C++</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只要从绘制代码，单步调试即可找到指定地点。不过最终使用的指令集却并不一样。有的用 <strong>avx2</strong> 、有的则是用 <strong>sse2</strong> 。如果想探究指令集部分的使用，需要到源码目录 <strong>qtbase\src\gui\painting</strong> ，根据目录下代码文件名即可知道是哪种指令集，一目了然。</p>
<p>回过头来再看上边的那些函数调用。其实不难发现，所有的绘制在中间都必然要经过<code>QPaintEngine</code>。<code>QRasterPaintEngine</code>只不过是它的一个派生，这个后边再说。而 <code>QPaintEngine</code> 根据所要绘制的内容，来区分绘制逻辑，比方说涂色采用填充 buffer 、统一刷新的方式；字体绘制要调用字体图元相关绘制逻辑等等。</p>
<p><em>所有的表层绘制都要经过绘制引擎来向下传递绘制信息。这是 Qt 作为一个高级框架的闪光点，在其他的 Qt 模块也有类似发现，比如控件的绘制上。这样看来 Qt 这个框架能给我们的，除了代码逻辑本身，还有设计。</em></p>
<h2 id="意外收获"><a href="#意外收获" class="headerlink" title="意外收获"></a>意外收获</h2><p>在整个代码探究的过程，我发现了这样一段代码，可以说是非常惊喜了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pd-&gt;<span class="built_in">devType</span>() == QInternal::Pixmap)</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;QPixmap *&gt;(pd)-&gt;<span class="built_in">detach</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pd-&gt;<span class="built_in">devType</span>() == QInternal::Image)</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;QImage *&gt;(pd)-&gt;<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">d-&gt;engine = pd-&gt;<span class="built_in">paintEngine</span>();</span><br></pre></td></tr></table></figure>
<p>这段代码是<code>QPainter::begin()</code>中的代码。当时是在研究<code>QWidget</code>的绘制过程中，走到了这里。只看代码很难体验它的神奇之处。</p>
<p><code>pd</code> 在前边是 <code>QWidget</code> 的一个指针，当经过这个 <code>if</code> 语句之后，<code>pd</code> 就变成了一个 <code>QImage</code> 指针。这不可谓之不神奇。对于稍微对 Qt 源码有一些理解的同学对 <code>detach()</code> 并不陌生，它本是 Qt 中最常用的 <strong>Copy-on-Write</strong> 的实现。不过经常用于在类的成员方法中调用，今天看到它这种用法着实惊艳到了。至于为什么这种用法可行，这也是一个可研究的点，有时间，将其整理出来。这段代码算是研究绘制过程中的一个小礼物，这也解开了<code>QWidget</code>绘制的本质。至于<code>QWidget</code>的绘制，也是一个很有意思的东西了，以后有机会详细整理一下。</p>
<h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p>之前我说<code>QRasterPaintEngine</code>只是<code>QPaintEngine</code>的派生类。我也说 Windows 平台下默认的 Qt 绘制是使用指令集的。原因就在于默认条件下，绝大部分的<code>QPaintDevice</code>是选择用<code>QRasterPaintEngine</code>的，这里我说绝大部分是因为，我没有完整的看过所有派生自<code>QPaintDevice</code>的类的代码。而选择用何种<code>QPaintEngine</code>具体逻辑可以以<code>QImage</code>为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QPaintEngine *<span class="title">QImage::paintEngine</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!d)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;paintEngine) &#123;</span><br><span class="line">        QPaintDevice *paintDevice = <span class="built_in">const_cast</span>&lt;QImage *&gt;(<span class="keyword">this</span>);</span><br><span class="line">        QPaintEngine *paintEngine = <span class="number">0</span>;</span><br><span class="line">        QPlatformIntegration *platformIntegration = QGuiApplicationPrivate::<span class="built_in">platformIntegration</span>();</span><br><span class="line">        <span class="keyword">if</span> (platformIntegration)</span><br><span class="line">            paintEngine = platformIntegration-&gt;<span class="built_in">createImagePaintEngine</span>(paintDevice);</span><br><span class="line">        d-&gt;paintEngine = paintEngine ? paintEngine : <span class="keyword">new</span> <span class="built_in">QRasterPaintEngine</span>(paintDevice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d-&gt;paintEngine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简而言之就是取决于<code>QGuiApplicationPrivate::platformIntegration()</code>的返回值。至于这个调用相关的，那是有关 <strong>QPA</strong> 的范畴了，就不再这篇赘述了。有时间再整理 <strong>QPA</strong> 相关的内容出来。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>对于 Qt 绘制的深入探究，可以说是受益匪浅，这篇文章只是描述了冰山一角，其实整个流程比这个简要概括要高级的多。从研究 Qt 源码至今，对整个 Qt 项目的感受与评价，已和往日截然不同。而网上大部分人对 Qt 的评价，其实在我看来，无异于盲人摸象。只有对源码稍有了解的人，才知道 Qt 这个项目，对于客户端开发人员的价值。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt源码笔记】 QImage 源码探究过程中的记忆碎片</title>
    <url>/2018/11/29/qt-source-qimage-fragment/</url>
    <content><![CDATA[<p>在公司曾经做有关图片的一个新项目。当时仔细研究了一下<code>QImage</code>的源码，将一些碎片化的东西记录在了某个平台上，如今翻出来了，感觉这些内容还可以再细化细化，有时间的话，详细整理，先将以前的碎片在此记录下来。</p>
<span id="more"></span>

<ol>
<li><p>所有的创建都由内部的<code>QImageData</code>类的<code>create</code>方法实现。即使传入<code>const char*</code> ，但是在创建时依然会被转为 <strong>非 const</strong> ，而在<code>create</code>中改为使用只读标志。</p>
</li>
<li><p><code>QImageData</code> 类中出现了一种叫位域的东西，可以指定这个东西占几位：<code>uint a:1;</code></p>
</li>
<li><p>在 <code>QImage</code> 拷贝构造时，如果 <code>QImage</code> 绑定了 <code>QPaintDevice</code> 或者是内部的 <code>QImageData</code> 标记了锁，则会复制一份全新的 <code>QImage</code> ；否则两个 <code>QImage</code> 共享一个<code>QImageData</code>。值得注意的是，Qt中用到的<code>swap</code>是标准库的。</p>
</li>
<li><p><code>QImage</code>中对于<code>set</code>或者是返回 <strong>非 const</strong> 的函数中使用<code>detach()</code>来实现写时拷贝</p>
</li>
<li><p><code>QImage</code>中的高质量抖动用的是 <strong>Floyd-SteinBerg</strong> 算法</p>
</li>
<li><p><code>QImage</code>中的<code>setText()</code>可以将字符串以 UTF-8 编码储存到图片里，但是并非所有的图片格式都支持，需要用<code>QImageWriter</code>去检查一下格式是否支持才可以使用。</p>
</li>
<li><p><code>QImage</code>中的<code>bitPlaneCount()</code>可以用来判断图片的有效位，因为类似 RGB32 这种，实际上它的有效位只有24位</p>
</li>
<li><p><code>QPixmap</code>中的<code>load()</code>是有缓存的，内部用<code>QPixmapCache</code>实现缓存。用下边的 key 做索引。自己也可以使用<code>QPixmapCache</code>根据实际需要做缓存。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QString key = QLatin1String(&quot;qt_pixmap&quot;)</span><br><span class="line">                % info.absoluteFilePath()</span><br><span class="line">                % HexString&lt;uint&gt;(info.lastModified().toTime_t())</span><br><span class="line">                % HexString&lt;quint64&gt;(info.size())</span><br><span class="line">                % HexString&lt;uint&gt;(data ? data-&gt;pixelType() : QPlatformPixmap::PixmapType);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>QPixmap</code>中<code>scaled()</code>用的就是<code>QImage</code>那一套缩放方法</p>
</li>
<li><p><code>QBitmap</code>实际上是<code>QPixmap</code>的二次封装</p>
</li>
<li><p><code>QImageRead</code>本质上是一个包装了接口的类。在读图片的时候会将Qt支持的图片格式全都尝试一遍，包括 imageformat 下的插件。优先寻找最可能匹配的格式( format 这个参数)。找到后拿到这个格式的 <em>handler</em> 。每一个格式本身都会实现作为 <em>handler</em> 的必要接口，以供<code>QImageReader</code>方法调用。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt源码笔记】关于 QTimer 在 Windows 下实现的杂谈</title>
    <url>/2018/08/05/qt-source-qtimer-achieve/</url>
    <content><![CDATA[<p>关于 QTimer 的具体实现，翻看源码源于一次面试经历。被问到 QTimer 的问题，我随口说了一句：Windows 平台下是用 Windows API 实现的，然后便引起了怀疑，不过我据理力争，便也作罢。所以回来之后，就又确认了一下。</p>
<span id="more"></span>
<p>要找这个佐证就必然要从<code>start()</code>方法顺藤摸瓜。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id != INV_TIMER)    <span class="comment">// stop running timer</span></span><br><span class="line">        <span class="built_in">stop</span>();</span><br><span class="line">    nulltimer = (!inter &amp;&amp; single);</span><br><span class="line">    id = QObject::<span class="built_in">startTimer</span>(inter, Qt::<span class="built_in">TimerType</span>(type));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实证明还是走到了<code>QObject</code>中。继续顺藤摸瓜。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QObject::startTimer</span><span class="params">(<span class="type">int</span> interval, Qt::TimerType timerType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_D</span>(QObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Q_UNLIKELY</span>(interval &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>(<span class="string">&quot;QObject::startTimer: Timers cannot have negative intervals&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Q_UNLIKELY</span>(!d-&gt;threadData-&gt;<span class="built_in">hasEventDispatcher</span>())) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>(<span class="string">&quot;QObject::startTimer: Timers can only be used with threads started with QThread&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Q_UNLIKELY</span>(<span class="built_in">thread</span>() != QThread::<span class="built_in">currentThread</span>())) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>(<span class="string">&quot;QObject::startTimer: Timers cannot be started from another thread&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> timerId = d-&gt;threadData-&gt;eventDispatcher.<span class="built_in">load</span>()-&gt;<span class="built_in">registerTimer</span>(interval, timerType, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;extraData)</span><br><span class="line">        d-&gt;extraData = <span class="keyword">new</span> QObjectPrivate::ExtraData;</span><br><span class="line">    d-&gt;extraData-&gt;runningTimers.<span class="built_in">append</span>(timerId);</span><br><span class="line">    <span class="keyword">return</span> timerId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以很清楚的看到<code>registerTimer()</code>方法。不过到这里就可以很快找到方法的位置。<code>eventDispatcher</code>让我直接找到 <strong>qeventdispatcher_win.cpp</strong>。果然在这中间，发现了想要找的东西。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QEventDispatcherWin32Private::registerTimer</span><span class="params">(WinTimerInfo *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(internalHwnd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Q_Q</span>(QEventDispatcherWin32);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">calculateNextTimeout</span>(t, <span class="built_in">qt_msectime</span>());</span><br><span class="line">    uint interval = t-&gt;interval;</span><br><span class="line">    <span class="keyword">if</span> (interval == <span class="number">0u</span>) &#123;</span><br><span class="line">        <span class="comment">// optimization for single-shot-zero-timer</span></span><br><span class="line">        QCoreApplication::<span class="built_in">postEvent</span>(q, <span class="keyword">new</span> <span class="built_in">QZeroTimerEvent</span>(t-&gt;timerId));</span><br><span class="line">        ok = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval &lt; <span class="number">20u</span> || t-&gt;timerType == Qt::PreciseTimer) &#123;</span><br><span class="line">        <span class="comment">// 3/2016: Although MSDN states timeSetEvent() is deprecated, the function</span></span><br><span class="line">        <span class="comment">// is still deemed to be the most reliable precision timer.</span></span><br><span class="line">        t-&gt;fastTimerId = <span class="built_in">timeSetEvent</span>(interval, <span class="number">1</span>, qt_fast_timer_proc, <span class="built_in">DWORD_PTR</span>(t),</span><br><span class="line">                                      TIME_CALLBACK_FUNCTION | TIME_PERIODIC | TIME_KILL_SYNCHRONOUS);</span><br><span class="line">        ok = t-&gt;fastTimerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">        <span class="comment">// user normal timers for (Very)CoarseTimers, or if no more multimedia timers available</span></span><br><span class="line">        ok = <span class="built_in">SetTimer</span>(internalHwnd, t-&gt;timerId, interval, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ok)</span><br><span class="line">        <span class="built_in">qErrnoWarning</span>(<span class="string">&quot;QEventDispatcherWin32::registerTimer: Failed to create a timer&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉的 Windows API 就被发现了。如果当初我能记得 <code>QObject</code> 里边的调用细节，或许应该就在面试的让对方少些疑问了。</p>
<p>其实看到这里的逻辑，会发现一些 Qt 的小操作。</p>
<ul>
<li>一个间隔为 <strong>0</strong> 的定时器，Qt 只会发一个事件放到事件队列，不涉及系统 API 调用。</li>
<li>间隔 <strong>20ms</strong> 以下，会调用<code>timeSetEvent</code>。但是这里有两个隐患：1. <code>timeSetEvent</code>是一个已经废弃的 API；2. <code>timeSetEvent</code>虽然精度高，但是同一个进程开 <strong>16</strong> 个之后就会失败，这是一个致命伤，想避开这个问题，就要用最新的 <code>CreateTimerQueueTimer </code>，由此可见这里是偷懒了。</li>
<li>除此之外的计时器会调用 <code>SetTimer</code>。</li>
</ul>
<p>在这里，会很自然的想到，Timer 的设置是成对出现的，也就是<code>KillTimer</code> 、 <code>timeKillEvent</code>这种调用。</p>
<p>通过对 <code>QTimer</code> 机制的理解，不难想到目标代码应该从 <code>timeEvent</code> 查起。按图索骥，<code>stop()</code>。最终发现这个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QEventDispatcherWin32Private::unregisterTimer</span><span class="params">(WinTimerInfo *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;interval == <span class="number">0</span>) &#123;</span><br><span class="line">        QCoreApplicationPrivate::<span class="built_in">removePostedTimerEvent</span>(t-&gt;dispatcher, t-&gt;timerId);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;fastTimerId != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">timeKillEvent</span>(t-&gt;fastTimerId);</span><br><span class="line">        QCoreApplicationPrivate::<span class="built_in">removePostedTimerEvent</span>(t-&gt;dispatcher, t-&gt;timerId);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (internalHwnd) &#123;</span><br><span class="line">        <span class="built_in">KillTimer</span>(internalHwnd, t-&gt;timerId);</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;timerId = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!t-&gt;inTimerEvent)</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Qt 对 Windows API 的基本调用还是可信赖的，但是就是开发人员懒了一点。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt源码笔记】万般皆是int main</title>
    <url>/2018/07/28/qt-source-qtmain/</url>
    <content><![CDATA[<p>经常写 Qt 的程序，就会发现，不管是写控制台程序还是带窗体的应用程序，在 Qt 中的入口都是<code>int main()</code>。但实际上抛开其他平台不说，就是在 Windows 平台上，二者的入口就是有区别的。之前只是略知一点，今天翻看了一下代码，算是了解了一下。</p>
<span id="more"></span>

<p>其实这个探究过程倒也并不费劲。命令行程序暂且不表。就拿带窗体的应用程序来说，已知它的入口只能是<code>WinMain</code>、<code>wWinMain</code>、<code>_tWinMain</code>。不难按图索骥找到 <strong>qtmain_win.cpp</strong> 这个文件。事实上， 另一个关于 winrt 的入口定义也在同级目录下( <strong>qtbase\src\winmain</strong> )。 <strong>qtmain_win.cpp</strong> 文件内容如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">#include &quot;qt_windows.h&quot;</span></span><br><span class="line"><span class="comment">#include &quot;qbytearray.h&quot;</span></span><br><span class="line"><span class="comment">#include &quot;qstring.h&quot;</span></span><br><span class="line"><span class="comment">#include &quot;qvector.h&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#include &lt;shlobj.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This file contains the code in the qtmain library for Windows.</span></span><br><span class="line"><span class="comment">  qtmain contains the Windows startup code and is required for</span></span><br><span class="line"><span class="comment">  linking to the Qt DLL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  When a Windows application starts, the WinMain function is</span></span><br><span class="line"><span class="comment">  invoked.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">QT_USE_NAMESPACE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(QT_NEEDS_QMAIN)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qMain</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> **)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> main qMain</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> **)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  WinMain() - Initializes Windows and calls user&#x27;s startup function main().</span></span><br><span class="line"><span class="comment">  <span class="doctag">NOTE:</span> WinMain() won&#x27;t be called if the application was linked as a &quot;console&quot;</span></span><br><span class="line"><span class="comment">  application.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert a wchar_t to char string, equivalent to QString::toLocal8Bit()</span></span><br><span class="line"><span class="comment">// when passed CP_ACP.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> *<span class="title">wideToMulti</span><span class="params">(<span class="type">int</span> codePage, <span class="type">const</span> <span class="type">wchar_t</span> *aw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> required = <span class="built_in">WideCharToMultiByte</span>(codePage, <span class="number">0</span>, aw, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> *result = <span class="keyword">new</span> <span class="type">char</span>[required];</span><br><span class="line">    <span class="built_in">WideCharToMultiByte</span>(codePage, <span class="number">0</span>, aw, <span class="number">-1</span>, result, required, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> APIENTRY <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, LPSTR <span class="comment">/*cmdParamarg*/</span>, <span class="type">int</span> <span class="comment">/* cmdShow */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    <span class="type">wchar_t</span> **argvW = <span class="built_in">CommandLineToArgvW</span>(<span class="built_in">GetCommandLineW</span>(), &amp;argc);</span><br><span class="line">    <span class="keyword">if</span> (!argvW)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> **argv = <span class="keyword">new</span> <span class="type">char</span> *[argc + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line">        argv[i] = <span class="built_in">wideToMulti</span>(CP_ACP, argvW[i]);</span><br><span class="line">    argv[argc] = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">LocalFree</span>(argvW);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> exitCode = <span class="built_in">main</span>(argc, argv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc &amp;&amp; argv[i]; ++i)</span><br><span class="line">        <span class="keyword">delete</span> [] argv[i];</span><br><span class="line">    <span class="keyword">delete</span> [] argv;</span><br><span class="line">    <span class="keyword">return</span> exitCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个文件中不难看出，我在自己的工程中使用的 <code>int main()</code> 其实就是 <code>const int exitCode = main(argc, argv);</code> 这一行中的 <code>main</code> 了。 找到了案发现场，转而想到了一个问题，这个文件是如何应用在我的工程中的。</p>
<p>翻看目录时候 <strong>winmain.pro</strong> 引起了我的注意，根据它的内容不难发现，这个目录在 Windows 下编译会生成 <strong>qtmain.lib</strong> 。机智的我直接去找项目工程文件( .vcxproj )。查看他的内容，一切都真相大白。在 link 部分，会发现 <strong>qtmain.lib</strong> 文件会被链接到 exe 中。而这一步的操作，应该就是 VS 中 Qt 插件的功劳了。</p>
<p>所以由此可推断，如果用 VS 裸写 Qt 的程序，在链接的时候除了链接必要的 Qt 库文件，还要自己手动把这个 <strong>qtmain.lib</strong> 链接进去。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt5 中的 Json 模块与 JsonCpp 的对比</title>
    <url>/2018/08/12/qt5json-jsoncpp-diff/</url>
    <content><![CDATA[<p>工作中有幸做过关于 Qt5 Json 模块向 Qt4 的移植。做过有关 <em>Qt Json</em> 与 <em>JsonCpp</em> 的对比，并做过相关的兼容工作。所以着重研究了一下有关 Json 解析器的相关内容。注：大家常说的 <strong>QJson</strong> 其实并不是 Qt 中的模块，而是在 Qt4 没有 Json 模块的年代，一个非官方的第三方模块。对于现在 Qt 中的 Json 模块，官方称之为 <strong>Qt Json</strong>。</p>
<span id="more"></span>

<p>其实 Qt5 中的 Qt Json 模块的代码，写的可以说是严格按照 ECMA-404 协议的解析范本，没有任何自己画蛇添足的逻辑。而相比之下，JsonCpp 就相当随意了，作为一个非常有个性的解析器，是当之无愧了。以至于从 JsonCpp 换到 Qt Json 着实要做些兼容工作。</p>
<h2 id="二者的细节对比："><a href="#二者的细节对比：" class="headerlink" title="二者的细节对比："></a>二者的细节对比：</h2><h3 id="Qt-Json"><a href="#Qt-Json" class="headerlink" title="Qt Json"></a>Qt Json</h3><ol>
<li>不支持C&#x2F;C++风格注释，解析失败</li>
<li>不支持0123456这种数值解析</li>
<li>不支持QJsonValue、QJsonDocument的直接比较大小(支持判断相等和不等)</li>
<li>允许设置默认值，不抛异常。没有设置默认值的，无法转换成功返回空值。</li>
<li>错误信息不可定位到具体行列</li>
<li>Json文本最大不能超过128MB(超过会爆DocumentTooLargeError)</li>
<li>最大不能超过1024层嵌套(超过会爆DeepNestingError)<br>(以上两个限制都是写死在代码的，可以改掉，但是改掉限制以后。是否有其他问题暂不清楚)</li>
<li>qDebug下支持直接输出 Qt Json 的相关对象</li>
</ol>
<h3 id="JsonCpp"><a href="#JsonCpp" class="headerlink" title="JsonCpp"></a>JsonCpp</h3><ol>
<li>支持C&#x2F;C++风格注释，可以选择是否解析注释，可以允许设置和获取注释(然而在FastWriter的情况下不会输出注释)</li>
<li>支持0123456这种数值的解析</li>
<li>支持JsonValue的直接比较</li>
<li>不允许设置默认值，对于无法转换成功的，直接抛异常</li>
<li>错误信息可以定位到具体行列</li>
</ol>
<p>对于二者的效率，只用了 JsonCpp 项目中的测试用例跑过，结果证明 Qt Json 性能会好大概3-5倍。而且对于 Qt 项目来说， JsonCpp 那种解析错误就抛异常的，显然有点激进了，利用 Qt 的信号和槽就优雅了很多。但是由于 Qt 开发人员的懒惰，使用递归来进行解析，导致对 Json 数据的嵌套层数有要求，算是一个遗憾。不过客户端应用也够用了。</p>
<p>工作中对 JsonCpp 的兼容也只是兼容了 JsonCpp 的第1、2条。对 Qt Json 模块只要改 parse 部分。而 Qt Json 的 parse 是一个状态机，代码也通俗易懂，改起来还是不难的。另外一部分内容就是 Qt5 Json 向 Qt4 移植，这块的话，还是要稍微看一下源码，改动的话需要调整 Qt4 中的 QString 以及 QAtomicInt 中的一些原子操作，主要是一些琐碎细节，没啥特色，也就不表了。</p>
<p>很遗憾的是这两个库都只支持 DOM 解析</p>
<p>论专业性，还是 RapidJson 好一点，还支持 SAX 解析，而且在性能上会比较拔群。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈DPI、分辨率与缇</title>
    <url>/2019/04/05/resolution-dpi-twips/</url>
    <content><![CDATA[<p>在客户端开发的过程中免不了要接触的就是像素，屏幕分辨率，这些概念是比较常见的，但很多时候真的就只是用而已，并不知道他们到底是一种什么关系，想起之前做看图的时候，经常就会遇到一些很有意思的图片文件，那个时候就研究了一下这几个概念。近来突然想起，就记录一下。</p>
<span id="more"></span>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>先说这个最常见的概念，就是指有多少个像素，如果是屏幕分辨率，就是指屏幕有多少个像素。只不过通常提起屏幕分辨率都以宽*高的方式表达，类似 1366*768、1920*768 等等。</p>
<h3 id="DPI"><a href="#DPI" class="headerlink" title="DPI"></a>DPI</h3><p>DPI (Dots Per Inch，每英寸点数)，这个点可以理解为像素数，即每英寸像素数。</p>
<h3 id="缇"><a href="#缇" class="headerlink" title="缇"></a>缇</h3><p>这个概念，对于很多人是陌生的，但是实际上在做 WPS 的时候，会经常遇到一些有关于它的换算。其实它就是一种度量单位。1缇 &#x3D; 0.05磅</p>
<h3 id="磅"><a href="#磅" class="headerlink" title="磅"></a>磅</h3><p>一种度量单位。1磅 &#x3D; 1&#x2F;72英寸</p>
<h2 id="一些计算"><a href="#一些计算" class="headerlink" title="一些计算"></a>一些计算</h2><blockquote>
<p>1英寸 &#x3D; 72磅 &#x3D; 1440缇</p>
</blockquote>
<p>由这个转换可知，以上三个单位的长度是确定的，这也就知道为什么在办公文档中会选择用磅而不是像素来描述字号，因为……需要打印，打印的时候时一定要知道这个东西确切的长度。</p>
<p>这就引发了下一个问题，屏幕上的1像素打印出来到底是多大。可以注意到的是像素本身是不跟现实中的物理量有什么联系的，但是有一个东西是有联系的，那就是 DPI，将英寸和像素联系起来了。</p>
<p>那 DPI 这个值又是怎么来的呢？很多人只知道 Windows 下 DPI 一般是96， 打印是300 。但是并不知道这个值怎么来的。这就要看像素怎么来的，对于电脑来说，屏幕分辨率就是像素信息。所以就把屏幕分辨率也串起来了</p>
<p>这里以一个 23寸，屏幕分辨率为 1920*1080的显示器 为例：sqrt(1920^2^+1080^2^) &#x2F; 23 ≈ 95.77 ≈ 96。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>缇</strong>是一个绝对的概念，无论在地球上的哪个地方，缇的长度都是绝对的；<strong>DPI</strong> 是一个可以自己设置的，每英寸的像素数；<strong>屏幕分辨率</strong>也是可以自己设置的，代表了屏幕上的像素点数。</p>
<h3 id="DPI-有什么用"><a href="#DPI-有什么用" class="headerlink" title="DPI 有什么用"></a>DPI 有什么用</h3><h4 id="屏幕-DPI"><a href="#屏幕-DPI" class="headerlink" title="屏幕 DPI"></a>屏幕 DPI</h4><p>对于客户端开发来说，在系统层面，是无法准确知道用户的电脑屏幕是多大的，对于客户端，只能感知屏幕有多少个像素。那如果只是根据像素做开发，用户买的高分屏就全都炸了，一个15寸的笔记本，但是是2k屏幕，在用户的机器上就会看你的软件无比的小，因为同样屏幕的大小，高分屏的像素更多。而你的软件是固定像素大小的。</p>
<p>但是如果你根据上边的公式算一下，其实不难算出，这种高分屏的 DPI 是要比 96 大的，如果细心观察，高分屏默认选择的 DPI 也不是标准 DPI 而是放大的，其实就是因为它比 96 要大而已，因为有这个值，就可以对用户电脑屏幕的状况做到心里有数了。通常做法是，看是 96 的多少倍，对自己的软件内部元素做相应倍数放大，这就是高分屏适配的一般做法</p>
<h4 id="图片-DPI"><a href="#图片-DPI" class="headerlink" title="图片 DPI"></a>图片 DPI</h4><p>而对于某个图片设置 DPI 的作用则是控制图片打印出来的大小。对于在电脑上显示图片的大多数软件来说，修改 DPI 是不影响图片在软件里看到的大小的，因为它的像素没有变。但是相同像素大小的图片，不同 DPI，它们打印出来大小就截然不同了，因为在这里就要根据 DPI 换算它们的实际大小，才能准确的打印在纸上，这就跟 DPI 有关了。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>DPI</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈观照自己的体会</title>
    <url>/2020/03/13/scrutinized-myself/</url>
    <content><![CDATA[<p>既然是浅谈，就说明此文必将只是一些粗浅的认识，不是一个学术文章，只是我自己的认识与体会。而后说到观照自己，则必先谈观照二字。</p>
<p>观照是个大概念，我自己并没有能力讲的十分清楚。只能说说我对此最模糊的认识。</p>
<p>观照的意思在网上可以找到很多，从我个人的理解，大致有两种是我比较认可的：</p>
<ol>
<li>指静观世界以智慧而照见事理</li>
<li>也叫静观。美学名词。指人（主体）在超功利的状态下对事物（客体）特性进行观察、体验、判断、审视等特有的心理活动。</li>
</ol>
<span id="more"></span>
<p>这两种解释也有出处可考：</p>
<p>关于第一种意思的出处，最早的就是《楞严经》（卷二：“﹝佛告 阿难 ：﹞汝虽强记，但益多闻，于奢摩他微密观照，心犹未了。” ）和唐朝李华的《衢州龙兴寺故律师体公碑》（“於辩才得自在，於文义得解脱，於人法得无我，於观照得甚深。”）。根据我不严谨的考察，《楞严经》应该是在公元705年开始翻译。而李华应该是公元715年出生，所以根据目前我得知的资料来看，这种释义的出处应该是《楞严经》。</p>
<p>第二种释义我没有找到严谨的出处，但以我自己粗浅的认识，柏拉图提到的观照(《哲学研究》2003年第1期——《哲人看到的是什么》)跟第二种释义不能说相同，但隐约有点类似。而且在其他文学作品中，也确实有见到这种释义的用法。譬如在鲁迅的《华盖集》题记第一句则写道：我知道伟大的人物能洞见三世，观照一切，历大苦恼，尝大欢喜，发大慈悲。郭沫若的《今昔集·今天创作的道路》：“文艺活动当然不能除外。要站在这样一种批判的立场以观照人生，批判人生，领导人生，文艺家才能尽到美化社会，革新社会的使命。” </p>
<p>但我写这些并非要追究观照的用法，也不是追究大师用的是否正确。而仅仅是想谈谈对于观照本意的个人认识。因为要谈具体的心得体会，就必须要确定谈的是什么。我所谓之观照，就是观照的第二个意思；而我所谓之观照自己，不是曾子的吾日三省吾身，也不是网上的段子早午晚吃什么的三省，更不是什么冥想或者其他的玄学说法。在我看来，如果硬要找一个解释，那就要借助上面我说的第二点意思：在超功利的状态下对自己进行观察、体验、判断、审视。借此达到准确认识自己（这包括很多方面，好恶、喜悲、屈伸、各种观等等）的目的；而我所谓之谈，不是说怎么、也不是说为什么。而是体会，是得什么。</p>
<p>对此我则有着三大体会，分别是幸福感、专注与理解。</p>
<p><strong>体会之一，幸福感。</strong></p>
<p>我曾经花费过很多时间去思考所谓的幸福感，人的幸福感究竟是从何而来。泡最靓的妞？赚更多的钱？周游世界？住最豪华的房子？开最豪华的车？就拿赚钱来说，拼命没拼命我不知道，我是努力赚钱了，但是在一段时期，我并没有得到应该有的快乐，我曾经十分怀疑自己，明明我做了那么多的事，却没得到多少幸福感。明明这些事非常正确，又非常符合自己的利益，但感受不到快乐。</p>
<p>在不工作的一年时间里，我开始试着观照自己。最终觉得，这跟我对事物价值的判断方法是分不开的。从小到大，我更聚焦的是对错、是非。而行事则多以盈亏、多寡判断。一件事要不要做，判断的维度基本围绕着对还是不对、有利还是有害。但却忽略了：“想做”还是“不想做”。在这里，我不想讨论所谓对与不对和想与不想极端对立的情况，因为这没有任何价值，所有人都有应该有的答案。我想说的是生活中非常一般的情况。很明显，我忽略了获得幸福感最重要的一个因素。而忽略的原因有很多种，可能是不符合利益最大化原则、也可能是妄图将自己隐藏在茫茫大众之中，不做一个异类等等</p>
<p>为什么我说观照自己可以提升幸福感？不仅仅是解决“想”与“不想”的问题，还有另外的原因。</p>
<p>当人不能观照自己的时候，就会迷失，这种迷失会让人负面情绪变得很重，因为找不到自身的问题，从自己向外观之，一切问题，都是别人的问题，都是客观的问题，都是无法解决的问题；而观照自己，其实与外界的矛盾，追本溯源，总能找到其与自己心中一个纠结点的映射。</p>
<p>一个最简单的例子，如果我很讨厌一个人，但我又做不了任何事情，只能每天抱怨这个人有多讨厌。归根结底，总能找到我离不开这个人的一个原因，如果能离开，则必然有一个痛快的切割，抱怨和讨厌的情绪也早就不存在了。这种离不开，可能是利益上的，也可能是其他方面的，再抽象一点，便是没有跟其切割的勇气。我一直说，如果有“虽千万人吾往矣。”的勇气，也就不会有那么多的负面情绪。 </p>
<p>所以对于幸福感的提升，我认为有三个方面：1.想与不想。2.与自身矛盾的和解。3.专注(这个在后边会提到)。这些都可以通过我所谓之观照自己来找到最准确的答案。观照自己不能直接带来幸福感，而是为寻找幸福感提供方向。</p>
<p><strong>体会之二，专注。</strong></p>
<p>我曾经有过一段时间，什么都想要，什么都酸，什么都杠，什么都争。没法开解。把自己陷入一个非常受折磨的状态。再后来我走出这段状态之后，重新来看，便觉得这和专注是分不开的。看起来像是八竿子打不着的事情，但实际上又有千丝万缕的联系。当我重新审视自己之后，我得出了一个结论。“什么都”等于“什么都不”。什么都想要就是什么都不想要，说到底就是不知道自己想要什么。因为不知道自己想要什么，别人有的就都想要；不知道自己想说什么，别人说的就都想杠。这种种的不知道，就会导致别人去做的，我就要去追，今天追这个，明天追那个，也就谓之不够专注，不够专注又做不好，做不好就又会酸，整个陷入了一个循环。</p>
<p>所以观照自己解决了自己要什么的问题，为专注提供前提。</p>
<p><strong>体会之三，理解。</strong></p>
<p>理解别人的前提是要理解自己。在对自己的行事有百分之百了解的前提下，如果连自己都不理解，又怎么做到对他人的行事了解百分之一的情况下，理解他人？只有很好的理解自己，才能更好的理解别人。在很长一段时间里，我对他人的评价一直都处于一个“不理解也不认同、既理解也认同”的非黑即白的状态，而我现在更多的情况是理解但不认同。在这里，我所谓之理解，就是我认为在他人的状态下做出这种行为是合理的，但理解了不一定就认同，他人行为的合理不合理与我是否认可他人的行为不存在必然的相关性。但对自己有正向收益的一点是，当理解了他人的时候，相比不理解时，由自己对他人的不认同导致的心里难受，也会减轻一些，为什么会出现这样的变化，这个不是我能说清楚的问题，我只是谈我得到的结论。</p>
<p>所以观照自己是理解自己的一种方法，为理解他人做准备。</p>
<p>我曾陷入过对自己与周围的怀疑之中，也曾被别人怀疑着。而我个人的体会是，对自身的认识的提升，是摆脱困境的最好方法。</p>
<p>其实对于观照这个概念也有很多方面可说，但限于我个人的认识与水平，很多东西我并不能说清道明。谈这些的目的也仅仅是对自己一些思考的记录。并非鼓吹什么东西，也并非要验证真假与科学考证。如果执着于此，“那反而又是没有观照了”。</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>【复音口琴】手震音、波音、琶音、装饰音技巧</title>
    <url>/2014/12/21/shou-bo-pa-zhuang/</url>
    <content><![CDATA[<p>手震音、波音、琶音、装饰音放在一起说了，因为这几个技巧理解上大家会很好理解。所以每个技巧注意的点都不多。</p>
<p>首先要说的第一坑就是这些技巧练习是很好练习，所以很容易给人一个错觉，自己已经掌握了。我自己就曾经入过这个坑。</p>
<p>这些技巧的重点在于效果是否到位，而不在于你会不会，但是话说回来，所有技巧都是要求效果到位。</p>
<span id="more"></span>

<p>首先是各种技巧的吹奏要点：</p>
<ul>
<li>手震音：吹奏时，用手捂住口琴下部，根据曲子情感做一开一合，听起来有一种震颤的感觉。具体的图就不上了，很多教材都有</li>
<li>波音：实际上波音，我个人感觉就是简化了简谱记号，一个标有波音记号的，在这个音本身的节奏上要吹成和后一个音前八后十六的节奏，这个教材上也有写，不多说</li>
<li>琶音：以高音1为例，从倍低音1滑至高音1。就是从琶音标记的音第低两个八度的音滑至这个音。滑动的速度有快有慢，看曲子要求。</li>
<li>装饰音(倚音)：在标有装饰音记号的地方，将装饰音快速吹出，不占正常音的时值。这里其实也不是很准确，既然你有音吹，肯定就要占时值，但是这么说的原因是，体现了它的吹奏时极为快速的，要尽可能的快速而清晰的吹出来，以最少的时值吹出它。</li>
</ul>
<p>这四种技巧如果说会，自己看了就能吹，但是效果好不好，那就看个人技术了。下面说说四种技巧注意的要点：</p>
<ul>
<li>手震音：1、在演奏中，要时刻注意移动自己的手，如果吹低音6，但是你的手还在口琴中间，必然是没什么效果的；2、这个技巧实际上有个简单的分脑，就是有些曲子中手震音的技巧的部分还会有舌伴奏，这个时候很容易自己手的开合就跟着伴奏的节奏走了，效果显然是不好的；3、对曲子情绪的把握，有控制的手速开合。</li>
<li>波音：这个大坑没有，但是在比较快速的曲子上，要多加练习，不然节奏把握不好，很可能吹成前十六后八。</li>
<li>琶音：这个有个小坑，就是无论是快速滑动还是慢速滑动，中间经过的音，每个都是平均且清晰的，否则效果会很差。所以移动口琴的速度要做到有所控制，也不是随便乱拽一气的。</li>
<li>装饰音：这个参考了傅豪久老师的讲解，我才真正理解了什么是快，还是建议多听听网上老师们的视频。不然自己很难理解什么算是快。但是也要根据曲子来。比如龙的传人中有一段67[1][2]的装饰音，这个就没必要求快，因为曲子上面明显标记了缓慢。但是推荐大家在练习这个技巧的时候尽量吹快。毕竟快是难吹的，如果你能吹快，慢自然就会了，那个时候演奏乐曲就随心所欲了。</li>
</ul>
<p>这四种技巧，每一种练习的时候，可以不必拘泥于短时间大量的重复练习，而是需要一个长期积累的过程，每天都要把这几种技巧多多复习，这样练起来效果会比较好……</p>
]]></content>
      <categories>
        <category>口琴吹奏技巧</category>
      </categories>
      <tags>
        <tag>harmonica</tag>
        <tag>复音口琴</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt源码笔记】Qt事件与Windows消息循环的联系</title>
    <url>/2016/07/31/qt-source-win-qt-event/</url>
    <content><![CDATA[<p>上次研究了一下Qt是如何对Win32初始化程序进行包装的。这次研究下Qt的事件循环和Windows消息循环之间的联系。</p>
<p>上次说到<code>QApplication</code>注册了一个<code>qt_internal_proc</code>方法来处理消息循环，但是在这个方法中并没有看到一些关于Qt事件的蛛丝马迹。例如<em>鼠标事件</em>、<em>键盘事件</em>等。</p>
<span id="more"></span>

<p>其实在<code>qt_internal_proc</code>方法中有个调用值得注意:<code>sendPostedEvents()</code>。如果在我们自己Demo的鼠标事件中打个断点，不难发现，就是从这个调用来到我们的<code>mousePressEvent()</code>的。但是如果我们查看堆栈信息，按图索骥，会发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool QWindowSystemInterface::sendWindowSystemEvents(QEventLoop::ProcessEventsFlags flags)</span><br><span class="line">&#123;</span><br><span class="line">    int nevents = 0;</span><br><span class="line"></span><br><span class="line">    while (QWindowSystemInterfacePrivate::windowSystemEventsQueued()) &#123;</span><br><span class="line">        QWindowSystemInterfacePrivate::WindowSystemEvent *event =</span><br><span class="line">            (flags &amp; QEventLoop::ExcludeUserInputEvents) ?</span><br><span class="line">                QWindowSystemInterfacePrivate::getNonUserInputWindowSystemEvent() :</span><br><span class="line">                QWindowSystemInterfacePrivate::getWindowSystemEvent();</span><br><span class="line">        if (!event)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        if (QWindowSystemInterfacePrivate::eventHandler) &#123;</span><br><span class="line">            if (QWindowSystemInterfacePrivate::eventHandler-&gt;sendEvent(event))</span><br><span class="line">                nevents++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            nevents++;</span><br><span class="line">            QGuiApplicationPrivate::processWindowSystemEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Record the accepted state for the processed event</span><br><span class="line">        // (excluding flush events). This state can then be</span><br><span class="line">        // returned by flushWindowSystemEvents().</span><br><span class="line">        if (event-&gt;type != QWindowSystemInterfacePrivate::FlushEvents)</span><br><span class="line">            QWindowSystemInterfacePrivate::eventAccepted.store(event-&gt;eventAccepted);</span><br><span class="line"></span><br><span class="line">        delete event;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (nevents &gt; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上边可以看到，这个最原始的事件就是从<code>getXXXXXEvent()</code>方法中得到的，而这个方法是从一个事件队列中取事件。</p>
<p><code>getWindowSystemEvent()</code>方法中的内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QWindowSystemInterfacePrivate::WindowSystemEvent * QWindowSystemInterfacePrivate::getWindowSystemEvent()</span><br><span class="line">&#123;</span><br><span class="line">    return windowSystemEventQueue.takeFirstOrReturnNull();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以说这个事件队列就是我们要关注的焦点。那事件是如何被添加到这个队列里的，这里暂时按下不表，先记住他的名字<code>windowSystemEventQueue</code>。</p>
<p>###从QWidget谈起<br>回过头来想，鼠标键盘事件其实都是依托于窗口的，但其实<code>QApplication</code>本身并不属于窗体，我们如果想在程序中加入一些可视的窗口，就要自己做个<code>QWidget</code>或者是<code>QMainWindow</code>等等。所以可以得出一个大概的结论，这些事件的接收处理必然和<code>QWidget</code>有着千丝万缕的联系。另外关于Win32消息的处理，我们必然要关注的一个，那就是回调函数。</p>
<p>拿着这两个线索，花了一点时间，简单梳理一下，不难发现这里边的调用。<strong>以下调用非必要的会省略掉参数</strong></p>
<ol>
<li>初始化<code>QWidget</code>会初始化<code>QWidgetPrivate</code>，在<code>QWidgetPrivate</code>的<code>init()</code>中会调用<code>QWidget::create()</code>;</li>
<li>接着在<code>QWidget::create()</code>中调用<code>QWidgetPrivate::create_sys()</code>，在这个方法中，会创建一个<code>QWindow</code>，在创建之后如果<code>QWidget</code>是显示的，会调用<code>QWindow::setVisible(true)</code>; </li>
<li>在<code>QWindow::setVisible(true)</code>中调用<code>QWindow::create()</code>，这个方法中没有别的只是转调<code>QWindowPrivate::create()</code>。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void QWindowPrivate::create(bool recursive)</span><br><span class="line">&#123;</span><br><span class="line">    Q_Q(QWindow);</span><br><span class="line">    if (platformWindow)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (q-&gt;parent())</span><br><span class="line">        q-&gt;parent()-&gt;create();</span><br><span class="line"></span><br><span class="line">    platformWindow = QGuiApplicationPrivate::platformIntegration()-&gt;createPlatformWindow(q);</span><br><span class="line">    Q_ASSERT(platformWindow);</span><br><span class="line"></span><br><span class="line">    if (!platformWindow) &#123;</span><br><span class="line">        qWarning() &lt;&lt; &quot;Failed to create platform window for&quot; &lt;&lt; q &lt;&lt; &quot;with flags&quot; &lt;&lt; q-&gt;flags();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QObjectList childObjects = q-&gt;children();</span><br><span class="line">    for (int i = 0; i &lt; childObjects.size(); i ++) &#123;</span><br><span class="line">        QObject *object = childObjects.at(i);</span><br><span class="line">        if (!object-&gt;isWindowType())</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        QWindow *childWindow = static_cast&lt;QWindow *&gt;(object);</span><br><span class="line">        if (recursive)</span><br><span class="line">            childWindow-&gt;d_func()-&gt;create(recursive);</span><br><span class="line"></span><br><span class="line">        // The child may have had deferred creation due to this window not being created</span><br><span class="line">        // at the time setVisible was called, so we re-apply the visible state, which</span><br><span class="line">        // may result in creating the child, and emitting the appropriate signals.</span><br><span class="line">        if (childWindow-&gt;isVisible())</span><br><span class="line">            childWindow-&gt;setVisible(true);</span><br><span class="line"></span><br><span class="line">        if (QPlatformWindow *childPlatformWindow = childWindow-&gt;d_func()-&gt;platformWindow)</span><br><span class="line">            childPlatformWindow-&gt;setParent(this-&gt;platformWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QPlatformSurfaceEvent e(QPlatformSurfaceEvent::SurfaceCreated);</span><br><span class="line">    QGuiApplication::sendEvent(q, &amp;e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在这个方法中，可以看到<code>createPlatformWindow()</code>，顾名思义，会创建一个平台相关的<em>Window</em>。这里的实际调用是<code>QWindowsIntegration::createPlatformWindow()</code>。<br> 而在这个方法中，我们会看到这个语句<code>QWindowsWindowData::create(window, requested, window-&gt;title());</code>这里的<code>create()</code>是一个静态方法。</li>
<li>在<code>create()</code>中会搞出一个<code>WindowCreationData</code>，这个结构体在<strong>qwindowswindow.cpp</strong>中，可以看到在定义上边的注释，没错，<code>create()</code>中会调用<code>WindowCreationData::create()</code>来创建一个<em>system handle</em>。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    /*!</span><br><span class="line">    \class WindowCreationData</span><br><span class="line">    \brief Window creation code.</span><br><span class="line"></span><br><span class="line">    This struct gathers all information required to create a window.</span><br><span class="line">    Window creation is split in 3 steps:</span><br><span class="line"></span><br><span class="line">    \list</span><br><span class="line">    \li fromWindow() Gather all required information</span><br><span class="line">    \li create() Create the system handle.</span><br><span class="line">    \li initialize() Post creation initialization steps.</span><br><span class="line">    \endlist</span><br><span class="line"></span><br><span class="line">    The reason for this split is to also enable changing the QWindowFlags</span><br><span class="line">    by calling:</span><br><span class="line"></span><br><span class="line">    \list</span><br><span class="line">    \li fromWindow() Gather information and determine new system styles</span><br><span class="line">    \li applyWindowFlags() to apply the new window system styles.</span><br><span class="line">    \li initialize() Post creation initialization steps.</span><br><span class="line">    \endlist</span><br><span class="line"></span><br><span class="line">    Contains the window creation code formerly in qwidget_win.cpp.</span><br><span class="line"></span><br><span class="line">    \sa QWindowCreationContext</span><br><span class="line">    \internal</span><br><span class="line">    \ingroup qt-lighthouse-win</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
<li>在<code>WindowCreationData::create()</code>中会发现一个非常熟悉的一段代码<br><code>const QString windowClassName = QWindowsContext::instance()-&gt;registerWindowClass(w);</code></li>
<li>这段代码是得到一个<code>QWindowsContext</code>实例，调用它的<code>registerWindowClass()</code>方法。而在<code>QWindowsContext::registerWindowClass()</code>中，我们会看到这段代码<br><code>return registerWindowClass(cname, qWindowsWndProc, style, GetSysColorBrush(COLOR_WINDOW), icon);</code>，在这里我们就会看到<code>qWindowsWndProc</code>，其实这个就是最终跟每个<code>QWidget</code>的事件相关的回调方法，这里暂时按下不表，先观察这个重载方法的内容：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QString QWindowsContext::registerWindowClass(QString cname,</span><br><span class="line">                                             WNDPROC proc,</span><br><span class="line">                                             unsigned style,</span><br><span class="line">                                             HBRUSH brush,</span><br><span class="line">                                             bool icon)</span><br><span class="line">&#123;</span><br><span class="line">    // since multiple Qt versions can be used in one process</span><br><span class="line">    // each one has to have window class names with a unique name</span><br><span class="line">    // The first instance gets the unmodified name; if the class</span><br><span class="line">    // has already been registered by another instance of Qt then</span><br><span class="line">    // add an instance-specific ID, the address of the window proc.</span><br><span class="line">    static int classExists = -1;</span><br><span class="line"></span><br><span class="line">    const HINSTANCE appInstance = static_cast&lt;HINSTANCE&gt;(GetModuleHandle(0));</span><br><span class="line">    if (classExists == -1) &#123;</span><br><span class="line">        WNDCLASS wcinfo;</span><br><span class="line">        classExists = GetClassInfo(appInstance, reinterpret_cast&lt;LPCWSTR&gt;(cname.utf16()), &amp;wcinfo);</span><br><span class="line">        classExists = classExists &amp;&amp; wcinfo.lpfnWndProc != proc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (classExists)</span><br><span class="line">        cname += QString::number(reinterpret_cast&lt;quintptr&gt;(proc));</span><br><span class="line"></span><br><span class="line">    if (d-&gt;m_registeredWindowClassNames.contains(cname))        // already registered in our list</span><br><span class="line">        return cname;</span><br><span class="line"></span><br><span class="line">#ifndef Q_OS_WINCE</span><br><span class="line">    WNDCLASSEX wc;</span><br><span class="line">    wc.cbSize       = sizeof(WNDCLASSEX);</span><br><span class="line">#else</span><br><span class="line">    WNDCLASS wc;</span><br><span class="line">#endif</span><br><span class="line">    wc.style        = style;</span><br><span class="line">    wc.lpfnWndProc  = proc;</span><br><span class="line">    wc.cbClsExtra   = 0;</span><br><span class="line">    wc.cbWndExtra   = 0;</span><br><span class="line">    wc.hInstance    = appInstance;</span><br><span class="line">    wc.hCursor      = 0;</span><br><span class="line">#ifndef Q_OS_WINCE</span><br><span class="line">    wc.hbrBackground = brush;</span><br><span class="line">    if (icon) &#123;</span><br><span class="line">        wc.hIcon = static_cast&lt;HICON&gt;(LoadImage(appInstance, L&quot;IDI_ICON1&quot;, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE));</span><br><span class="line">        if (wc.hIcon) &#123;</span><br><span class="line">            int sw = GetSystemMetrics(SM_CXSMICON);</span><br><span class="line">            int sh = GetSystemMetrics(SM_CYSMICON);</span><br><span class="line">            wc.hIconSm = static_cast&lt;HICON&gt;(LoadImage(appInstance, L&quot;IDI_ICON1&quot;, IMAGE_ICON, sw, sh, 0));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            wc.hIcon = static_cast&lt;HICON&gt;(LoadImage(0, IDI_APPLICATION, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_SHARED));</span><br><span class="line">            wc.hIconSm = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        wc.hIcon    = 0;</span><br><span class="line">        wc.hIconSm  = 0;</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">    if (icon) &#123;</span><br><span class="line">        wc.hIcon = (HICON)LoadImage(appInstance, L&quot;IDI_ICON1&quot;, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        wc.hIcon    = 0;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    wc.lpszMenuName  = 0;</span><br><span class="line">    wc.lpszClassName = reinterpret_cast&lt;LPCWSTR&gt;(cname.utf16());</span><br><span class="line">#ifndef Q_OS_WINCE</span><br><span class="line">    ATOM atom = RegisterClassEx(&amp;wc);</span><br><span class="line">#else</span><br><span class="line">    ATOM atom = RegisterClass(&amp;wc);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    if (!atom)</span><br><span class="line">        qErrnoWarning(&quot;QApplication::regClass: Registering window class &#x27;%s&#x27; failed.&quot;,</span><br><span class="line">                      qPrintable(cname));</span><br><span class="line"></span><br><span class="line">    d-&gt;m_registeredWindowClassNames.insert(cname);</span><br><span class="line">    qCDebug(lcQpaWindows).nospace() &lt;&lt; __FUNCTION__ &lt;&lt; &#x27; &#x27; &lt;&lt; cname</span><br><span class="line">        &lt;&lt; &quot; style=0x&quot; &lt;&lt; hex &lt;&lt; style &lt;&lt; dec</span><br><span class="line">        &lt;&lt; &quot; brush=&quot; &lt;&lt; brush &lt;&lt; &quot; icon=&quot; &lt;&lt; icon &lt;&lt; &quot; atom=&quot; &lt;&lt; atom;</span><br><span class="line">    return cname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>到这里，就看到了注册窗口的基本套路<code>RegisterClass()</code>，就算是彻底把跟Qt事件相关的消息循环回调找到了。</p>
<p>现在再来看一下刚才说的<code>qWindowsWndProc</code>，这里边的内容，其实比较简短：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot; LRESULT QT_WIN_CALLBACK qWindowsWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">    LRESULT result;</span><br><span class="line">    const QtWindows::WindowsEventType et = windowsEventType(message, wParam, lParam);</span><br><span class="line">    const bool handled = QWindowsContext::instance()-&gt;windowsProc(hwnd, message, et, wParam, lParam, &amp;result);</span><br><span class="line">    if (QWindowsContext::verbose &gt; 1 &amp;&amp; lcQpaEvents().isDebugEnabled()) &#123;</span><br><span class="line">        if (const char *eventName = QWindowsGuiEventDispatcher::windowsMessageName(message)) &#123;</span><br><span class="line">            qCDebug(lcQpaEvents) &lt;&lt; &quot;EVENT: hwd=&quot; &lt;&lt; hwnd &lt;&lt; eventName &lt;&lt; hex &lt;&lt; &quot;msg=0x&quot;  &lt;&lt; message</span><br><span class="line">                &lt;&lt; &quot;et=0x&quot; &lt;&lt; et &lt;&lt; dec &lt;&lt; &quot;wp=&quot; &lt;&lt; int(wParam) &lt;&lt; &quot;at&quot;</span><br><span class="line">                &lt;&lt; GET_X_LPARAM(lParam) &lt;&lt; GET_Y_LPARAM(lParam) &lt;&lt; &quot;handled=&quot; &lt;&lt; handled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!handled)</span><br><span class="line">        result = DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里主要做了一些微小的工作，对消息分类把消息处理成<code>QtWindow::WindowEventType</code>类型，便于后续处理，具体逻辑在<code>windowsEventType()</code>方法中，主要是做Win32消息和Qt事件的映射。然后就是调用<code>QWindowsContext::windowsProc()</code>处理消息。特定情况下输出debug信息。在处理消息的时候会得到处理结果，对于没有处理的调用<code>DefWindowProc()</code>做默认处理。</p>
<p><strong>如果想看Win32消息和Qt事件对应的关系映射，在上边说到的windowEventType()方法中是最快的，基本涵盖了大部分，但是要注意有一些名字对不上，因为到这里其实分类还不是QEvent，而是一个中间类型</strong></p>
<p>现在来重点关注一下<code>windowProc()</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool QWindowsContext::windowsProc(HWND hwnd, UINT message,</span><br><span class="line">                                  QtWindows::WindowsEventType et,</span><br><span class="line">                                  WPARAM wParam, LPARAM lParam, LRESULT *result)</span><br><span class="line">&#123;</span><br><span class="line">    *result = 0;</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    msg.hwnd = hwnd;         // re-create MSG structure</span><br><span class="line">    msg.message = message;   // time and pt fields ignored</span><br><span class="line">    msg.wParam = wParam;</span><br><span class="line">    msg.lParam = lParam;</span><br><span class="line">    msg.pt.x = msg.pt.y = 0;</span><br><span class="line">    if (et != QtWindows::CursorEvent &amp;&amp; (et &amp; (QtWindows::MouseEventFlag | QtWindows::NonClientEventFlag))) &#123;</span><br><span class="line">        msg.pt.x = GET_X_LPARAM(lParam);</span><br><span class="line">        msg.pt.y = GET_Y_LPARAM(lParam);</span><br><span class="line">        // For non-client-area messages, these are screen coordinates (as expected</span><br><span class="line">        // in the MSG structure), otherwise they are client coordinates.</span><br><span class="line">        if (!(et &amp; QtWindows::NonClientEventFlag)) &#123;</span><br><span class="line">            ClientToScreen(msg.hwnd, &amp;msg.pt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">#ifndef Q_OS_WINCE</span><br><span class="line">        GetCursorPos(&amp;msg.pt);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Run the native event filters.</span><br><span class="line">    long filterResult = 0;</span><br><span class="line">    QAbstractEventDispatcher* dispatcher = QAbstractEventDispatcher::instance();</span><br><span class="line">    if (dispatcher &amp;&amp; dispatcher-&gt;filterNativeEvent(d-&gt;m_eventType, &amp;msg, &amp;filterResult)) &#123;</span><br><span class="line">        *result = LRESULT(filterResult);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QWindowsWindow *platformWindow = findPlatformWindow(hwnd);</span><br><span class="line">    if (platformWindow) &#123;</span><br><span class="line">        filterResult = 0;</span><br><span class="line">        if (QWindowSystemInterface::handleNativeEvent(platformWindow-&gt;window(), d-&gt;m_eventType, &amp;msg, &amp;filterResult)) &#123;</span><br><span class="line">            *result = LRESULT(filterResult);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (et &amp; QtWindows::InputMethodEventFlag) &#123;</span><br><span class="line">        QWindowsInputContext *windowsInputContext = ::windowsInputContext();</span><br><span class="line">        // Disable IME assuming this is a special implementation hooking into keyboard input.</span><br><span class="line">        // &quot;Real&quot; IME implementations should use a native event filter intercepting IME events.</span><br><span class="line">        if (!windowsInputContext) &#123;</span><br><span class="line">            QWindowsInputContext::setWindowsImeEnabled(platformWindow, false);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        switch (et) &#123;</span><br><span class="line">        case QtWindows::InputMethodStartCompositionEvent:</span><br><span class="line">            return windowsInputContext-&gt;startComposition(hwnd);</span><br><span class="line">        case QtWindows::InputMethodCompositionEvent:</span><br><span class="line">            return windowsInputContext-&gt;composition(hwnd, lParam);</span><br><span class="line">        case QtWindows::InputMethodEndCompositionEvent:</span><br><span class="line">            return windowsInputContext-&gt;endComposition(hwnd);</span><br><span class="line">        case QtWindows::InputMethodRequest:</span><br><span class="line">            return windowsInputContext-&gt;handleIME_Request(wParam, lParam, result);</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // InputMethodEventFlag</span><br><span class="line">    //...</span><br><span class="line">    if (platformWindow) &#123;</span><br><span class="line">        // Suppress events sent during DestroyWindow() for native children.</span><br><span class="line">        if (platformWindow-&gt;testFlag(QWindowsWindow::WithinDestroy))</span><br><span class="line">            return false;</span><br><span class="line">        if (QWindowsContext::verbose &gt; 1)</span><br><span class="line">            qCDebug(lcQpaEvents) &lt;&lt; &quot;Event window: &quot; &lt;&lt; platformWindow-&gt;window();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        qWarning(&quot;%s: No Qt Window found for event 0x%x (%s), hwnd=0x%p.&quot;,</span><br><span class="line">                 __FUNCTION__, message,</span><br><span class="line">                 QWindowsGuiEventDispatcher::windowsMessageName(message), hwnd);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (et) &#123;</span><br><span class="line">    case QtWindows::KeyboardLayoutChangeEvent:</span><br><span class="line">        if (QWindowsInputContext *wic = windowsInputContext())</span><br><span class="line">            wic-&gt;handleInputLanguageChanged(wParam, lParam); // fallthrough intended.</span><br><span class="line">    case QtWindows::KeyDownEvent:</span><br><span class="line">    case QtWindows::KeyEvent:</span><br><span class="line">    case QtWindows::InputMethodKeyEvent:</span><br><span class="line">    case QtWindows::InputMethodKeyDownEvent:</span><br><span class="line">    case QtWindows::AppCommandEvent:</span><br><span class="line">#if !defined(Q_OS_WINCE) &amp;&amp; !defined(QT_NO_SESSIONMANAGER)</span><br><span class="line">        return platformSessionManager()-&gt;isInteractionBlocked() ? true : d-&gt;m_keyMapper.translateKeyEvent(platformWindow-&gt;window(), hwnd, msg, result);</span><br><span class="line">#else</span><br><span class="line">        return d-&gt;m_keyMapper.translateKeyEvent(platformWindow-&gt;window(), hwnd, msg, result);</span><br><span class="line">#endif</span><br><span class="line">    //...</span><br><span class="line">    case QtWindows::MouseWheelEvent:</span><br><span class="line">    case QtWindows::MouseEvent:</span><br><span class="line">    case QtWindows::LeaveEvent:</span><br><span class="line">#if !defined(Q_OS_WINCE) &amp;&amp; !defined(QT_NO_SESSIONMANAGER)</span><br><span class="line">        return platformSessionManager()-&gt;isInteractionBlocked() ? true : d-&gt;m_mouseHandler.translateMouseEvent(platformWindow-&gt;window(), hwnd, et, msg, result);</span><br><span class="line">#else</span><br><span class="line">        return d-&gt;m_mouseHandler.translateMouseEvent(platformWindow-&gt;window(), hwnd, et, msg, result);</span><br><span class="line">#endif</span><br><span class="line">    case QtWindows::TouchEvent:</span><br><span class="line">#if !defined(Q_OS_WINCE) &amp;&amp; !defined(QT_NO_SESSIONMANAGER)</span><br><span class="line">        return platformSessionManager()-&gt;isInteractionBlocked() ? true : d-&gt;m_mouseHandler.translateTouchEvent(platformWindow-&gt;window(), hwnd, et, msg, result);</span><br><span class="line">#else</span><br><span class="line">        return d-&gt;m_mouseHandler.translateTouchEvent(platformWindow-&gt;window(), hwnd, et, msg, result);</span><br><span class="line">#endif</span><br><span class="line">    case QtWindows::FocusInEvent: // see QWindowsWindow::requestActivateWindow().</span><br><span class="line">    case QtWindows::FocusOutEvent:</span><br><span class="line">        handleFocusEvent(et, platformWindow);</span><br><span class="line">        return true;</span><br><span class="line">    case QtWindows::ShowEventOnParentRestoring: // QTBUG-40696, prevent Windows from re-showing hidden transient children (dialogs).</span><br><span class="line">        if (!platformWindow-&gt;window()-&gt;isVisible()) &#123;</span><br><span class="line">            *result = 0;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    //...</span><br><span class="line">    &#125;</span><br><span class="line">   //...</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本着太长不看的原则，我把一些相似的都省略掉了。这里就能看到在这里会根据消息类型来进行分类处理。处理的方式也是统一的，调用<code>handleXXXXEvent()</code>或是<code>tranlateXXXXEvent()</code>。需要二次加工的就要走到<code>tranlateXXXXEvent()</code>二次加工。最终其实都是走到<code>handleXXXXEvent()</code>。而<code>handleXXXXEvent()</code>方法中会将事件包装成一个新的类型，再统一调用<code>QWindowSystemInterfacePrivate::handleWindowSystemEvent(e)</code><strong>PS:这是个静态方法</strong>，这个静态方法中需要关注<code>postWindowSystemEvent()</code>。</p>
<p>现在来看<code>postWindowSystemEvent()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void QWindowSystemInterfacePrivate::postWindowSystemEvent(WindowSystemEvent *ev)</span><br><span class="line">&#123;</span><br><span class="line">    windowSystemEventQueue.append(ev);</span><br><span class="line">    QAbstractEventDispatcher *dispatcher = QGuiApplicationPrivate::qt_qpa_core_dispatcher();</span><br><span class="line">    if (dispatcher)</span><br><span class="line">        dispatcher-&gt;wakeUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了非常熟悉的一个队列<code>windowSystemEventQueue</code>，就是在这里将事件加入队列，至此整个Qt事件和Windows消息循环彻底联系起来……</p>
<p>其实这只是一个添加事件、获取事件的简单流程，仅仅为了研究Qt事件和Windows消息循环的联系。<br>在这中间省略的很多其他细节，包括注册窗口，反注册，具体的事件处理规则，还有一些防止事件错误发送的保护机制，都是很好的研究内容……</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>深夜读《苏东坡传》</title>
    <url>/2014/12/14/su-dong-po-zhuan/</url>
    <content><![CDATA[<p>林语堂的《苏东坡传》，之前是没听说过的，也没人推荐过。买书的时候，为了凑优惠，选了一部作者名气比较大的。可以精神上接近下国学大师。翻开之后却觉得甚是难读，林语堂在书中说：为一个人写传，就要对这个人够了解，因为林特别喜爱苏东坡，故参考了关于苏的各种资料，写了这本传记。</p>
<p>可是他忽略了一点，越喜爱一个人，就越难对一个人作出客观的评价。只是翻看了两三章，都是溢美之词。失了客观的传记让我抵触情绪很大。这本书与其叫《苏东坡传》不如叫《苏东坡赞》，不知自己看过全书之后会不会对这种看法有所改变。</p>
<p>但是回头想想，容不下别人的溢美之词，也许就是自己的心里太满，做不到无欲无求，也许自己本身就不够客观，这也是自己应该修炼的地方。真不知道什么时候能改改这脾气。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>总结与展望</title>
    <url>/2016/01/03/summary-and-preview/</url>
    <content><![CDATA[<p>2015注定是变化的一年，在大学呆久了总要出来看看，或许这就是大家常说的“走入社会”吧。</p>
<span id="more"></span>
<h3 id="这一年，是现实和理想有激烈冲突的一年："><a href="#这一年，是现实和理想有激烈冲突的一年：" class="headerlink" title="这一年，是现实和理想有激烈冲突的一年："></a>这一年，是现实和理想有激烈冲突的一年：</h3><p>理想是丰满的，现实总是骨感的，年轻人的骨子里总有那么一股子冲劲，但是现实会把这骨子冲劲硬生生的顶回去。但是我依旧会坚持自己的那种我行我素，因为程序猿不也应该有一点自己的职业操守吗？</p>
<h3 id="这一年，是与Qt结缘的一年："><a href="#这一年，是与Qt结缘的一年：" class="headerlink" title="这一年，是与Qt结缘的一年："></a>这一年，是与Qt结缘的一年：</h3><p>工作的原因，让我开始接触Qt，大学的时候也玩过Qt，那时的玩也不过是照着教程随便搞搞。这一年我开始真正的去认识Qt，我开始试着了解他的源码，开始体会它的设计哲学……也开始学着摆脱别人的描述，去体会他的强大；</p>
<h3 id="这一年，是与C-确立关系的一年："><a href="#这一年，是与C-确立关系的一年：" class="headerlink" title="这一年，是与C++确立关系的一年："></a>这一年，是与C++确立关系的一年：</h3><p>是的，迷茫了四年，最终还是选择了这个让人又爱又恨的语言。也许冥冥中有一种定数，让我厌恶java，找python的工作又找不到，最后还是因为C++得以被收留。我开始重新审视，开始变得立体，开始试着去玩转它；</p>
<h3 id="这一年，是烦躁的一年："><a href="#这一年，是烦躁的一年：" class="headerlink" title="这一年，是烦躁的一年："></a>这一年，是烦躁的一年：</h3><p>从大学走出了，我离开了一批人，又认识了更多的人……我从他们的身上看到了低调，可我却没有学会。这是烦躁的一年，烦躁的几乎要被冲昏头脑，变得飘飘然……</p>
<hr>
<p>2015年，是一个岔路口，我在纠结……<br>2016年，是下一条路，我会更加坚定！</p>
<hr>
<p>##2016年，少说多做，脚踏实地，从心出发……</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>听到真话究竟有多难</title>
    <url>/2020/03/26/the-difficulty-of-telling-the-truth/</url>
    <content><![CDATA[<p>听到真话其实是一件非常难的事情。因为这个过程很复杂，中间的每个环节都会影响到最终的结果。这种感觉类似写代码的“与”运算，只要中间有一个过程是假，那最后听到的就是假。</p>
<span id="more"></span>
<p>我把听到真话的完整过程分为两部分：首先讲话的人要讲真话；其次听的人要听到这些话。这便是听到真话。为什么我说难，因为这两个部分尤其难。我将详细叙述下我的思考。</p>
<h3 id="讲真话"><a href="#讲真话" class="headerlink" title="讲真话"></a>讲真话</h3><p>讲真话是非常难的，为什么难呢？因为说假话很简单。听起来这句话应该是一句废话，但是要细品。为什么讲说假话很简单呢？这就要从影响讲话真实性的几大要素说起。我把它归结为这样几类：立场、情绪、惰性、其他因素。</p>
<h4 id="立场"><a href="#立场" class="headerlink" title="立场"></a>立场</h4><p>立场是最容易影响讲话真实性的要素。一个人如果有立场，讲话就会有指向性，就会很难保持客观中立。这里又要分为两种：一种是下意识地；一种是无意识的。所谓下意识地，就是讲话的人清楚的知道自己的立场，并且要将自己的表达完美的贴合自己的立场，所以故意说假话，俗话说就是：揣着明白装糊涂。(例：某些公众号、某些大V)；而无意识地，指的是立场本身对于这个人而言已经根深蒂固，融为一体，在讲话时候因立场原因自然而然地说出了失实的东西，但自己并不自知。(例：被洗脑的传销者)。</p>
<p>这两种虽然状况不完全一致，但最终结果都会导致讲话的人说假话。这在生活中是很常见的现象，因为立场在生活中很容易存在，任何事物都可能产生多面，就会有多个立场。所以说假话就非常常见。</p>
<h4 id="情绪"><a href="#情绪" class="headerlink" title="情绪"></a>情绪</h4><p>Wiki上，情绪的词条：是对一系列主观认知经验的通称，是多种感觉、思想和行为综合产生的心理和生理状态。可以说是一语道破。因为情绪本身就是主观的。当你带着情绪去讲话，去做事，实际上就很容易不够客观。(例：为了跟别人杠，而故意夸大或贬损了某些事物)。而情绪是无时无刻不在的，所以假话也就很多了。</p>
<h4 id="惰性"><a href="#惰性" class="headerlink" title="惰性"></a>惰性</h4><p>不得不承认，人是有惰性的，在生活中很常见的情况，当一个人解释一种事物如果非常不耐烦，就很容易解释的比较粗略，或是不符合事实。因为这种情况下说真话的成本更高，人是趋利的，在衡量了对自己是利大于弊的时候，就会选择说假话的策略来降低自己的时间成本。而人的惰性是很常见的，所以说假话的情况也就多了。</p>
<h4 id="其他因素"><a href="#其他因素" class="headerlink" title="其他因素"></a>其他因素</h4><p>就是排除以上三种因素之外的因素，我把它归结为其它因素。我目前还没发现具体例子。但是出于对问题覆盖全面，还是要有这一类才好。</p>
<p>从以上几点来看，不难看出，无论是下意识地还是无意识地，说假话是非常容易的，而且很常见。反之，讲真话就是非常难的。</p>
<h3 id="听到真话"><a href="#听到真话" class="headerlink" title="听到真话"></a>听到真话</h3><p>听到真话其实也是非常难的一件事情。这一点有很多人并不是很理解。听这个动作怎么就会难了。但实际上我强调的是听到，有些人听了，并不一定会听到。有一句话叫：你永远叫不醒一个装睡的人。就是这个道理。很多真话是不好听的，很多人不愿意听。这就造成了很多真话，听了，但根本没听到。</p>
<p>在这个世界上，美不一定都真实，但大部分的丑都是真实的，因为极少有人有立场、有情绪去给别人虚构丑。很多人不愿意听也不愿意见丑，所以即使听了，也没听到。宁愿听到假话也不愿意听到真话。所以听到真话也是一个很难的东西。想听到真话，你就要排除对方的立场、情绪、惰性以及可能说假话的其它因素，同时自己也要有足够的心理准备接纳真话，才能真正意义上听到真话。从小就讲做人不能偏听偏信，现在看，其实是非常难的。</p>
<br>

<p>而掌握了影响真实性的几大要素之后，对很多文章、信息和讲话的真实性其实就不会那么麻痹了。针对包含几个要素的文章、信息和讲话则都要留心。例：煽动性的(情绪)、讲者跟内容有利益相关的(立场)、讲者内容受讲者本身惰性影响的……</p>
<p>但这些实际上对真正来判断其真实性的指导意义并不是很大，因为更多的时候，我们很难辨别，内容是否煽动、是否有利益相关。而判断这些的方法展开来说，又有很多方面。限于篇幅，在这里就暂且不表了。</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>格局对普通人有意义吗？</title>
    <url>/2020/09/06/what-patterns-mean-to-ordinary-people/</url>
    <content><![CDATA[<p>两个月没有更新了，因为一直在看《禅与摩托车维修艺术》，看的很慢，用了快两个月时间才看完。所以就耽搁了。而且我也打算要花上一些功夫，写一些系列文章来总结它。</p>
<p>不过这篇却是要说说另外一本书，是我最近这一阵子看的，书很薄，花了四天时间就看完了，它就是《态度》，作者是吴军。这边书的封皮态度两个字是拆开的，“心”和“广”用红色标出来了，这跟书中的内容倒是有点联系。虽然书名叫《态度》，但实际上也可以叫做“吴军家书”。四十封写给女儿的信，阐述了吴军自己对女儿在成长过程中的一些建议。书中分为六个部分：人生哲学、洞察世界、对待金钱、人际关系、有效学习、做人做事。</p>
<span id="more"></span>

<p>书中大部分还是一些老生常谈，而且从中可以看出他对美国文化的吹捧，让我个人有点厌恶，这个单纯是个人喜好问题。每封信之后有一个结果来论证这封信起了作用，就有点生硬，显得不是那么客观。以至于刚开始看了一部分之后，我觉得这本书我只能给二星。</p>
<p>但全书看下来之后，有一点让我印象还是比较深刻的。那就是“格局”。也是因为这一点，让我调整了评级给了三星。</p>
<p>吴军在给女儿关于一些选择的建议中说：做事格局要大，境界要高，志向要远。其实这话，可能很多人成长过程中都听过，我自己也是。但是直到看过之后，我才真正对这个有所思考，我想也是跟我自己的经历有关。如果我没有直到现在的这些经历，也许我还是不能去思考格局的问题。</p>
<p>正如标题所说，今天我就想谈谈，<strong>格局对于普通人到底有没有意义</strong>。有很多时候，提到大格局，大境界，大志向，总觉得离普通人就过于遥远了。很多人是持着不在其位、不谋其政的观点。甚至有点普通人不配谈格局的意思。但是事实上就是如此吗？在我看来，并不是这样。或者说，在一段时间之前，我也是那样认为，但现在我并不认同了。</p>
<p>我认为有意义，那当然是要拿出一些东西，来支撑我的观点。</p>
<p>为什么有人认为格局会离普通人非常遥远。在我看来大抵有这么几点原因：</p>
<ol>
<li><p>提到格局，大多会提到一些“看起来普通人难以达到的目标”</p>
</li>
<li><p>认为格局是上层建筑，而大多数人觉得“经济基础决定上层建筑”，普通人的经济基础还没到位，所以上层建筑无从谈起</p>
</li>
<li><p>周围的普通人都不谈，谁谈了，谁就有点异类了</p>
</li>
</ol>
<p>但是其实这几点深究起来，好像并没有什么根据。这就要结合格局对普通人的意义，一起来说，才能说得明白。我认为格局对人的意义，无论是普通人，还是不普通的人，就在于<strong>它为人提供了一个方向</strong>。有句话叫『心有多大，舞台就有多大』，如果套在格局上，不如说<strong>格局有多大，路就能走多远</strong>。</p>
<p>那再回头说说为什么上边的几点原因没什么根据。</p>
<ol>
<li><p>大格局确实往往是一个很大的目标，造福人类社会、颠覆行业、保护人民群众的生命财产安全等等，类似这些，让人都会觉得离自己太遥远了，以一己之力并不能做到。但实际上忽略了人类社会或者说行业都是由人构成，当你能造福一两个人的时候，其实就已经参与到了造福人类社会这个格局其中了。就像去年我跟朋友说的那段话一样『这个世界有很多层级，在每一个层级上都有机会做好，不一定都得在顶层做。就像老师也有顶级名师、也有去山区支教的老师，他们对教育事业的贡献都很大。』在任何一个层面上，都可以参与到一个很大的格局当中。</p>
</li>
<li><p>如果认识到在任何一个层面上都可以参与到大格局其中，就不会觉得经济基础是一个必要条件。而且抛开经济基础不谈，其实“经济基础决定上层建筑”这句话本身是一个政治观点，而不是一个哲学观点。但因为我们的教育，政治和哲学没有完全分开，其实马克思没有说过这句话，而且这是一个国家层面的观点，并不是一个对个人有指导意义的价值观。</p>
</li>
<li><p>从众心理本就不可取，没什么好反驳的了……</p>
</li>
</ol>
<p>为什么格局会引起我的思考？我记得我曾经跟朋友说过这样一句话，我说：『写代码的没有信仰，太痛苦了』没有人生方向，对工作没有认同感，眼里都是钱，今天这家给的多，就去这家，明天那家给的多就去那家。到了三十五岁，混不上去，就直接“拉闸”，那个时候就是最痛苦的，因为不知道要干啥。</p>
<p>所以我想说的是，<strong>格局对任何人都很重要</strong>。人终究需要一个方向，不管是什么样的人，殊途同归，最终都会有一问：人生的意义究竟是什么。等问到自己这个问题的时候，现琢磨，就迷失了……</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>bcrypt 死锁探秘</title>
    <url>/2019/04/15/windows-bcrypt-deadlock/</url>
    <content><![CDATA[<p>产品经理反馈程序经常失去响应，从他那里创建了 dump 文件，取回来，用 windbg 分析一番。感慨颇多。</p>
<span id="more"></span>

<h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><p>加载符号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;!analyze -v</span><br><span class="line">wow64cpu!CpupSyscallStub+0x9:</span><br></pre></td></tr></table></figure>

<p>看到这个，系统是64位的，转换一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;.load wow64exts</span><br><span class="line">&gt;!sw</span><br><span class="line">&gt;!analyze -v</span><br><span class="line"></span><br><span class="line">STACK_TEXT:  </span><br><span class="line">002294a8 76a43d3c 00000000 002294ec 396663fe ntdll_771d0000!ZwDelayExecution+0x15</span><br><span class="line">00229510 5169f801 00000001 00000000 00035086 KERNELBASE!SleepEx+0x65</span><br><span class="line">00229528 519377cd 0dd20834 0dd20830 00229650 clr!EESleepEx+0x4f</span><br><span class="line">00229538 517afa11 00000000 39676e87 025cfb70 clr!__DangerousSwitchToThread+0x72</span><br><span class="line">00229650 517afad5 00390da0 39676e37 00229700 clr!ThreadNative::StartInner+0x2c1</span><br><span class="line">002296e0 79946049 00229700 00000000 025cfb50 clr!ThreadNative::Start+0x6a</span><br><span class="line">002296f8 79945fe4 00000001 00229738 0802a1c7 mscorlib_ni!System.Threading.Thread.Start(System.Threading.StackCrawlMark ByRef)+0x61</span><br><span class="line">00229704 0802a1c7 023dbe24 025cfb40 00000000 mscorlib_ni!System.Threading.Thread.Start()+0x18</span><br></pre></td></tr></table></figure>

<p>看了一下，这里应该不是事故现场。看看其他线程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;~*kb</span><br><span class="line">//此处省略一些信息</span><br><span class="line">......</span><br><span class="line"> 417  Id: 1480.3cfc Suspend: 0 Teb: 7ea61000 Unfrozen</span><br><span class="line"> <span class="comment"># ChildEBP RetAddr  Args to Child</span></span><br><span class="line">00 3849f5dc 7721eb4e 00000250 00000000 00000000 ntdll_771d0000!NtWaitForSingleObject+0x15</span><br><span class="line">01 3849f640 7721ea32 00000000 00000000 00000000 ntdll_771d0000!RtlpWaitOnCriticalSection+0x13e</span><br><span class="line">02 3849f668 77209aa9 772d20c0 4f52bc5c 7ea63000 ntdll_771d0000!RtlEnterCriticalSection+0x150</span><br><span class="line">03 3849f6fc 7720984c 3849f76c 4f52bde8 00000000 ntdll_771d0000!LdrpInitializeThread+0xc6</span><br><span class="line">04 3849f748 77209879 3849f76c 771d0000 00000000 ntdll_771d0000!_LdrpInitialize+0x1ad</span><br><span class="line">05 3849f758 00000000 3849f76c 771d0000 00000000 ntdll_771d0000!LdrInitializeThunk+0x10</span><br></pre></td></tr></table></figure>

<p>417个线程，大部分线程堆栈都是这样，看起来可能是存在死锁，导致线程不能正常退出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;!locks</span><br><span class="line">Scanned 9 critical sections</span><br></pre></td></tr></table></figure>

<p>没有多余信息。查看一下关键段信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;!cs -s -l -o</span><br><span class="line">DebugInfo          = 0x772d4380</span><br><span class="line">Critical section   = 0x772d20c0 (ntdll_771d0000!LdrpLoaderLock+0x0)</span><br><span class="line">LOCKED</span><br><span class="line">LockCount          = 0x187</span><br><span class="line">WaiterWoken        = No</span><br><span class="line">OwningThread       = 0x00001a0c</span><br><span class="line">RecursionCount     = 0x1</span><br><span class="line">LockSemaphore      = 0x250</span><br><span class="line">SpinCount          = 0x00000000</span><br><span class="line">OwningThread DbgId = ~47s</span><br><span class="line">OwningThread Stack =</span><br><span class="line">	ChildEBP RetAddr  Args to Child              </span><br><span class="line">	184fd76c 7721eb4e 00000ed8 00000000 00000000 ntdll_771d0000!NtWaitForSingleObject+0x15 (FPO: [3,0,0])</span><br><span class="line">	184fd7d0 7721ea32 00000000 00000000 00000000 ntdll_771d0000!RtlpWaitOnCriticalSection+0x13e (FPO: [Non-Fpo])</span><br><span class="line">	184fd7f8 6f882f8e 6f894060 00000000 0dd63b7c ntdll_771d0000!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo])</span><br><span class="line">	184fd820 6f882dc8 06f640c8 00000000 0dd63b78 bcrypt+0x2f8e</span><br><span class="line">	184fd874 72269a42 184fd894 72269a70 00000000 bcrypt+0x2dc8</span><br><span class="line">	184fd898 7659c167 722a49cc 184fd8c0 721aea6e msxml6!AutoInitSalt::AutoInitSalt+0x1f (FPO: [Non-Fpo]) (CONV: thiscall)</span><br><span class="line">	184fd8a4 721aea6e 721aea9c 721aeb90 00000001 msvcrt!_initterm+0x13 (FPO: [Non-Fpo])</span><br><span class="line">	184fd8c0 72191456 72190000 00000000 00000000 msxml6!_CRT_INIT+0xc3 (FPO: [Non-Fpo]) (CONV: stdcall)</span><br><span class="line">	184fd920 721ae3fe 72190000 00000001 00000000 msxml6!__DllMainCRTStartup+0x9e (FPO: [Non-Fpo]) (CONV: stdcall)</span><br><span class="line">	184fd940 77209344 72190000 00000001 00000000 msxml6!InitDllMain+0x90 (FPO: [Non-Fpo]) (CONV: stdcall)</span><br><span class="line">	184fd960 7720fde1 7219135c 72190000 00000001 ntdll_771d0000!LdrpCallInitRoutine+0x14</span><br><span class="line">	184fda54 7720ea5e 00000000 6f549168 184fdbf8 ntdll_771d0000!LdrpRunInitializeRoutines+0x26f (FPO: [Non-Fpo])</span><br><span class="line">	184fdbc8 7724d39f 184fdc38 184fdbf8 0dee0974 ntdll_771d0000!LdrpLoadDll+0x472 (FPO: [Non-Fpo])</span><br><span class="line">	184fdc04 76a42e0f 00000000 184fdc58 184fdc38 ntdll_771d0000!LdrLoadDll+0xc7 (FPO: [Non-Fpo])</span><br><span class="line">	184fdc4c 75d29c67 00000000 00000000 00002008 KERNELBASE!LoadLibraryExW+0x233 (FPO: [Non-Fpo])</span><br><span class="line">	184fdc68 75d29bea 00000000 184fdce4 00002008 ole32!LoadLibraryWithLogging+0x16 (FPO: [Non-Fpo]) (CONV: stdcall)</span><br><span class="line">	184fdc8c 75d29ad6 184fdce4 184fdcb0 184fdcb4 ole32!CClassCache::CDllPathEntry::LoadDll+0xaf (FPO: [Non-Fpo]) (CONV: stdcall)</span><br><span class="line">	184fdcbc 75d28fde 184fdce4 184fdfcc 184fdcdc ole32!CClassCache::CDllPathEntry::Create_rl+0x37 (FPO: [Non-Fpo]) (CONV: stdcall)</span><br><span class="line">	184fdf08 75d28eb3 00000001 184fdfcc 184fdf38 ole32!CClassCache::CClassEntry::CreateDllClassEntry_rl+0xd4 (FPO: [Non-Fpo]) (CONV: thiscall)</span><br><span class="line">	184fdf50 75d28db9 00000001 071100e8 184fdf7c ole32!CClassCache::GetClassObjectActivator+0x224 (FPO: [Non-Fpo]) (CONV: stdcall)</span><br><span class="line"><span class="variable">$&#123;$ntdllwsym&#125;</span>!RtlpStackTraceDataBase is NULL. Probably the stack traces are not enabled.</span><br><span class="line">-----------------------------------------</span><br><span class="line">DebugInfo          = 0x070be3a8</span><br><span class="line">Critical section   = 0x6f894060 (bcrypt+0x14060)</span><br><span class="line">LOCKED</span><br><span class="line">LockCount          = 0x1</span><br><span class="line">WaiterWoken        = No</span><br><span class="line">OwningThread       = 0x000021e4</span><br><span class="line">RecursionCount     = 0x1</span><br><span class="line">LockSemaphore      = 0xED8</span><br><span class="line">SpinCount          = 0x00000000</span><br><span class="line">OwningThread DbgId = ~18s</span><br><span class="line">OwningThread Stack =</span><br><span class="line">	ChildEBP RetAddr  Args to Child              </span><br><span class="line">	0b80e2bc 7721eb4e 00000250 00000000 00000000 ntdll_771d0000!NtWaitForSingleObject+0x15 (FPO: [3,0,0])</span><br><span class="line">	0b80e320 7721ea32 00000000 00000000 0b80e388 ntdll_771d0000!RtlpWaitOnCriticalSection+0x13e (FPO: [Non-Fpo])</span><br><span class="line">	0b80e348 77200329 772d20c0 7c9ba944 6f88275c ntdll_771d0000!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo])</span><br><span class="line">	0b80e3e4 77200262 6f840000 0b80e420 00000000 ntdll_771d0000!LdrGetProcedureAddressEx+0x159 (FPO: [Non-Fpo])</span><br><span class="line">	0b80e400 76a41f7c 6f840000 0b80e420 00000000 ntdll_771d0000!LdrGetProcedureAddress+0x18 (FPO: [Non-Fpo])</span><br><span class="line">	0b80e428 6f8826e6 6f840000 6f88275c 0dd7a980 KERNELBASE!GetProcAddress+0x44 (FPO: [Non-Fpo])</span><br><span class="line">	0b80e43c 6f882fbc 6f840000 0dd7a980 00000000 bcrypt+0x26e6</span><br><span class="line">	0b80e470 6f882dc8 0dd7a980 00000000 0dd63c20 bcrypt+0x2fbc</span><br><span class="line">	0b80e4c4 6f8564b4 0b80e4f0 76b6b79c 00000000 bcrypt+0x2dc8</span><br><span class="line">	0b80e4f4 6f856445 00000002 0b80e5b4 0b80e618 bcryptprimitives!CheckSignaturePadding+0x44 (FPO: [Non-Fpo])</span><br><span class="line">	0b80e530 6f886380 0dd7b1b8 0b80e5b4 0b80e618 bcryptprimitives!MSCryptRsaVerifySignature+0x90 (FPO: [Non-Fpo])</span><br><span class="line">	0b80e574 76b8515e 0dc37230 0b80e5b4 0b80e618 bcrypt+0x6380</span><br><span class="line">	0b80e5a8 76b8511a 0dc37230 76b6b79c 0b80e618 crypt32!I_CryptCNGSignAndEncodeHash+0x18d (FPO: [Non-Fpo])</span><br><span class="line">	0b80e5e0 76b84fc5 00000001 0044b478 00000000 crypt32!I_CryptCNGVerifyEncodedSignature+0xba (FPO: [Non-Fpo])</span><br><span class="line">	0b80e668 76b84eb4 76b6bf8c 00000001 0044b478 crypt32!I_CryptCNGVerifyCertificateSignedContent+0x15d (FPO: [Non-Fpo])</span><br><span class="line">	0b80e6d4 76b65db2 00000000 00000001 00000002 crypt32!CryptVerifyCertificateSignatureEx+0x242 (FPO: [Non-Fpo])</span><br><span class="line">	0b80e72c 76b65b7c 0de850b0 0ddb6358 00000000 crypt32!ChainGetSubjectStatus+0x90 (FPO: [Non-Fpo])</span><br><span class="line">	0b80e758 76b655a3 0de850b0 00000000 0ddb6358 crypt32!CCertIssuerList::CreateElement+0x51 (FPO: [Non-Fpo])</span><br><span class="line">	0b80e790 76b694fc 0de850b0 0de85128 07138910 crypt32!CCertIssuerList::AddIssuer+0x87 (FPO: [Non-Fpo])</span><br><span class="line">	0b80e7bc 76b6605d 00000002 0de850b0 0de85128 crypt32!CChainPathObject::FindAndAddIssuersFromCacheByMatchType+0x87 (FPO: [Non-Fpo])</span><br><span class="line"><span class="variable">$&#123;$ntdllwsym&#125;</span>!RtlpStackTraceDataBase is NULL. Probably the stack traces are not enabled.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有很多个，但是前两个就可以破案了。</p>
<p>18号线程：</p>
<p><code>0b80e348 77200329 772d20c0 7c9ba944 6f88275c ntdll_771d0000!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo])</code><br>进入了 0x6f894060 关键段，想要访问 0x772d20c0 这个关键段</p>
<p>47号线程：</p>
<p><code>184fd7f8 6f882f8e 6f894060 00000000 0dd63b7c ntdll_771d0000!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo])</code><br>进入了 0x772d20c0 关键段，但是想要进入 0x6f894060 关键段。<strong>造成死锁</strong>。</p>
<p>再看47号线程这部分，LockCount &#x3D; 0x187 有391个线程因为这个被锁住，跟线程数也差不多对的上，基本可以断定 0x772d20c0 这个关键段不能被正常释放导致。再分析两个线程的堆栈，可以看到都进入了 bcrypt 模块，基本可以判定 微软的 bcrypt 会存在死锁</p>
<p>去网上搜了一下，果然有人遇上同样的问题<br><a href="https://social.technet.microsoft.com/Forums/Lync/en-US/dee65a4a-ed42-426b-8540-427d2875154f/excel-365-may-experience-a-deadlock-while-opening-encrypted-spreadsheet?forum=Office2016ITPro">https://social.technet.microsoft.com/Forums/Lync/en-US/dee65a4a-ed42-426b-8540-427d2875154f/excel-365-may-experience-a-deadlock-while-opening-encrypted-spreadsheet?forum=Office2016ITPro</a><br>不是客户端本身代码问题，松了一口气，但是微软这个加密模块会存在死锁，感觉还是有点 emmm… 唔得行</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>一个加密的工具模块，竟然会用到锁，这个设计也是挺迷的。这个问题在 Win7 下出现过，Win10 还没有接到反馈。说到底 dotnet framework 这个设计还是为人所诟病的。运行时不能独立出来，对系统本身依赖太多。首先会因为用户本身的环境有问题，导致软件运行不正常；其次，还有一部分的问题因为用户的环境不同，有些会出问题，有些不会出问题，而且框架没得改。也难怪没有火起来。还好微软及时幡然悔悟，dotnet core 3 终于回归正轨。</p>
<p>WPF 这套开发效率确实是高，但是面对各种各样用户的系统环境，如果 dotnet 不能让人做到可以自己编译自己改，那就还是存在硬伤的。发现问题但改不动，微软对于框架本身的自信最终还是会害了自己。就看 dotnet 5 能不能有啥大突破了</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>Windbg</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 编程中的字符编码</title>
    <url>/2018/07/09/windows-character-encoding/</url>
    <content><![CDATA[<p>经常在写代码的时候需要处理宽字符，ASCII 字符，在代码中看到 wchar、char 等等。一般都是处理一个方法的时候发现需要的是某字符串，然后这边有什么字符串，之后查一个转换方法。还有对于 Unicode 、ANSI 这些不太分得清，所以花了一点时间看了一看。做个小结。</p>
<span id="more"></span>
<h1 id="编码介绍"><a href="#编码介绍" class="headerlink" title="编码介绍"></a>编码介绍</h1><h2 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h2><p>ANSI(American National Standards Institute) 其实并不算是一种固定编码，可以理解为在不同国家，有着不同的解释。例如在中国大陆，ANSI 编码指的就是 GBK 编码，在台湾地区指的是 BIG5 编码。所以一个场景下这种编码是有问题的，比方说一个保存为 ANSI 编码的文件，在不同区域的系统下，用记事本打开就会有问题，因为对文本的解释是不同的。例如在中国的系统上保存，其实就是 GBK 编码，然后在美国的系统上打开，会被当做 ASCII 编码来解释，就会出现问题。看不到想要的内容。(注：所以《 Windows 核心编程(第五版)》(下称《核心编程》)2.1节作者说到：<code>调用 strlen 会返回“以 0 结尾的一个 ANSI 单字节字符数组”中的字符数</code>，这个表述是不准确的，之所以这么说是因为作者所在的国家显然是 ASCII 编码，但是拿到中文这里说就不恰当，可以说是作者的锅也可以说是译者的锅。所以此书第二章所有讲到 ANSI，都可以理解为 ASCII 编码)</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode 标准(使用多字符编码)解决了 ASCII 编码这种单字符编码无法表示一些包含特别多字符的问题。官方的一段解释<code>The Unicode Standard provides a unique number for every character, no matter what platform, device, application or language. </code>，其实就是把每个字符作为一个具体数字 。对于 Unicode 标准，存在多种编码，例如：<code>UTF-8</code> 编码，<code>UTF-16</code> 编码等等。UTF(Unicode Transformation Format)，指的是 Unicode 转换格式。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>以下引用《核心编程》原文：</p>
<blockquote>
<p>UTF-8 将一些字符编码为 1 个字节(可以说就是那些 ASCII 字符)，一些字符编码为 2 个字节，一些字符编码为 3 个字节，一些字符编码为 4 个字节。根据 Unicode 的数字不同来区分应该编码为几个字节，属于<code>变长</code>字节编码。这样的好处是显而易见的，就是节省空间，坏处也是显而易见的，处理一些字符编码比较复杂的文本，显然效率会差，至少要不断判断是几个字节，计算长度就比较麻烦。</p>
</blockquote>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>UTF-16 就比较鸡贼了，如果细说就要扯到辅助平面和基本文字平面了，感觉意义都不是很大。简单理解就是一般字符(文字基本都是这个范畴)编码为 2 个字节，不一般的编码为 4 个字节(也就是 2 个 2 字节)。关于 UTF-16 连《核心编程》都没说，可见作者也是非常鸡贼了。</p>
<h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>UTF-32 这个算是最省事了，把 Unicode 值用 32 位无符号整数表示就得到了 UTF-32 的编码了。缺点也是显而易见的，贼占地方。</p>
<h3 id="BOM头"><a href="#BOM头" class="headerlink" title="BOM头"></a>BOM头</h3><p>经常在 Code Page 中看到带 BOM 头和不带 BOM 头。这个跟编码的大小端有关。对于这种多个字节的编码存在一个大小端的问题。如何来区分编码的大小端。Unicode 标准推荐使用一个 BOM(Byte Order Mark)来做区分。BOM 的字符编码是0xFEFF，这个叫做零宽无中断字符，这也解释了为什么你在文件里边去掉和添加 BOM 头都不会影响排版。所以 BOM 头的存在可以帮助判断文本的编码的大小端，如果没有 BOM 头的文本，在跨系统使用的时候，编辑器的实现可以做出两种做法：1. 会根据系统是大小端强行解释，这样的问题是一旦两个系统不一致，看到的内容也就完全不对了；2. 根据里边的数据，做一个判断，因为当大端被解释成小端有可能会出现 Unicode 中不存在的字符(如 BOM 头这个字符，0xFEFF存在，0xFFEF不存在)。在我看来显然应该是第一种做法。具体理由按下不表了。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><p>1 个字节(8 bit)。用来表示 ASCII 编码。</p>
<h2 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h2><p>2 个字节(16 bit)。用来表示 Unicode 字符(UTF-16)。当写出<code>wchar_t c = L&#39;A&#39;;</code>这行代码的时候，编译器会把<code>L</code>后边的东西用 UTF-16 来编码。值得一提的是<code>wchar_t</code>早期的 Microsoft 编译器并不支持。在那个上古时期有这样一个定义<code>typedef unsigned short wchar_t</code>。后来支持以后，编译器搞了一个编译开关<code>/Zc:wchar_t</code>，有这个的才在编译器定义这个数据类型，现在新建项目的时候会默认开启了。</p>
<h2 id="CHAR、WCHAR"><a href="#CHAR、WCHAR" class="headerlink" title="CHAR、WCHAR"></a>CHAR、WCHAR</h2><p>按照《核心编程》的说法：</p>
<blockquote>
<p>为了与 C 语言稍微有一些区分，Windows 开发团队希望定义自己的数据类型。</p>
</blockquote>
<ul>
<li>CHAR：<code>typedef char CHAR</code></li>
<li>WCHAR: <code>typedef wchar_t WCHAR</code></li>
<li>指针：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pointer to 8-bit character(s)</span></span><br><span class="line"><span class="keyword">typedef</span> CHAR *PCHAR;</span><br><span class="line"><span class="keyword">typedef</span> CHAR *PSTR;</span><br><span class="line"><span class="keyword">typedef</span> CONST CHAR *PCSTR</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pointer to 16-bit character(s)</span></span><br><span class="line"><span class="keyword">typedef</span> WCHAR *PWCHAR;</span><br><span class="line"><span class="keyword">typedef</span> WCHAR *PWSTR;</span><br><span class="line"><span class="keyword">typedef</span> CONST WCHAR *PCWSTR</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TCHAR"><a href="#TCHAR" class="headerlink" title="TCHAR"></a>TCHAR</h2><p><code>TCHAR c = TEXT(&#39;A&#39;)</code>。这个可以理解为万能类型，之所以这么说，可以看一下它的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> WCHAR TCHAR, *PTCHAR, PTSTR;</span><br><span class="line"><span class="keyword">typedef</span> CONST WCHAR *PCTSTR;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEXT(quote) L##quote</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> CHAR TCHAR, *PTCHAR, PTSTR;</span><br><span class="line"><span class="keyword">typedef</span> CONST CHAR *PCTSTR;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEXT(quote) quote</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT(quote) __TEXT(quote)</span></span><br></pre></td></tr></table></figure>
<p>所以看你的项目是否定义了 UNICODE 宏来决定 TCHAR 的类型，当然这个 UNICODE 宏还会影响 Windows API 调用函数版本的选择，后边细说。所以会看到大批文章告诉你解决什么编不过的问题都直接让你用 TCHAR 和 TEXT()。但我觉得并没有太大意义，至少我暂时想不到需要这两个版本都支持的场景。项目使用哪种数据类型明确一点会比较好，会影响到效率，后边细说。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>对于 Windows API 微软都会提供两个版本的例如 <code>CreateWindowExW</code>、<code>CreateWindowExA</code>，一个是宽字符版本，一个是单字符版本。当然如果你用<code>CreateWindowEx</code>，你会发现再配合 TCHAR 这套，显然也可以正常使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CreateWindowEx CreateWindowExW</span></span><br><span class="line"><span class="meta">#eles</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CreateWindowEx CreateWindowExA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>就是因为这个缘故。所以上边我说会影响到函数版本的选择。而效率问题，在 Windows Vista 上(当然可以理解为之后的版本也都如此) A 版本的函数其实只是一个转换层，将传入的 ASCII 字符转换成 Unicode 字符，然后调用 W 版本。所以这中间会有一个分配内存的过程，显然会有一个效率上的问题。所以其实现在写代码，非常推荐统一使用宽字符版本。</p>
<p>另外除了 Windows API 之外，C 运行库，也有类似的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _tcslen wcslen</span></span><br><span class="line"><span class="meta">#eles</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _tcslen strlen</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>只不过使用的是 _UNICODE 宏。所以不想让工程出现编码的混乱，显然 UNICODE、_UNICODE 是要成对出现的。事实上，现在用 Visual Studio 新建工程的时候，默认这两个都会定义上的。</p>
<h1 id="跨平台的坑"><a href="#跨平台的坑" class="headerlink" title="跨平台的坑"></a>跨平台的坑</h1><p>对于 wchar_t 在 Windows 平台是 UTF-16 编码，是 2 个字节的长度。而在 Linux 上是 4 个字节的长度，GCC 编译的时候会用 UTF-32 编码。这里边就会有一个不一致。要考虑编码转换问题。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>至此编程中需要的编码，大致了解清楚了。Windows 编程中，除非有特殊需要，否则一律使用宽字符是最好的选择。编码则选择 UTF-16 编码。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 Windows 编程中的堆</title>
    <url>/2018/08/20/windows-heap/</url>
    <content><![CDATA[<p>提起堆，大部分人都不陌生，但是其实很多人也不见得就很了解。我见过的大部分人，对堆的理解其实还停留在，全局的一种内存，速度没有栈快，不会自动销毁，需要开发人员自己管理。这其实不怪 Windows，怪就怪面试人员水平参差不齐，五百年了，问堆还是，堆栈究竟有什么区别。然后在中国这个应试教育横行的地方，也必然是各种针对性的突击，问八百个人都是上边的答案。然而，对于 Windows 的堆，作为一个开发人员，这些了解显然是不够的。</p>
<span id="more"></span>
<p>其实想深入了解 Windows 中的堆，仅需要两篇文章，日常开发就够用了。</p>
<ul>
<li>Heap: Pleasures and Pains<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/ms810466(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/ms810466(v=msdn.10)</a></p>
</blockquote>
</li>
<li>Managing Heap Memory<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/ms810603(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/ms810603(v=msdn.10)</a></p>
</blockquote>
</li>
</ul>
<p>这两篇文章，说的还算详尽，至少基本的开发会清晰很多。</p>
<h2 id="堆的使用条件"><a href="#堆的使用条件" class="headerlink" title="堆的使用条件"></a>堆的使用条件</h2><ul>
<li>当程序需要的对象不能提前知晓的时候，也就是说需要在运行时动态分配的对象，要在堆上</li>
<li>栈上放不下的对象，要在堆上</li>
</ul>
<h2 id="堆的种类"><a href="#堆的种类" class="headerlink" title="堆的种类"></a>堆的种类</h2><p>这里要引用一段 MSDN 原文：</p>
<blockquote>
<p><strong>GlobalAlloc&#x2F;GlobalFree</strong>: Heap calls that talk directly to the per-process default heap.</p>
<p><strong>LocalAlloc&#x2F;LocalFree</strong>: Heap calls that talk directly to the per-process default heap.</p>
<p><strong>COM’s IMalloc allocator (or CoTaskMemAlloc &#x2F; CoTaskMemFree)</strong>: Functions use the default per-process heap. Automation uses the Component Object Model (COM)’s allocator, and the requests use the per-process heap.</p>
<p><strong>C&#x2F;C++ Run-time (CRT) allocator</strong>: Provides malloc() and free() as well as new and delete operators. Languages like Microsoft Visual Basic® and Java also offer new operators and use garbage collection instead of heaps. CRT creates its own private heap, which resides on top of the Windows heap.</p>
</blockquote>
<blockquote>
<p>Traditionally, the operating system and run-time libraries come with an implementation of the heap. At the beginning of a process, the OS creates a default heap called Process heap. ** The Process heap is used for allocating blocks if no other heap is used. Language run times also can create separate heaps within a process. (For example, C run time creates a heap of its own.) Besides these dedicated heaps, the application program or one of the many loaded dynamic-link libraries (DLLs) may create and use separate heaps. Windows offers a rich set API for creating and using private heaps.</p>
</blockquote>
<p>从这段描述上看：</p>
<ul>
<li>每个进程会有一个默认堆</li>
<li>C&#x2F;C++ 运行时会有自己的私有堆。</li>
<li>进程中用到的模块，允许创建自己的私有堆。</li>
</ul>
<p>这就非常清晰了。这也就是传说中的<strong>一个模块一个堆</strong>。而关于堆的种类的认知是非常必要的，因为对于堆上的内存，要本着<strong>谁申请谁释放</strong>的原则，如果在模块的私有堆中申请的内存，拿到模块外由别人释放，就会引发崩溃，因为别人释放的时候会去自己的堆中找那部分内容，找不到就GG了。</p>
<p>而其实在 Windows 中关于堆分配器，其实是有前后端之分的。前端分配器维护一个固定大小的块列表，一个内存分配过来以后先在列表中找未被使用的块，如果找不到才会到后端分配器，新分配出一个块，并且后端分配器还会把这个操作提交到虚拟内存。因为有前后端分配器之分，所以性能问题肯定也会在这中间产生。一个显而易见的就是如果用到后端分配器的操作，必然会比只用前端分配器慢，所以解决这种性能问题还是尽量避免后端分配器操作。</p>
<h2 id="堆的性能问题"><a href="#堆的性能问题" class="headerlink" title="堆的性能问题"></a>堆的性能问题</h2><ul>
<li>内存分配<blockquote>
<p>内存分配导致的慢主要还是在于当前端分配器找不到可用块时，调用后端分配器，创建新块，以及跟虚拟内存的交互会有性能损耗</p>
</blockquote>
</li>
<li>内存释放<blockquote>
<p>内存释放导致的慢是由于释放内存会有一个块合并的操作，将空闲块合并到一起重组成一个大的空闲块，但是这中间会引发对内存的无序访问，导致缓冲命中失败和性能下降。</p>
</blockquote>
</li>
<li>堆竞争<blockquote>
<p>在多线程的情况，出现多个线程访问一个堆，需要有一个等待过程。而加锁，会引起线程的上下文切换也是性能下降的原因之一。</p>
</blockquote>
</li>
<li>堆破坏<blockquote>
<p>程序没有正确使用堆导致对破坏</p>
</blockquote>
</li>
<li>频繁的 alloc 和 realloc<blockquote>
<p>脚本语言容易发生，不过现在的脚本语言解释器都比较机智了，都会分配一块很大的内存自己用，来避免这个。</p>
</blockquote>
</li>
</ul>
<h2 id="提升堆性能的一般操作"><a href="#提升堆性能的一般操作" class="headerlink" title="提升堆性能的一般操作"></a>提升堆性能的一般操作</h2><ul>
<li>避免使用指针关联两个数据结构<blockquote>
<p>使用指针关联两个数据结构会导致对象的分配和释放被分离，产生额外开销。</p>
</blockquote>
</li>
<li>把孩子对象嵌入父亲对象。<blockquote>
<p>减少额外分配内存的次数。</p>
</blockquote>
</li>
<li>合并小对象组成一个大对象(聚合)<blockquote>
<p>可以减少被分配的块的数量来提升性能，关键是要找好聚合边界</p>
</blockquote>
</li>
<li>用 Buffer 满足 80% 的需求(二八原则)<blockquote>
<p>用内存 Buffer 存储字符串或者二进制数据，开一个能满足 80% 需求的大小的 Buffer 即可。剩下 20% 可以开一个新的 Buffer，然后持有指针即可。这样可以减少内存分配和释放，也可以减少数据空间，会提升性能</p>
</blockquote>
</li>
<li>成块分配内存对象<blockquote>
<p>小声BB(我个人理解就是指内存池)</p>
</blockquote>
</li>
<li>使用<code>_amblksiz</code><blockquote>
<p>C语言运行时(CRT)特有的前端分配器，可以用它跟后端分配器申请分配一个比较大的块，从而减少对后端分配器的请求。</p>
</blockquote>
</li>
</ul>
<h2 id="提升堆性能的进阶操作"><a href="#提升堆性能的进阶操作" class="headerlink" title="提升堆性能的进阶操作"></a>提升堆性能的进阶操作</h2><ul>
<li>使用 Windows Heap</li>
<li>使用内存池</li>
<li>使用 MP Heap。(一个多进程友好的包)</li>
<li>重新思考算法与数据结构</li>
</ul>
<h2 id="改善堆性能之前需要做的"><a href="#改善堆性能之前需要做的" class="headerlink" title="改善堆性能之前需要做的"></a>改善堆性能之前需要做的</h2><ol>
<li>评估代码中堆的使用方法</li>
<li>梳理代码，减少关于堆的调用，修复错误并调整数据结构</li>
<li>要对堆的性能消耗做具体评估</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多人会认为这些过于底层，对一般开发用处不大，但其实对堆的深入了解，除了可以在程序性能上有一些更大的提升，对于一般开发则可以写出质量更高的代码。只有对操作系统的了解足够的深入，才能写出跟操作系统有着完美配合的代码，这看似是一种玄学，其实是一种科学。是基于 Windows 平台开发应用的开发人员与操作系统的开发人员的一种默契。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>说说 Windows 编程中 /MT、/MD 的区别</title>
    <url>/2018/08/26/windows-mt-md-diff/</url>
    <content><![CDATA[<p>Windows 编程中无法绕开的编译开关 <strong>&#x2F;MT</strong>、**&#x2F;MD** 其实还有一个 <strong>&#x2F;LD</strong>，不过后者很少见。之前对这些一直没有一个清晰的概念，所以就查阅了相关资料。算是对这块有了一个粗浅的认识。</p>
<p>其实最直观的资料还属 <a href="https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=vs-2017">MSDN</a></p>
<p><strong>&#x2F;MT</strong>、**&#x2F;MD** 其实一言以蔽之，就是运行时的库是静态链接还是动态链接。**&#x2F;MTd<strong>、</strong>&#x2F;MDd** 是他们的 <em>debug</em> 版本。所以他们的选择最直接的就是影响生成文件的大小。静态链接显然会大，动态链接则要求目标机器有需要的运行时库文件。其实我见过的大部分应用还是选择 <strong>&#x2F;MD</strong> 比较多，因为在它们的安装目录下会看到 <em>MSVCRTXXX.dll</em> 。显然是带了运行时库的。</p>
<p><strong>&#x2F;LD</strong> 是创建一个 DLL。如果以 <em>&#x2F;LD</em> 编译，代码中没有写 DLL 入口点，编译器会自动插入一个入口点。值得一提的是这个编译开关默认是 <strong>&#x2F;MT</strong>。 除非显式定义 <strong>&#x2F;MD</strong>。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 Windows 编程中的 Thread</title>
    <url>/2018/08/21/windows-shallow-thread/</url>
    <content><![CDATA[<p>线程对于 Windows 编程人员来说，并不陌生，但是一直以来，我对它的了解也只是基本的使用层面。对于很多细节，也并不是很了解。这作为一个 Windows 客户端开发人员，可以说是非常尴尬了。所以，抽了一点时间，仔细梳理了一下线程相关的内容。顺便记录下来。</p>
<span id="more"></span>
<h2 id="一些常识"><a href="#一些常识" class="headerlink" title="一些常识"></a>一些常识</h2><ul>
<li>基本状态：就绪，执行，阻塞</li>
<li>堆公有、栈私有</li>
<li>创建和结束所需要的系统开销：小</li>
<li>没有自己的地址空间</li>
</ul>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>在 Windows 下创建一个线程，很自然的会想到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CreateThread</span>(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line">    _In_ SIZE_T dwStackSize,</span><br><span class="line">    _In_ LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class="line">    _In_opt_ __drv_aliasesMem LPVOID lpParameter,</span><br><span class="line">    _In_ DWORD dwCreationFlags,</span><br><span class="line">    _Out_opt_ LPDWORD lpThreadId</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>这个方法可以说对 Windows 应用开发人员并不陌生。当使用这个方法的时候，在平时使用的时候，比较多关注的就是<code>lpStartAddress</code>、<code>lpParameter</code>。这是线程函数的入口以及参数。创建一个新线程之后，将会从这里开始执行。</p>
<p>但是对于 C++ 来说，其实有另一个方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_ACRTIMP <span class="type">uintptr_t</span> __cdecl _beginthreadex(</span><br><span class="line">    _In_opt_  <span class="type">void</span>*                    _Security,</span><br><span class="line">    _In_      <span class="type">unsigned</span>                 _StackSize,</span><br><span class="line">    _In_      _beginthreadex_proc_type _StartAddress,</span><br><span class="line">    _In_opt_  <span class="type">void</span>*                    _ArgList,</span><br><span class="line">    _In_      <span class="type">unsigned</span>                 _InitFlag,</span><br><span class="line">    _Out_opt_ <span class="type">unsigned</span>*                _ThrdAddr</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>在这里，<code>_StartAddress</code>、<code>_ArgList</code>则跟上述那两个参数是类似的作用。<br>然而在这两个方法的选择中，《Windows 核心编程》早有公断。</p>
<p>根据作者的说法是选择<code>_beginthreadex</code>替代<code>CreateThread</code>。而原因则要从<code>_beginthreadex</code>的实现上说起。</p>
<p><code>_beginthreadex</code>在 Windows 下的实现也是调用了<code>CreateThread</code>，毕竟在 Windows 系统中，只认这一种创建线程的方式。但是在这之前，它还会做一些额外工作。创建一个线程数据块( tiddata )，然后将入口和参数都保存到数据块中，最后还要把数据块保存在 TLS 中。之后还要初始化一个 SEH 帧，用来处理运行时产生的错误。然后在线程结束之前，释放掉 tiddata 。那这样看，确实要比<code>CreateThread</code>多做一些事情。</p>
<p>话说回来，如果不做这些事情，当然就会有问题。比较直接的问题就是内存泄漏。原因是，如果使用<code>CreateThread</code>创建线程，当调用一些运行库函数的时候，会检查这个 tiddata 。如果发现没有，则会自己搞出一个，而这个在线程结束的时候，就不会被正确释放，就出现了内存泄漏。</p>
<p>类似<code>errno</code>这种运行库函数，需要反应正确的错误信息，如果不记录线程相关信息，则会在多线程的时候出现错误，所以一个 tiddata 是必要的，这也说明了为什么这个 tiddata 无论什么情况都会存在。</p>
<p>所以综上所述，在创建线程是，应该选择<code>_beginthreadex</code>。</p>
<p>关于更详细的<code>_beginthreadex</code>内容，参考 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=vs-2017">_beginthread, _beginthreadex</a> 这篇文章是最好了</p>
<h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p>上边说的 TLS。可谓是线程中不可缺少的东西。因为线程之间是共享地址空间的，所以当有一些每个线程自己所需要的数据的时候，就不那么方便。而 TLS 就是用来解决这个问题。存储在 TLS 中的数据，对于每个线程之间，是互相隔离的。</p>
<h2 id="结束线程"><a href="#结束线程" class="headerlink" title="结束线程"></a>结束线程</h2><p>尽可能的让线程执行完自然结束。不到万不得已的时候，都不要使用<code>ExitThread</code>或者是<code>_endthreadex</code>。因为会使主调线程不正常返回，导致构造的 C++ 对象都不会析构；如果使用<code>ExitThread</code>还会造成 tiddata 不会被释放。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>关于多线程编程其实坑不算少，唯有对 Thread 多一些了解，才能写出更高质量的代码。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>狼人杀中的诈身份</title>
    <url>/2018/09/30/wolfkill-cheat-id/</url>
    <content><![CDATA[<p>狼人杀中，诈身份可谓是最常见的行为，无论是新手还是老手都喜欢使用这个伎俩。但是很遗憾并不是所有人都能用好这一技术手段。狼人杀这个游戏有方法、无定法，所以特将诈身份的一般套路整理出来，以备日后翻看。</p>
<span id="more"></span>
<h2 id="诈身份的手段"><a href="#诈身份的手段" class="headerlink" title="诈身份的手段"></a>诈身份的手段</h2><p>常用的诈身份手段：</p>
<ul>
<li>警上跳预言家发后置位查杀（金水）</li>
<li>警上跳女巫声称盲毒后置位</li>
<li>警上接到查杀跳猎人钢板</li>
</ul>
<h2 id="诈身份的目的"><a href="#诈身份的目的" class="headerlink" title="诈身份的目的"></a>诈身份的目的</h2><p>通常大部分人只记得上述行为可以诈身份，但是并没记住诈身份的目的是什么。</p>
<p>首先要明确的是，任何行为都要有收益，这是一条公认的事实，否则好人不为好人玩，这个游戏就会变得扑朔迷离。</p>
<p>而诈身份的<strong>收益</strong>或者说<strong>目的</strong>在于</p>
<blockquote>
<p>炸出来狼牌，可以帮助好人排出隐在好人堆里的一狼。</p>
</blockquote>
<h2 id="不同手段的使用方法"><a href="#不同手段的使用方法" class="headerlink" title="不同手段的使用方法"></a>不同手段的使用方法</h2><p>回头来看几种诈身份的手段</p>
<h3 id="跳预言家"><a href="#跳预言家" class="headerlink" title="跳预言家"></a>跳预言家</h3><p>有的人上警随便跳一个预言家给后置位发一个查杀，警徽流也没有。</p>
<p>有的人跳预言家刚在警上不退水，说是为预言家挡刀。</p>
<p>有的人觉得发警下查杀不构成诈身份退不了水。</p>
<p>有的人觉得发金水不构成诈身份退不了水。</p>
<p>这些说法或做法都有些绝对。因为没有抓住诈身份的目的。</p>
<h4 id="有收益的诈身份"><a href="#有收益的诈身份" class="headerlink" title="有收益的诈身份"></a>有收益的诈身份</h4><ul>
<li><p>发到真正的狼牌查杀，且状态像个预言家</p>
<blockquote>
<p>当你漫不经心的随便给后置位发一个查杀，发到好人身上，这次诈身份的收益为0。因为你并不能找到狼牌是哪个，狼人也不会因为你刚在警上不退水认你是真预言家，因为你发错查杀这是个铁逻辑，并不可能是预言家。另一方面好人会怼死你，碰巧是个神牌还会逼神牌起跳，收益为负，这是搅乱场上局势，不如不炸。</p>
</blockquote>
</li>
<li><p>发到真正的好人金水，且状态像个预言家</p>
<blockquote>
<p>首先说发警下金水不构成诈身份退不了水，这个观念只能是55开：确实不构成诈身份，但是退水还是可以退的。在白狼王的局里，好人通过发查杀挡刀远不如发金水更容易迷惑狼人，因为发到正确查杀的概率是36.4%，而发到正确金水的概率是63.6%。</p>
</blockquote>
</li>
</ul>
<h4 id="So-Sad"><a href="#So-Sad" class="headerlink" title="So Sad"></a>So Sad</h4><p>当没有把握做到这两点，茫茫多的人漫不经心的跳预言家诈身份，且刚在警上不退水，最终的后果是什么呢。</p>
<blockquote>
<p>即使你想脱衣服，但是也晚了，因为茫茫多的好人起跳预言家，导致好人根本记不住所有人的警徽流，当然包括真预言家的警徽流，后边即使所有人都脱衣服，狼人两爆，预言家第二个验人拿到警徽都说不出来，等于好人自己把警徽吞了</p>
</blockquote>
<h3 id="跳女巫"><a href="#跳女巫" class="headerlink" title="跳女巫"></a>跳女巫</h3><p>我最开始看到这个套路来自pandakill。属于南派狼人杀的一种打法（即状态流）。不经意抛出盲毒的信息，去看被毒人的反应。</p>
<p>要求抿卦相一流，但是因人而异。</p>
<h4 id="有收益的诈身份-1"><a href="#有收益的诈身份-1" class="headerlink" title="有收益的诈身份"></a>有收益的诈身份</h4><ul>
<li>要盲毒一个警上后置位容易抿卦相的人，抿完了抓紧退水，警下再给分析。<blockquote>
<p>盲毒老油条，当然什么都看不出来。抓紧退水的原因是，防止狼人爆，来不及脱衣服，被女巫在夜里直接解决了，虽然一般局，女巫撒毒不会撒的这么随意。但是难保有义愤填膺的。</p>
</blockquote>
</li>
</ul>
<h3 id="跳猎人"><a href="#跳猎人" class="headerlink" title="跳猎人"></a>跳猎人</h3><p>这个套路，其实是蛮推荐的一个套路，人畜无害。并且这也是反制悍跳预言家的一个策略。从狼人的心里角度出发，当狼人发你查杀，且给了充足时间让他退水，不退水，跳一张钢板认出，对狼的心理压力很大。</p>
<h4 id="有收益的诈身份-2"><a href="#有收益的诈身份-2" class="headerlink" title="有收益的诈身份"></a>有收益的诈身份</h4><blockquote>
<p>开始你的表演，给他充足的退水时间，然后勇敢的起跳，表示认出，总之演技决定一切</p>
<p>风险：第一天被刀的是猎人，解释不清楚，有可能就把你带走了。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然任何套路被用的稀烂的时候，都不是好套路，所以当我说出这些的时候，可能我自己都不会选择这几种方式了。</p>
<p>除了找出谁是真正的狼人、成功伪装自己之外，发挥自己的思路，开发让人耳目一新的打法，也狼人杀的乐趣所在。</p>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>狼人杀</tag>
        <tag>桌游</tag>
      </tags>
  </entry>
  <entry>
    <title>狼人杀无纸化打法</title>
    <url>/2018/09/20/wolfkill-no-paper/</url>
    <content><![CDATA[<p>在桌游吧跟专业玩家或者是在公司跟同事玩狼人杀都会遇上拿着纸笔或者是手机认认真真记录发言票型的玩家，对于狼人杀这个信息爆炸的游戏，确实记录是有必要的。而下边我要说的则是一种虽然记忆力不是很好，但抛开纸笔、手机的一种玩法。对于聚会娱乐这种场景的狼人杀也不失为一个可选方案。</p>
<span id="more"></span>
<h1 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h1><p>狼人杀是一个判断逻辑、考验发言的游戏，在游戏过程中会产生大量的信息，对于信息的处理至关重要，同时发言对游戏走势又有着至关重要的影响。</p>
<h2 id="逻辑归一化"><a href="#逻辑归一化" class="headerlink" title="逻辑归一化"></a>逻辑归一化</h2><p>很多人喜欢准备一张纸，记录一些信息，因为信息量爆炸，很多时候记不住，这里提供一种无纸化狼人杀的打法。核心叫做逻辑归一化。</p>
<p>所谓的逻辑归一化，就是通过对信息的整理和判断，将每一轮的信息，最后汇总筛选，只记录最有用的信息。</p>
<p>这个过程需要两种方式来处理。剪枝和去重。</p>
<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>剪枝指的是屏蔽掉无用信息。</p>
<p>例如对于一个认狼出局的发言，他的信息是具有迷惑性的，对于点出他的狼同伴。他可以打一个正逻辑，说出一些假的狼同伴；也可以打一个反逻辑，说出所有的真的狼同伴。而对于这个信息，是没有逻辑支点(逻辑支点的概念下边有说)的，所以这个信息是不具有参考价值的。</p>
<p>例如票型，对于每一轮的票型，全部都能记住是最好的，但是在没有纸张的情况下，则要选择最关心的几个人的票型，每一轮的发现都会有几个焦点人物出现，而焦点人物的票型就至关重要。</p>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>去重指的是屏蔽跟风式发言，和重复性发言。</p>
<p>当第二个人重复一个信息的时候，其实对于第二个人来说，相当于没有发言。划水式发言等于直接说过，也没有必要记录。</p>
<h2 id="寻找逻辑支点"><a href="#寻找逻辑支点" class="headerlink" title="寻找逻辑支点"></a>寻找逻辑支点</h2><p>逻辑支点指的是支撑整套逻辑的事实依据。所谓的铁逻辑指的便是有一个强有力的逻辑支点制成的逻辑。</p>
<p>可以做成逻辑支点的有：</p>
<ul>
<li>票型</li>
<li>明显的个人习惯</li>
<li>事实矛盾</li>
</ul>
<p>(一言以蔽之，就是极大概率事件)</p>
<h2 id="逻辑与概率"><a href="#逻辑与概率" class="headerlink" title="逻辑与概率"></a>逻辑与概率</h2><p>狼人杀是一个软逻辑游戏，与之对应的是抵抗组织这种硬逻辑游戏，抵抗组织的好人必须出执行成功，而狼人杀对任何人都没有限制。软逻辑游戏，在很多情况下都没有什么必然。久而久之会把自己陷入一种困境，在正反逻辑盘开以后，发现怎么说都有理，对于现状分析不清。其实则是自己没有找到强有力的逻辑支点，知道游戏结束，找不到一个铁逻辑。</p>
<blockquote>
<p>就我个人举例：</p>
<p>第二天白天6号、7号上警跳预言家，两人发言都没有毛病，我12号因为在7号警徽流里，所以上票7号，但7号只吃到我一票，6号当选警长。</p>
<p>警下发言，我是站边7号，理由是，在两个预言家发言都很不错的情况下，狼人是没必要压手的，给队友上票总能找到充分的理由。</p>
<p>但是第二天我听了6号的发言，觉得6号发言的状态很好，跟狼人一起把7号真预言家投了出去</p>
<p>这里就犯了一个错误，以发言状态代替了票型这个逻辑支点，而发言状态是不能作为逻辑支点，支撑整个逻辑体系的，所以才会导致做了狼助。</p>
</blockquote>
<p>狼人杀是个概率游戏，但是人的性格是很难改变的，再加上狼人杀是一个多人游戏，所以搏大概率事件做逻辑支点，是保持胜利的比较容易的方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结合逻辑归一化去处理信息，总能把茫茫多的信息汇总到一点或者几点，最终将这一点跟推出的逻辑支点相结合，确定场上的局面。</p>
<p>这个打法并不是十全十美。</p>
<p>因为剪枝和去重是一个局部性的处理，并没有考虑全局最优，这样就会有一定的局限性，如果恰好某个重要信息被屏蔽掉了，也再难以重新回头了。</p>
<p>因为将所有的信息绑定到一个逻辑支点，假如选错了逻辑支点，就会一愚到底，难以回头。</p>
<p>但是在无纸的情况下，不失为一种可选择的打法。</p>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>狼人杀</tag>
        <tag>桌游</tag>
      </tags>
  </entry>
  <entry>
    <title>狼人杀分享总结</title>
    <url>/2018/09/12/wolfkill-share/</url>
    <content><![CDATA[<p>在公司的时候，作为狼人杀协会的会长，兼鱼塘塘主，给萌新做过一次狼人杀分享会，同时也是对自己玩狼人杀的思路的梳理，记录下来，便于日后翻阅。</p>
<span id="more"></span>
<h1 id="狼人夜间手势"><a href="#狼人夜间手势" class="headerlink" title="狼人夜间手势"></a>狼人夜间手势</h1><ul>
<li>角色：<blockquote>
<p>预言家、女巫、白痴、猎人、守卫、丘比特、狼人、恶魔</p>
</blockquote>
</li>
<li>行动：<blockquote>
<p>悍跳、煽动、隐、倒钩、发金水、发查杀、上警、警下、自刀、下一夜、(恶魔)查验、自爆、推(砸)</p>
</blockquote>
</li>
</ul>
<h1 id="狼人分工"><a href="#狼人分工" class="headerlink" title="狼人分工"></a>狼人分工</h1><ul>
<li>悍跳狼(上警)：</li>
</ul>
<blockquote>
<p>对于发金水还是发查杀，要有清晰的认识。一般基于以下几点：</p>
<ul>
<li>目标是一张摇摆不定的牌，有机会骗到他，发金水拉票</li>
<li>目标已经明确被抿出是一张民牌，且发言一般般，发查杀做扛推</li>
<li>前置位对跳的真预言家博得了很多好人的信任，这个时候要考虑的是发到哪一张牌的验人力度是最大的，才能拉到票。</li>
</ul>
</blockquote>
<ul>
<li>冲锋狼、煽动狼(大概率上警)：</li>
</ul>
<blockquote>
<p>是要为悍跳狼号票的一张牌，可以说两个人是一条绳上的蚂蚱，任何一个人发言的失误，俩人都要炸。</p>
</blockquote>
<blockquote>
<p>如果是在警上，除了煽动随时都要准备起跳，也就是我们常说的那张补位狼牌。前置位悍跳狼为了博力度去发警上后置位金水恰好发到真预言家，这个时候如果没有队友救，就是白送一狼。作为补位狼牌要做的就是起跳预言家，给悍跳狼机会退水</p>
</blockquote>
<ul>
<li>隐狼(一般不上警)：</li>
</ul>
<blockquote>
<p>很多人觉得隐狼就是倒钩狼，这是非常错误的。隐狼的自由度是很大的，他要根据场上形势自己判断是倒钩还是冲锋。他的目的只有一个，别把自己打成焦点，一直狗到狼人获胜，好人先于他死光了，他的目的就达到了。</p>
</blockquote>
<ul>
<li>倒钩狼(上不上警看自己心情)：</li>
</ul>
<blockquote>
<p>倒钩狼就是传说中的卧底。倒钩狼的行动是倒钩，但是目的不是倒钩。他的目的是要让狼人获胜。对于场上的局势判断至少要分两部分：</p>
</blockquote>
<blockquote>
<ul>
<li>队友悍跳成功，博得了一部分好人的信任，可以跟真预言家55开，这个时候，倒钩狼牌就是想办法不动声色的(太爆炸自己就被好人干出局了)做低真预言家面，或者是在末置位，以一种巧妙地方式分了好人的票，帮助狼人冲票成功(所谓的阴阳倒钩狼)</li>
<li>队友悍跳失败，基本上大家已经准确站边，这个时候优先保证的是做好自己身份，博得好人的信任，甚至可以第一个点出队友的狼面，用巧妙地语言改掉预言家落在自己身上的警徽流。</li>
<li>在判断局势的同时，既然自己倒钩了真预言家，那狼坑就一定少一个，要准确的找到场上的晕民，把他们打进狼坑，做后边的扛推。</li>
</ul>
</blockquote>
<h1 id="逻辑推论常识与经验"><a href="#逻辑推论常识与经验" class="headerlink" title="逻辑推论常识与经验"></a>逻辑推论常识与经验</h1><ul>
<li>常识</li>
</ul>
<blockquote>
<ul>
<li>金水反水立警，身份最高</li>
<li>两个<strong>对立阵营</strong>打成的公共狼大概率是一张狼牌(倒钩狼和狼队友发出的公共狼可能是一个好人)；两个<strong>对立阵营</strong>公认的公共好人牌非常大概率是一张好人牌</li>
<li><strong>真预言家和悍跳狼</strong>发到的双查杀一定是一张狼人牌；<strong>真预言家和悍跳狼</strong>发到的双金水一定是一张金水牌。</li>
<li>预言家的两夜警徽流：1.验到一好人一狼人，警徽飞好人；2.两狼人警徽外置位飞；3.两好人警徽撕掉</li>
</ul>
</blockquote>
<ul>
<li>经验<blockquote>
<ul>
<li>村民:发言阳光，不被扛推是第一要义。在这个基础上最好能晚点再让狼人抿出闭眼民的身份；警上后置位接了金水之后可以反水立警刚一会看看对方的态度，诈一诈；一定要站边，因为站边之后你的尸体都会说话，不站边，死也是白死。只有在你明确的知道你压手是为了什么才压手，永远不要在你分不清要投给谁的时候压手。</li>
<li>女巫:1、管理好你的银水，如果你自己都定不了他是自刀狼还是真银水，不要指望其他人可以判断清楚；2、所以女巫开药的对象一定得是你能摸得准的，也就是说，救起来他你去听发言可以定他身份的。3、在解药用掉之后的晚上你摸不准守卫会不会守你，那一定要撒毒。如果你死了，药没撒出来，且没有遗言，保不齐后边狼人就会在末置位要被出的情况下跳一张女巫，然后冲一张好人牌，跟你这瓶药撒到好人身上没区别。</li>
<li>狼人：在夜里去打一层逻辑，白天发言去盘二层逻辑，或者反之。</li>
<li>如果你盘对跳的两个预言家盘狼坑都盘不齐，或者找出五六匹狼，那大概率有狼倒钩了</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="团队收益论"><a href="#团队收益论" class="headerlink" title="团队收益论"></a>团队收益论</h1><ol>
<li>团队最大</li>
<li>你的行为一定要为团队带来收益</li>
<li>是否算是为团队带来收益要从队友出发考虑(即你的做法会不会被队友认可)</li>
</ol>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>狼人杀</tag>
        <tag>桌游</tag>
      </tags>
  </entry>
  <entry>
    <title>『眼中有泪，心中有光』，年轻真好</title>
    <url>/2021/07/12/youthful-bliss/</url>
    <content><![CDATA[<p>最近读了两本诗集：《姜二嫚的诗》和《大山里的小诗人》。</p>
<p>《姜二嫚的诗》很早就在我的书单中了，也是偶然间，看到了那句『灯把黑夜，烫了一个洞』，让我很早就把这本书列在了书单里；而《大山里的小诗人》则是因为前一阵子看了一部纪录片《人生第一次》，看到了书中的几首诗，我便毫不犹豫地把这本书加入了书单。</p>
<span id="more"></span>
<p>书到了之后，只用了三个晚上我便将两本诗集都读了一遍。读完之后，我花了很长时间试图找到一些形容词来准确的形容书中的这些诗和写诗的小诗人们，但是失败了。震撼但并不能准确把握为什么而震撼，这也是我为什么迟迟没有动笔的原因。</p>
<p>提到《大山里的小诗人》这本书，就不得不提到一个组织—— <strong>是光。</strong>这是一个乡村诗歌教育公益组织，简单来说就是教乡村孩子写诗的一个组织。“是光”的口号是：会写诗的孩子不砸玻璃。听着倒是朴实无华。而这本书便是“是光”整理了这些孩子们写的诗，做成的一本诗集。</p>
<p>让我决定买《大山里的小诗人》这本书的，大概就是施应锁小朋友的那首诗。</p>
<Center>《朋友》</Center>
<Center>放学回家的路长长的</Center>
<Center>只有我一个</Center>
<Center>家里的牛圈大大的</Center>
<Center>只有小牛一头</Center>
<Center>当我抱住它的时候</Center>
<Center>我们都有了朋友</Center>

<p>第一次听到这首诗，便被深深的触动，这是一个12岁的小孩子写的。我的第一感觉是不敢相信这是一个小孩子写出来的，但是想想又觉得非常合理。在这本书中还有很多这样的宝藏诗句。</p>
<p>相比之下《姜二嫚的诗》，我读完之后，第一感觉是有点过誉了。这并不是对一个小孩子的苛责，在我看来小孩子的想象力是无限的，只是还不能熟练运用，很多金句需要来自灵光一闪。但是强行凑数凑成一本诗集，不把控质量，这就是大人的问题了。除了那首《灯》，确实没有再看到其他更让人惊艳的诗句。</p>
<p>其实对于诗集内容来说，倒是没有必要花太多篇幅去描述，毕竟诗不同于小说或者散文一类的。在我写这段文字的时候，我是试图想搞清楚我自己为什么会觉得震撼。或者说到底是什么震撼了我。</p>
<p>我想了很久，最终我选了三个词。童真、希望、想象力。</p>
<ul>
<li>童真：儿童特有的天真和那种对情感直接且细腻的表达，没有成年世界的规则和关系划分，那种对世界上所有事物的一视同仁和儿童特有的同理心。</li>
<li>希望：他们心中对未来有美好的憧憬，永远抱有希望。即使是悲伤，也看不出成年人的那种丧。</li>
<li>想象力：成年人所谓的脑洞。</li>
</ul>
<p>他们没有成年人所谓的经验和技巧，也没有成年人的“路径依赖“；他们把雨滴当作乌云和白云结婚的喜糖，把小牛当成朋友；他们慢慢地走路因为不舍得影子跟着他们太累；他们能感觉到黑板被写的时候的痛；他们认为沙滩是海浪的宝宝，海浪不断亲吻着沙滩……</p>
<p>而震撼的另一方面，也许是这些诗集勾起了我某些想法。</p>
<p>我自己其实是有每隔一两年就翻看一下小时候日记和习作的习惯的，曾经的我何尝不是像他们一样，可是现在我却一点点丢失了这些品质，变得只能羡慕……</p>
<p>还记得，我职业生涯的第二份工作入职的前一天，2019.03.24，我在朋友圈写下了一段话，”<strong>我给自己的下一个目标是做一道光，纵然未来有太多的不确定，无法掌握，但只要我能掌握自己也就足够了。</strong>“，如今看着这些诗，总觉得似乎诗中的光穿透了纸面，照进了我的内心。</p>
<p>之前的《后浪》有句经典的话用来描述青年，『心中有火，眼里有光』，在我看来，写出了青年的冲劲。不妨把它改一改，改成『<strong>眼里有泪，心中有光</strong>』送给少年们，用来描述这些孩子那份弥足珍贵的童真和对未来的希望。</p>
<p>年轻真好……希望他们能永远保住这难能可贵的品质。</p>
<p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=27rd0mjhb6v4s">https://cloud.tencent.com/developer/support-plan?invite_code=27rd0mjhb6v4s</a></p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Harper说</tag>
      </tags>
  </entry>
  <entry>
    <title>雨崩徒步保姆级攻略——写给去雨崩旅游顺便徒步的小白</title>
    <url>/2021/11/07/yubeng-hiking/</url>
    <content><![CDATA[<p>10.28-11.2 去了云南香格里拉。本来团队旅游是打算去宁夏中卫的，但是无奈疫情导致当地不接待游客了，所以临时改道去了雨崩，不过到了之后觉得还是很不错的。因为听说雨崩徒步还是要做些准备的，所以在网上也恶补了一些攻略，做了一些准备，但是去过之后发现，还是有些不够详实的地方，要真正去过了之后才知道。所以感觉有必要写下来，供别人参考。</p>
<p>来找攻略的人，必是已经知道雨崩有多值得去了，这里就不想花太多篇幅去描述雨崩有多好，毕竟雨崩的好不是用言语和图片能展示的东西，就不开吹了。总之是值得去的。</p>
<span id="more"></span>
<h2 id="关于徒步路线"><a href="#关于徒步路线" class="headerlink" title="关于徒步路线"></a>关于徒步路线</h2><ol>
<li>西当进村</li>
<li>上雨崩到冰湖</li>
<li>上雨崩到神湖</li>
<li>下雨崩到神瀑</li>
<li>通过尼农大峡谷出村。</li>
</ol>
<p>雨崩徒步基本就这几条，如果让我排这几条路线的难度，应该是 5 &gt; 3 &gt; 1 &gt; 2 &gt; 4。所以如果你抱着旅游顺便徒步的话，最多走 2、4。还有就是要有一个前提认知，雨崩徒步跟一般登山还不太一样，因为路线相对来说长一点，它是一会上坡，一会又下坡，然后最终的地方是比较高的。徒步的时候看地图的水平的距离就没啥用，因为可能水平距离就1km，但是它是个上坡，垂直高度上升了200m，其实这种路也是极难走的。</p>
<p>另外就是注意看路边树上挂的红的粉的那种布条，是徒步团挂着做宣传的，同时也是指路的，如果你看到布条，说明没走错，就是在大家都走的路线上。</p>
<p>有些路段是可以选择骑着骡子走的，不过费用不低，然后有些路段太陡骡子不能驼人，那就只能下来走。这里要注意，这里的牛、马和骡子，多少有点不讲卫生(手动狗头)，随地大小便，所以有洁癖就别来了，登山你也会很难受。</p>
<p>我这次走的路线是 2(稍微有点变种，这个稍后在表)和 4。</p>
<p>先说说进村，选择从西当徒步进村，不适合来旅游顺便徒步的人。因为这段路不好走，也没啥景色可看，人车不分流灰尘极大(开个玩笑，雨崩徒步就没有人车分流的道，这里后边会详细说)，而且不近，没怎么徒步过的人，估计走一半直接劝退了。所以我们一行人是 10.29 在西当坐越野车进来的，其实对于奔着旅游心态来的人来说，一次把几种方式尽可能体验到才最划算，所以坐那里的7座越野车是最好的，山路开起来非常刺激。</p>
<p>关于7座越野车，如果你看过别的攻略会告诉你尽可能少带行李，越野车不好装。确实。越野车的后边能放行李的地方很窄，就是普通行李箱的厚度那样的进深。但是能不能把行李带进去也取决于你脸够不够大。因为如果你硬要带进去，而且不提给钱的事，那里的人也能帮你想办法把行李带上，或者是他们有拉货的车刚好上山，或者是等到后边凑不够一车人的时候给行李几个座位。别问我是怎么知道的……另外就是越野车比较好的座位应该是副驾驶或者后两排的中间位置，因为旁边的位置，当车颠起来的时候，就只能用手臂做头的肉垫了，中间的话相当于两边的人做肉垫了。越野车会有两站，司机会提醒，先到上雨崩，再到下雨崩。看自己下榻的地方选择下车地点就行。</p>
<p>为什么 2、3、4 出发点不一样有的在上雨崩、有的在下雨崩呢，这是选了比较方便的出发点。神瀑距离下雨崩比较近，如果从上雨崩去神瀑就要先从上雨崩走到下雨崩。另外两条也是一个意思。所以来这里徒步的人一般会选择先住在上雨崩，然后走上雨崩的路线，然后走完就去下雨崩住，走神瀑，这样的话等于只走一个上雨崩到下雨崩的下坡路，不会在上雨崩和下雨崩反复横跳。为什么我前边说我走的是个变种，是因为我走了下雨崩到冰湖。原因就是临时决定去雨崩，又赶上这个时候转山节，很多徒步的，上雨崩已经没得住了。所以去冰湖那天比大部分人多走了一个下雨崩到上雨崩的上坡。</p>
<h2 id="准备物品"><a href="#准备物品" class="headerlink" title="准备物品"></a>准备物品</h2><p>下面说说我带的东西：登山杖、登山鞋、登山包、冲锋衣、偏光镜、头灯、食物、手套、帽子、防晒霜、水、现金。我应该是我们团里边带的最全的了，因为我是第一次登山徒步，又听说要做些准备，所以难免做的比较充分，后来事实证明这些东西里边只有一样没什么用，其他的都用到了。</p>
<p>下边说说这些东西为什么是需要的</p>
<p>登山杖(必备)：如果只是走神瀑其实不用也还好，这个后边再说。如果走其他路线，登山杖一定是必备的，当然这东西一般都不让带上飞机，你可以选择托运，或者是到了村里的客栈跟老板借或者租。这里对于新手有个提示，必带两根，两根就算是有用，一根没准还更累。登山杖下边有个泥托，最好是带上，这样有泥地好搞一点。</p>
<p>登山鞋(选备)：雨崩的路线都是登山，除了神瀑差不多有一半是石板路之外，其他路线都是山路土路、有水就是泥路、石子路，首先是防滑，登山鞋会有一些基本的防滑措施，如果不是冬天，不带冰爪，登山鞋的防滑就够用；其次防水，这样走一些稍微浅一点涉水的地方会比较好走，也不至于一不小心湿了鞋就要一直湿着走；第三是中帮或高帮会防止有一些沙子、石子什么的进到鞋里；第四登山鞋前部是有加固的，不至于前边的人踩不稳踩下一块石头砸你脚趾，这就很伤了。tips：如果你穿了登山鞋，记得要穿一个高靿袜子，因为如果穿矮靿袜子，会被鞋的帮磨到脚踝，走一天下来脚脖子肯定磨掉皮了。</p>
<p>登山包(选备)：这个看带的东西多不多吧，如果是旅游顺便徒步的话，其实背个书包也行，只要能装下沿途用到的东西就行，如果你的负重很大，就有必要用专业的登山包，负重系统比较好一点，但是一般好的登山包后边都会有块铁板保证支撑，会增加负重，所以小白可以不用登山包。</p>
<p>冲锋衣(必备)：其实也可以算选备，但是如果有冲锋衣会非常方便，我用的是迪卡侬的那种三合一的加绒冲锋衣。内胆可拆卸。冲锋衣也会有基本的防水，也比较防风。这个时间去雨崩，在村里早晚或者是在山上的白天跟东北的冬天就是一样冷的，然后中午又跟夏天一样。那这样出发或者到山顶的时候就可以带着内胆穿，中午热了可以把绒拆下来，只穿外边防风。而且山里有时候会下雨、下雪，有个冲锋衣会方便很多。我在下山的时候就经历了下雨、下雪两种。</p>
<p>偏光镜(选备)：我原来是听说阳光比较刺眼，需要一个墨镜，我就买了个偏光镜，结果没想到有点过分了，戴上去之后看路都费劲，只要一个轻度的墨镜就行，大部分时间都在山里周围很多树，其实比较重度的眼镜是用不到的，戴上去之后看不清路反而不好走。所以就这个我根本没用上。</p>
<p>头灯(选备)：之前的攻略说去厕所没灯，需要一个，其实现在客栈什么的都已经挺好了，用不上了。去冰湖的路上我也以为这个也白买了，但是没想到，上山的时候我太乐观了，下山就尴尬了，体力也有点不行了，走的比较慢，刚下到平地都还有很长一段距离才到上雨崩的时候，天就完全黑了，我们有些人是拿手机照，我就把头灯打开了。建议备一个，但愿用不上，但需要的时候没有就比较麻烦，因为那个时候有可能你的手机也没电了，假如还是在山上就更麻烦。</p>
<p>食物、水(必备)：冰湖的路线两瓶水绝对不够，我们大多数人基本两瓶水，但是回来的时候已经要省着喝了。中间有个补给点，笑农大本营那里可以买些东西，水、泡面什么的。贵是比较正常的，我在那里加了一壶热水，10块，但是他那边的壶已经烧的有点糊了，加的水喝着有些焦味。泡面一桶 20 块。建议还是自己带点可以快速恢复能量的，一般就是士力架、巧克力、葡萄糖或者能量棒等……</p>
<p>手套(必备)：因为登山杖是必备的，手套就一定是必备的，登山杖用之前在网上查查怎么用，不是当拐棍用的，要把腕带握在手上，具体的可以去网上查，所以走一天，手就会被磨到了。这里有个建议，不要戴露手指头的手套，因为这个时间在山上，手套会有御寒的作用，如果是露手指的，到了冰湖上边的坡那里，绝对把手冻麻。</p>
<p>帽子、防晒霜(必备)：作用就是防晒，虽然眼镜意义不大，但是防晒的意义大，高原紫外线很足，帽子遮住大部分，防晒霜做一个补充，基本上就不会被晒坏了。</p>
<p>现金(必备)：因为补给点可能没有信号，刷不了二维码。</p>
<p>氧气瓶(选备)：我没有带，但是同行的人有带的，这个看人吧。根据一般的经验，如果指着这个上山，其实还是挺困难的，吸了之后会有种依赖，停不下来，就得一直吸，那带一罐肯定就不太够。雨崩村去到冰湖大概也就是从 3400m 到 3900m 如果出发的时候没有高反的话，其实还好，不太可能爬山的时候出现高反，所以不带倒是也行。</p>
<h2 id="关于冰湖"><a href="#关于冰湖" class="headerlink" title="关于冰湖"></a>关于冰湖</h2><p>冰湖这条路线难度介于徒步爱好者和普通小白之间吧，就是普通小白也是可以走的，就是要做好心理准备而已，如果不是高反了，基本应该也都能走下来那种。我是 10.30 徒步冰湖。这条路线有几个关键点，一个是笑农垭口，这里有个观景台，在这里能看到雪山，拍照也是非常不错的。如果只是到笑农垭口，那可以说难度降低了一半吧。从笑农垭口再往前，就跟前边不太一样了，难度就上升了，而且有一段路会没有信号，我们队伍中就是有人因为没信号，也没跟大部队一起，结果自己走错路了。路会比之前的不好走一点，然后会到笑农大本营，那里就是前边我说的补给点，可以补充热水或者休息，这里我的联通是一点信号都没有的，只能用现金。然后就是终点了，有的人会选择走到湖边，有的人是走到湖前边的山坡上在那里拍照之后就回去了。</p>
<p>如果打算返程的时候走不动了骑骡子，要注意时间，太晚了骡子也下班了，它们是不加班的。登山的时候基本上没什么固定路线，都是之前走过的踩出来的路线，但是有些比较陡峭，有些比较缓，当然比较缓的要绕远路。不过这里对于新手来说尽量选择缓的路，不要怕绕远路，因为选择比较陡峭的路其实对体能也是比较大的消耗。对于没怎么徒步过的人出发的时候会过于乐观，回去的时候就异常艰难。要时刻记得曾经去程走过的上坡都会变为回程的下坡，反过来也是一样。所以要分配好体力，分配不好就得像我一样走回客栈的那几步差点躺了……</p>
<p>平缓的路要怎么找呢，一个是自己观察，还有一个，就是我之前说到，雨崩的路人车不分流，骡子也是要上山的，它们多少有点不讲卫生，会随地大小便。可以看着它们的粪便找路就好，它们都是走最好走的那条。</p>
<p>同行的导游扎西说可以骑骡子，但是实际上骑骡子上去之后，腿也会很痛，其实路难走，骑骡子也不会舒服到哪里去。第二天可能反而还没法走了。</p>
<p>这个季节其实路算比较好走了，因为那种泥地比较少，算是相对来说比较干燥，比较硬的。估计雨季的时候、或者温度高的时候，路会比较难走。</p>
<p>冰湖回来的时候，整个人都不好了，脸上都没有血色了。我确实体力也差了点，但是负重也是大，背包上边有块铁板，就有点吃不消了，还帮同事背了一个无人机，最尴尬的是，到地方还没飞。所以建议是在保证所需之后，尽可能地少背东西。尤其是平时不怎么徒步的，要做好心理准备。</p>
<h2 id="关于神瀑"><a href="#关于神瀑" class="headerlink" title="关于神瀑"></a>关于神瀑</h2><p>如果走过了冰湖、神瀑的难度可以说就不用放在心上了。我是 10.31 徒步神瀑，其中有一半都是石板路，就会比较好走，中间也会有一个补给点，据我观察这个补给点还丰富一些，可以吃一些小笼包、玉米、牦牛奶等等，这里可以刷二维码，但是我的联通依旧刷不出来，所以最好都带现金，而且在神瀑下也可以用现金来祈福，就比较方便。</p>
<p>神瀑要注意的就是，石板路在下来的时候，走多了可能对膝盖会有一定的压力，可以侧身或者类似八字脚那样下，会好一点点。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>推荐一个 APP，名字叫<strong>两步路</strong>,户外用的一个 APP，用 GPS 的，里边有很多人分享自己的轨迹，当然雨崩相关的轨迹也能搜到不少，可以加载他们的轨迹，来判断你走了多少，距离目的地还有多远。不过这个东西还挺耗电的，自己根据情况使用吧。</p>
<p>之前翻阅其他攻略，最大的问题是，找不到这个时间应该穿什么衣服，这里详细说下我自己：上身南极人保暖内衣(秋衣)，加绒冲锋衣，路上看温度，热了就拆绒穿，冷了就加绒穿；下身南极人保暖内衣(秋裤)，一个稍微带点厚度的运动裤。其实本来还带了棉裤，但是到那里发现倒是用不上，而且登山也不方便。</p>
<p>关于雨崩的美景美图就不发了，马蜂窝上一搜一把，不过我想说的是，其实照片再好看，都不如亲身去体会，一是照片也做不到完全还原我们眼睛看到的那种美，二是当你走到目的地的时候，其实景色是一方面，而那种成功的喜悦会给自己的感受带来更深层次的加持，那是一种复合体验，是看图体会不到的。</p>
]]></content>
      <categories>
        <category>IT-Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>徒步</tag>
        <tag>旅行</tag>
        <tag>雨崩</tag>
        <tag>攻略</tag>
      </tags>
  </entry>
</search>
